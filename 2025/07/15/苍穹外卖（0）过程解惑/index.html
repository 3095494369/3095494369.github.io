<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>苍穹外卖（0）过程解惑 | my-blog</title><meta name="author" content="浮生若梦"><meta name="copyright" content="浮生若梦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DTO,VO,Entity(实体类)区别   类型 全称 作用 用途    VO Value Object 值对象，表示只读的展示数据 通常用于前端展示层，封装用户需要展示的数据，包装返回的数据   DTO Data Transfer Object 数据传输对象，用于系统内部层与层之间的数据传输 常用于 Controller ↔ Service 或远程接口间的数据传输   实体类（Entity）">
<meta property="og:type" content="article">
<meta property="og:title" content="苍穹外卖（0）过程解惑">
<meta property="og:url" content="http://example.com/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/index.html">
<meta property="og:site_name" content="my-blog">
<meta property="og:description" content="DTO,VO,Entity(实体类)区别   类型 全称 作用 用途    VO Value Object 值对象，表示只读的展示数据 通常用于前端展示层，封装用户需要展示的数据，包装返回的数据   DTO Data Transfer Object 数据传输对象，用于系统内部层与层之间的数据传输 常用于 Controller ↔ Service 或远程接口间的数据传输   实体类（Entity）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/touxiang.jpg">
<meta property="article:published_time" content="2025-07-15T03:37:18.000Z">
<meta property="article:modified_time" content="2025-07-17T00:49:38.081Z">
<meta property="article:author" content="浮生若梦">
<meta property="article:tag" content="后端开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "苍穹外卖（0）过程解惑",
  "url": "http://example.com/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/",
  "image": "http://example.com/image/touxiang.jpg",
  "datePublished": "2025-07-15T03:37:18.000Z",
  "dateModified": "2025-07-17T00:49:38.081Z",
  "author": [
    {
      "@type": "Person",
      "name": "浮生若梦",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '苍穹外卖（0）过程解惑',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/dingbutu.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">my-blog</span></a><a class="nav-page-title" href="/"><span class="site-name">苍穹外卖（0）过程解惑</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">苍穹外卖（0）过程解惑</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-15T03:37:18.000Z" title="发表于 2025-07-15 11:37:18">2025-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-17T00:49:38.081Z" title="更新于 2025-07-17 08:49:38">2025-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/">实战项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="DTO-VO-Entity-实体类-区别"><a href="#DTO-VO-Entity-实体类-区别" class="headerlink" title="DTO,VO,Entity(实体类)区别"></a>DTO,VO,Entity(实体类)区别</h1><table>
<thead>
<tr>
<th>类型</th>
<th>全称</th>
<th>作用</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>VO</td>
<td>Value Object</td>
<td>值对象，表示<strong>只读的展示数据</strong></td>
<td>通常用于前端展示层，封装用户需要展示的数据，<strong>包装返回的数据</strong></td>
</tr>
<tr>
<td>DTO</td>
<td>Data Transfer Object</td>
<td>数据传输对象，用于<strong>系统内部层与层之间的数据传输</strong></td>
<td>常用于 Controller ↔ Service 或远程接口间的<strong>数据传输</strong></td>
</tr>
<tr>
<td>实体类（Entity）</td>
<td>实体类&#x2F;模型类</td>
<td>表示数据库中的一张表</td>
<td>用于 ORM 映射（如 JPA、MyBatis），直接与数据库交互</td>
</tr>
</tbody></table>
<h1 id="数据库字段与变量名的对应"><a href="#数据库字段与变量名的对应" class="headerlink" title="数据库字段与变量名的对应"></a>数据库字段与变量名的对应</h1><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/image-20250715145106151.png" class="" alt="image-20250715145106151">

<h1 id="统一登录验证—JWT令牌"><a href="#统一登录验证—JWT令牌" class="headerlink" title="统一登录验证—JWT令牌"></a>统一登录验证—JWT令牌</h1><h1 id="统一封装返回给前端的结果-Result封装返回结果"><a href="#统一封装返回给前端的结果-Result封装返回结果" class="headerlink" title="统一封装返回给前端的结果-Result封装返回结果"></a>统一封装返回给前端的结果-Result封装返回结果</h1><p>进入sky-common模块，在com.sky.result包下定义了Result.java</p>
<pre><code class="language-java">package com.sky.result;

import lombok.Data;

import java.io.Serializable;

/**
 * 后端统一返回结果
 * @param &lt;T&gt;
 */
@Data
public class Result&lt;T&gt; implements Serializable &#123;

    private Integer code; //编码：1成功，0和其它数字为失败
    private String msg; //错误信息
    private T data; //数据

    public static &lt;T&gt; Result&lt;T&gt; success() &#123;
        Result&lt;T&gt; result = new Result&lt;T&gt;();
        result.code = 1;
        return result;
    &#125;

    public static &lt;T&gt; Result&lt;T&gt; success(T object) &#123;
        Result&lt;T&gt; result = new Result&lt;T&gt;();
        result.data = object;
        result.code = 1;
        return result;
    &#125;

    public static &lt;T&gt; Result&lt;T&gt; error(String msg) &#123;
        Result result = new Result();
        result.msg = msg;
        result.code = 0;
        return result;
    &#125;

&#125;
</code></pre>
<h1 id="DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils"><a href="#DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils" class="headerlink" title="DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils"></a>DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils</h1><blockquote>
<p>注意：</p>
<p>​	前端传来的数据字段 和 插入数据库中的字段数量不一致，缺少的需要补充。</p>
</blockquote>
<img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/image-20250715155059419.png" class="" alt="image-20250715155059419">

<p>对应代码如下：</p>
<pre><code class="language-java"> //对象属性拷贝
BeanUtils.copyProperties(employeeDTO, employee);

//设置账号的状态，默认正常状态 1表示正常 0表示锁定-------为了代码的可读性，将其封装为了常量类StatusConstant.java
employee.setStatus(StatusConstant.ENABLE);

//设置密码，默认密码123456
employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
</code></pre>
<h1 id="如何从JWT令牌中动态获取当前登录人的id。"><a href="#如何从JWT令牌中动态获取当前登录人的id。" class="headerlink" title="如何从JWT令牌中动态获取当前登录人的id。"></a>如何从JWT令牌中动态获取当前登录人的id。</h1><p><strong>1. JWT令牌中携带的id信息</strong></p>
<p><strong>2. 将id放到线程中</strong></p>
<p>因为在员工登录成功后生成的JWT令牌，后端会返回一个JWT令牌给前端，在后续的请求中，前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id。</p>
<pre><code class="language-java">  try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            //解析出令牌中的id
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //将解析出的id，放到线程中
      //--------------------------------------
            BaseContext.setCurrentId(empId);
	//-------------------------------------
            
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
</code></pre>
<p><strong>解析出登录员工id后，如何传递给Service的save方法？</strong></p>
<p>​	通过ThreadLocal进行传递。</p>
<p>在sky-common模块，中的com.sky.context</p>
<pre><code class="language-java">package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;

&#125;
</code></pre>
<p><strong>在Service中获取线程局部变量中的值：</strong></p>
<pre><code class="language-java">/**
     * 新增员工
     *
     * @param employeeDTO
     */
    public void save(EmployeeDTO employeeDTO) &#123;
        //.............................

        //设置当前记录创建人id和修改人id
        employee.setCreateUser(BaseContext.getCurrentId());//目前写个假数据，后期修改
        employee.setUpdateUser(BaseContext.getCurrentId());

        employeeMapper.insert(employee);
    &#125;
</code></pre>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><strong>介绍：</strong></p>
<p>ThreadLocal 并不是一个Thread，而是Thread的局部变量。<br>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>public void set(T value) 	设置当前线程的线程局部变量的值</li>
<li>public T get() 		返回当前线程所对应的线程局部变量的值</li>
<li>public void remove()        移除当前线程的线程局部变量</li>
</ul>
<p>对ThreadLocal有了一定认识后，接下来继续解决<strong>问题二</strong></p>
<img src="D:\我的博客\myblog\source\_posts\苍穹外卖（0）过程解惑\image-20221111212349365.png" alt="image-20221111212349365" style="zoom:67%;" /> 

<p>ThreadLocal 操作的工具类：</p>
<pre><code class="language-java">package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;

&#125;
</code></pre>
<h1 id="统一分页查询"><a href="#统一分页查询" class="headerlink" title="统一分页查询"></a>统一分页查询</h1><p>统一都封装为PageResult对象。</p>
<p>在sky-common模块</p>
<pre><code class="language-java">package com.sky.result;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

/**
 * 封装分页查询结果
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable &#123;

    private long total; //总记录数

    private List records; //当前页数据集合

&#125;
</code></pre>
<p>在EmployeeServiceImpl中实现pageQuery方法：</p>
<pre><code class="language-java">	/**
     * 分页查询
     *
     * @param employeePageQueryDTO
     * @return
     */
    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;
        // select * from employee limit 0,10
        //开始分页查询
        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());

        Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);//后续定义

        long total = page.getTotal();
        List&lt;Employee&gt; records = page.getResult();

        return new PageResult(total, records);
    &#125;
</code></pre>
<p>**注意：**此处使用 mybatis 的分页插件 PageHelper 来简化分页代码的开发。底层基于 mybatis 的拦截器实现。</p>
<p>故在pom.xml文中添加依赖(初始工程已添加)</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
   &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;$&#123;pagehelper&#125;&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="统一日期格式-全局处理"><a href="#统一日期格式-全局处理" class="headerlink" title="统一日期格式-全局处理"></a>统一日期格式-全局处理</h1><p>在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理</p>
<p> Spring MVC 框架的 <strong>消息转换器扩展（MessageConverter）</strong>，核心目的是用自定义的 <code>JacksonObjectMapper</code> 来替代 Spring 默认的 Jackson 配置，从而定制 JSON 的序列化和反序列化行为。</p>
<pre><code class="language-java">	/**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
</code></pre>
<p>时间格式定义，sky-common模块中</p>
<pre><code class="language-java">/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper &#123;

    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;
    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;

    public JacksonObjectMapper() &#123;
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    &#125;
&#125;
</code></pre>
<h2 id="针对处理："><a href="#针对处理：" class="headerlink" title="针对处理："></a>针对处理：</h2><p>在属性上加上注解，对日期进行格式化</p>
<img src="D:\我的博客\myblog\source\_posts\苍穹外卖（0）过程解惑\image-20221112103501581.png" alt="image-20221112103501581" style="zoom:67%;" /> 

<p>但这种方式，需要在每个时间属性上都要加上该注解，使用较麻烦，不能全局处理。</p>
<h1 id="自定义注解切面编程"><a href="#自定义注解切面编程" class="headerlink" title="自定义注解切面编程"></a>自定义注解切面编程</h1><p><strong>我们使用AOP切面编程，实现功能增强，来完成公共字段自动填充功能。</strong></p>
<p><strong>实现步骤：</strong></p>
<p>1). 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法</p>
<p>2). 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</p>
<p>3). 在 Mapper 的方法上加入 AutoFill 注解</p>
<p><strong>自定义注解：</strong></p>
<pre><code class="language-java">package com.sky.annotation;

import com.sky.enumeration.OperationType;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill &#123;
    //数据库操作类型：UPDATE INSERT
    OperationType value();
&#125;
</code></pre>
<p><strong>OperationType</strong></p>
<p>在sky-common模块中定义</p>
<pre><code class="language-java">package com.sky.enumeration;

/**
 * 数据库操作类型
 */
public enum OperationType &#123;

    /**
     * 更新操作
     */
    UPDATE,

    /**
     * 插入操作
     */
    INSERT
&#125;
</code></pre>
<p><strong>自定义切面类：</strong></p>
<pre><code class="language-java">package com.sky.aspect;
import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import java.lang.reflect.Method;
import java.time.LocalDateTime;
/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;

    /**
     * 切入点
     */
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    /**
     * 前置通知，在通知中进行公共字段的赋值
     */
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint)&#123;
        log.info(&quot;开始进行公共字段自动填充...&quot;);

        //获取到当前被拦截的方法上的数据库操作类型
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象
        OperationType operationType = autoFill.value();//获得数据库操作类型

        //获取到当前被拦截的方法的参数--实体对象
        Object[] args = joinPoint.getArgs();
        if(args == null || args.length == 0)&#123;
            return;
        &#125;

        Object entity = args[0];

        //准备赋值的数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        //根据当前不同的操作类型，为对应的属性通过反射来赋值
        if(operationType == OperationType.INSERT)&#123;
            //为4个公共字段赋值
            try &#123;
                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

                //通过反射为对象属性赋值
                setCreateTime.invoke(entity,now);
                setCreateUser.invoke(entity,currentId);
                setUpdateTime.invoke(entity,now);
                setUpdateUser.invoke(entity,currentId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;else if(operationType == OperationType.UPDATE)&#123;
            //为2个公共字段赋值
            try &#123;
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

                //通过反射为对象属性赋值
                setUpdateTime.invoke(entity,now);
                setUpdateUser.invoke(entity,currentId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>4）：对方法加上AutoFill注解</strong></p>
<p>Mapper接口的方法上添加，来代替公共字段</p>
<pre><code class="language-java"> 	
	/**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    @AutoFill(value = OperationType.INSERT)
    void insert(Category category);
    /**
     * 根据id修改分类
     * @param category
     */
    @AutoFill(value = OperationType.UPDATE)
    void update(Category category);
</code></pre>
<p>这样在Service实现层上就可以省略公共字段的填充。</p>
<p>例如：</p>
<pre><code class="language-java">   	/**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);
        //在mapper层添加了注解   @AutoFill(value = OperationType.INSERT)，来自挂填充公共字段
//        //设置创建时间、修改时间、创建人、修改人
//        category.setCreateTime(LocalDateTime.now());
//        category.setUpdateTime(LocalDateTime.now());
//        category.setCreateUser(BaseContext.getCurrentId());
//        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.insert(category);
    &#125;
	/**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);
        //在mapper层添加了注解   @AutoFill(value = OperationType.update)，来自挂填充公共字段
//        //设置修改时间、修改人
//        category.setUpdateTime(LocalDateTime.now());
//        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">浮生若梦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/">http://example.com/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">my-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></div><div class="post-share"><div class="social-share" data-image="/image/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/" title="苍穹外卖（三）公共字段填充、菜品CRUD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">苍穹外卖（三）公共字段填充、菜品CRUD</div></div><div class="info-2"><div class="info-item-1">公共字段填充问题分析在新增员工或者新增菜品分类时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工或者编辑菜品分类时需要设置修改时间、修改人等字段。这些字段属于公共字段，也就是也就是在我们的系统中很多表中都会有这些字段，如下：    序号 字段名 含义 数据类型    1 create_time 创建时间 datetime   2 create_user 创建人id bigint   3 update_time 修改时间 datetime   4 update_user 修改人id bigint   而针对于这些字段，我们的赋值方式为：  1). 在新增数据时, 将createTime、updateTime 设置为当前时间, createUser、updateUser设置为当前登录用户ID。 2). 在更新数据时, 将updateTime 设置为当前时间, updateUser设置为当前登录用户ID。 解决方案我们使用AOP切面编程，实现功能增强，来完成公共字段自动填充功能。 实现步骤： 1). 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法 2)...</div></div></div></a><a class="pagination-related" href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/" title="苍穹外卖（二）员工管理、菜品分类管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">苍穹外卖（二）员工管理、菜品分类管理</div></div><div class="info-2"><div class="info-item-1">新增员工需求分析与设计产品原型  当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据, 然后将数据保存至数据库中。 注意事项：  账号必须是唯一的 手机号为合法的11位手机号码 身份证号为合法的18位身份证号码 密码默认为123456  接口设计  表设计新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。 employee表结构：    字段名 数据类型 说明 备注    id bigint 主键 自增   name varchar(32) 姓名    username varchar(32) 用户名 唯一   password varchar(64) 密码    phone varchar(11) 手机号    sex varchar(2) 性别    id_number varchar(18) 身份证号    status Int 账号状态 1启用0禁用   create_time Datetime 创建时间    update_time datetime 最后修改时间    create_user bigin...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/" title="苍穹外卖（三）公共字段填充、菜品CRUD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-16</div><div class="info-item-2">苍穹外卖（三）公共字段填充、菜品CRUD</div></div><div class="info-2"><div class="info-item-1">公共字段填充问题分析在新增员工或者新增菜品分类时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工或者编辑菜品分类时需要设置修改时间、修改人等字段。这些字段属于公共字段，也就是也就是在我们的系统中很多表中都会有这些字段，如下：    序号 字段名 含义 数据类型    1 create_time 创建时间 datetime   2 create_user 创建人id bigint   3 update_time 修改时间 datetime   4 update_user 修改人id bigint   而针对于这些字段，我们的赋值方式为：  1). 在新增数据时, 将createTime、updateTime 设置为当前时间, createUser、updateUser设置为当前登录用户ID。 2). 在更新数据时, 将updateTime 设置为当前时间, updateUser设置为当前登录用户ID。 解决方案我们使用AOP切面编程，实现功能增强，来完成公共字段自动填充功能。 实现步骤： 1). 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法 2)...</div></div></div></a><a class="pagination-related" href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" title="苍穹外卖（一）环境准备"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-15</div><div class="info-item-2">苍穹外卖（一）环境准备</div></div><div class="info-2"><div class="info-item-1">  我的gitee仓库，内涵源代码https://gitee.com/zhouhuiqiang5704/sky-cqwm.git  软件开发流程需求分析完成需求规格说明书、产品原型编写。   需求规格说明书： 一般来说就是使用 Word 文档来描述当前项目的各个组成部分，如：系统定义、应用环境、功能规格、性能需求等，都会在文档中描述。例如：   产品原型：一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。 例如：   设计设计的内容包含 UI设计、数据库设计、接口设计。 UI设计：用户界面的设计，主要设计项目的页面效果，小到一个按钮，大到一个页面布局，还有人机交互逻辑的体现。 数据库设计：需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段。例如：   接口设计：通过分析原型图，首先，粗粒度地分析每个页面有多少接口，然后，再细粒度地分析每个接口的传入参数，返回值参数，同时明确接口路径及请求方式。例如...</div></div></div></a><a class="pagination-related" href="/2025/07/22/%E8%8B%A5%E4%BE%9D%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%AF%E5%8A%A8%E5%87%86%E5%A4%87/" title="若依后台管理系统（一）启动准备"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">若依后台管理系统（一）启动准备</div></div><div class="info-2"><div class="info-item-1">相关文档 前后端分离相关文档：介绍 | RuoYi  启动项目版本要求： JDK &gt;= 1.8 (推荐1.8版本) Mysql &gt;= 5.7.0 (推荐5.7版本) Redis &gt;= 3.0 Maven &gt;= 3.0 Node &gt;= 12  前端： # 进入项目目录 cd ruoyi-ui  # 安装依赖 npm install  # 强烈建议不要用直接使用 cnpm 安装，会有各种诡异的 bug，可以通过重新指定 registry 来解决 npm 安装速度慢的问题。 npm install --registry=https://registry.npmmirror.com  # 本地开发 启动项目 npm run dev  后端修改必要的配置和开启启动项：  修改数据库连接，编辑resources目录下的application-druid.yml  # 数据源配置 spring:     datasource:         type: com.alibaba.druid.pool.DruidDataSource         driverCl...</div></div></div></a><a class="pagination-related" href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/" title="苍穹外卖（二）员工管理、菜品分类管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-15</div><div class="info-item-2">苍穹外卖（二）员工管理、菜品分类管理</div></div><div class="info-2"><div class="info-item-1">新增员工需求分析与设计产品原型  当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据, 然后将数据保存至数据库中。 注意事项：  账号必须是唯一的 手机号为合法的11位手机号码 身份证号为合法的18位身份证号码 密码默认为123456  接口设计  表设计新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。 employee表结构：    字段名 数据类型 说明 备注    id bigint 主键 自增   name varchar(32) 姓名    username varchar(32) 用户名 唯一   password varchar(64) 密码    phone varchar(11) 手机号    sex varchar(2) 性别    id_number varchar(18) 身份证号    status Int 账号状态 1启用0禁用   create_time Datetime 创建时间    update_time datetime 最后修改时间    create_user bigin...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">浮生若梦</div><div class="author-info-description">世界为什么会一直转,因为她不希望我们每个人停留下来,她希望我们向前看!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DTO-VO-Entity-%E5%AE%9E%E4%BD%93%E7%B1%BB-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">DTO,VO,Entity(实体类)区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E4%B8%8E%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="toc-number">2.</span> <span class="toc-text">数据库字段与变量名的对应</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E2%80%94JWT%E4%BB%A4%E7%89%8C"><span class="toc-number">3.</span> <span class="toc-text">统一登录验证—JWT令牌</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E7%BB%99%E5%89%8D%E7%AB%AF%E7%9A%84%E7%BB%93%E6%9E%9C-Result%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">4.</span> <span class="toc-text">统一封装返回给前端的结果-Result封装返回结果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DTO%EF%BC%88%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%EF%BC%89%E5%92%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E2%80%94-BeanUtils"><span class="toc-number">5.</span> <span class="toc-text">DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8EJWT%E4%BB%A4%E7%89%8C%E4%B8%AD%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E4%BA%BA%E7%9A%84id%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">如何从JWT令牌中动态获取当前登录人的id。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">7.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.</span> <span class="toc-text">统一分页查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F-%E5%85%A8%E5%B1%80%E5%A4%84%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">统一日期格式-全局处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">针对处理：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">自定义注解切面编程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/14/%E9%9D%92%E6%88%88%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/" title="文件上传与下载">文件上传与下载</a><time datetime="2025-08-14T08:25:57.000Z" title="发表于 2025-08-14 16:25:57">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/22/%E8%8B%A5%E4%BE%9D%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%AF%E5%8A%A8%E5%87%86%E5%A4%87/" title="若依后台管理系统（一）启动准备">若依后台管理系统（一）启动准备</a><time datetime="2025-07-22T06:40:43.000Z" title="发表于 2025-07-22 14:40:43">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/" title="SpringAop切面类">SpringAop切面类</a><time datetime="2025-07-16T02:39:10.000Z" title="发表于 2025-07-16 10:39:10">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/SpringSecurity/" title="SpringSecurity">SpringSecurity</a><time datetime="2025-07-16T02:39:10.000Z" title="发表于 2025-07-16 10:39:10">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/" title="苍穹外卖（三）公共字段填充、菜品CRUD">苍穹外卖（三）公共字段填充、菜品CRUD</a><time datetime="2025-07-16T02:29:34.000Z" title="发表于 2025-07-16 10:29:34">2025-07-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By 浮生若梦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>