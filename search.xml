<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringAop切面类</title>
      <link href="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/"/>
      <url>/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Aop——-这是基于路径匹配的AOP—切点是方法名"><a href="#什么是Aop——-这是基于路径匹配的AOP—切点是方法名" class="headerlink" title="什么是Aop——-这是基于路径匹配的AOP—切点是方法名"></a>什么是Aop——-这是基于路径匹配的AOP—切点是方法名</h1><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091010268.png" class="" alt="image-20250703091256278"><p><em><strong>方法中存在相同的业务需求的代码，可以通过AOP动态植入这部分的代码。</strong></em></p><h1 id="AOP的应用场景"><a href="#AOP的应用场景" class="headerlink" title="AOP的应用场景"></a>AOP的应用场景</h1><p>D<img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091505678.png" class="" alt="image-20250703091505678"></p><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091623178.png" class="" alt="image-20250703091623178"><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091704225.png" class="" alt="image-20250703091704225"><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100011716.png" class="" alt="image-20250703100011716"><h1 id="AOP中的主要概念"><a href="#AOP中的主要概念" class="headerlink" title="AOP中的主要概念"></a>AOP中的主要概念</h1><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100409875.png" class="" alt="image-20250703100409875"><h2 id="Aspect中通知的种类"><a href="#Aspect中通知的种类" class="headerlink" title="Aspect中通知的种类"></a>Aspect中通知的种类</h2><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100559967.png" class="" alt="image-20250703100559967"><h1 id="如何写切面类"><a href="#如何写切面类" class="headerlink" title="如何写切面类"></a>如何写切面类</h1><p>切面：切入方法的集合类</p><p>切点：规定执行方法的执行条件</p><p>通知：当执行时是如何执行的</p><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100804430.png" class="" alt="image-20250703100804430"><h2 id="实现步骤代码示例"><a href="#实现步骤代码示例" class="headerlink" title="实现步骤代码示例"></a>实现步骤代码示例</h2><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703101235652.png" class="" alt="image-20250703101235652"><p>依赖：</p><pre><code class="language-java">&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;      &lt;version&gt;3.2.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;6.2.6&lt;/version&gt;    &lt;/dependency&gt;</code></pre><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703101333049.png" class="" alt="image-20250703101333049"><p>controller.* : 指controller包下所有的类</p><p>controller.* .*(): 指controller包下所有的类的所有方法</p><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703102835162.png" class="" alt="image-20250703102835162"><p>pjp.getSignature().getname()：获取方法名</p><p>pjp.getTarfet().getClass().toString()：获取类名</p><p>pjp.geArgs(): 获取参数名</p><p>pjp.proceed() ： 执行方法</p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>测试方法：</p><pre><code class="language-java">package org.example.Controller;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.*;@Slf4j@RestController@RequestMapping(&quot;/Aop&quot;)public class CalculatorController &#123;    // http://localhost:8080/Aop/add?a=5&amp;b=3    @GetMapping(&quot;/add&quot;)    public String add(@RequestParam double a, @RequestParam double b) &#123;        log.info(&quot;这是加法&quot;);        return &quot;结果：&quot; + (a + b);    &#125;    // http://localhost:8080/Aop/sub?a=5&amp;b=3    @GetMapping(&quot;/sub&quot;)    public String subtract(@RequestParam double a, @RequestParam double b) &#123;        return &quot;结果：&quot; + (a - b);    &#125;    // http://localhost:8080/Aop/mul?a=5&amp;b=3    @GetMapping(&quot;/mul&quot;)    public String multiply(@RequestParam double a, @RequestParam double b) &#123;        return &quot;结果：&quot; + (a * b);    &#125;    // http://localhost:8080/Aop/div?a=6&amp;b=3    @GetMapping(&quot;/div&quot;)    public String divide(@RequestParam double a, @RequestParam double b) &#123;        if (b == 0) &#123;            return &quot;错误：除数不能为 0&quot;;        &#125;        return &quot;结果：&quot; + (a / b);    &#125;</code></pre><p>切面类：</p><pre><code class="language-java">package org.example.Config;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;/*日志界面管理1.定义切面类-@Aspect (注：也要加载到容器中--@Component)2.定义切点-@Pointcut(value = &quot;execution(* org.example.Controller.*.*())&quot;)3.定义Advice通知优先级排列：    @Around：环绕通知    @Before：前置通知----调用方法    @AfterReturning：最终通知--在方法调用之后执行    @After：后置通知    @AfterThrowing：异常通知---只有出现异常才会执行 */@Aspect@Component@Slf4jpublic class LoggerAdvice &#123;    //2.定义切点-@Pointcut    /*    切点名称：controllerMethodsPointcut    作用区域：在返回类型不限的org.example.Controller包下的所有类的所有的有参方法     */    @Pointcut(value = &quot;execution(* org.example.Controller.*.*(..))&quot;)    public void controllerMethodsPointcut() &#123;    &#125;    //3.定义Advice通知        //环绕通知--作用于方法的全程    /*    @Around：环绕通知，只能使用ProceedingJoinPoint，其余通知使用JoinPoint    joinPoint.proceed():固定语句--表示执行该方法    className:获取类名    methodName：获取方法名    args:获取请求参数     */    @Around(&quot;controllerMethodsPointcut()&quot;)    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;        String className = joinPoint.getTarget().getClass().getName();        String methodName = joinPoint.getSignature().getName();        Object[] args = joinPoint.getArgs();        log.info(&quot;调用类名&#123;&#125;.方法名&#123;&#125;&quot;,className,methodName);        log.info(&quot;请求参数：&#123;&#125;&quot;, Arrays.toString(args));        Object result = joinPoint.proceed();        log.info(&quot;方法完成调用类名&#123;&#125;.方法名&#123;&#125;&quot;, className, methodName);        log.info(&quot;返回结果：&#123;&#125;&quot;, result);        return result;    &#125;    /*        * 前置通知--在方法调用之前执行        * @Before(&quot;controllerMethodsPointcut()&quot;)     */    @Before(&quot;controllerMethodsPointcut()&quot;)    public void beforeAdvice() &#123;        log.info(&quot;方法调用之前执行---------------------------------&quot;);    &#125;    /*        * 后置通知--在方法调用之后执行        * @After(&quot;controllerMethodsPointcut()&quot;)     */    @After(&quot;controllerMethodsPointcut()&quot;)    public void afterAdvice() &#123;        log.info(&quot;方法调用之后执行---------------------------------&quot;);    &#125;    /*        * 异常通知--在方法调用出现异常时执行        * @AfterThrowing(value = &quot;controllerMethodsPointcut()&quot;, throwing = &quot;ex&quot;)     */    @AfterThrowing(value = &quot;controllerMethodsPointcut()&quot;, throwing = &quot;ex&quot;)    public void afterThrowingAdvice(Exception ex) &#123;        log.error(&quot;方法调用出现异常：&#123;&#125;&quot;, ex.getMessage());    &#125;    /*        * 最终通知--在方法调用之后执行，无论是否出现异常        * @AfterReturning(value = &quot;controllerMethodsPointcut()&quot;, returning = &quot;result&quot;)     */    @AfterReturning(value = &quot;controllerMethodsPointcut()&quot;, returning = &quot;result&quot;)    public void afterReturningAdvice(Object result) &#123;        log.info(&quot;方法调用完成，返回结果：&#123;&#125;&quot;, result);    &#125;&#125;</code></pre><h1 id="基于注解的AOP–切点是注解（自定义）"><a href="#基于注解的AOP–切点是注解（自定义）" class="headerlink" title="基于注解的AOP–切点是注解（自定义）"></a>基于注解的AOP–切点是注解（自定义）</h1><blockquote><p>触发AOP可以是类名、方法名、参数、返回值类型，也可以是注解</p></blockquote><p><strong>1）：自定义注解</strong></p><p>进入到sky-server模块，创建com.sky.annotation包。</p><pre><code class="language-java">package com.sky.annotation;import com.sky.enumeration.OperationType;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AutoFill &#123;    //数据库操作类型：UPDATE INSERT    OperationType value();&#125;</code></pre><blockquote><p>解释如下：</p></blockquote><p><strong>1.<code>@Target(ElementType.METHOD)</code> —— 约束适用范围</strong></p><p><code>@Target</code> 是 <strong>元注解</strong>（用来修饰注解的注解），用来指定 <strong>AutoFill</strong> 只能放在什么元素上。</p><ul><li><code>ElementType.METHOD</code>：说明 <strong><em>只能</em> 用在方法</strong>声明上；不能放在类、字段、参数等位置。</li><li>常见的取值还包括 <code>TYPE</code>（类&#x2F;接口）、<code>FIELD</code>（字段）、<code>PARAMETER</code>（形参）……可以同时指定多个，例如 <code>&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;</code>。</li></ul><p><strong>2.<code>@Retention(RetentionPolicy.RUNTIME)</code> —— 生命周期</strong></p><p>另一枚元注解，决定编译后字节码里保留多久。</p><ul><li><code>SOURCE</code>：只存在于源码阶段，编译后即消失（如 Lombok 的大多数注解）。</li><li><code>CLASS</code>：编译后仍在 <code>.class</code> 文件中，但 <strong>运行时</strong> 通过反射拿不到（默认值）。</li><li><code>RUNTIME</code>：不仅编译期保留，而且 JVM 运行时依旧保留，可用反射读取——<strong>AOP、拦截器、框架自动装配</strong> 等场景全靠它。</li></ul><p>所以，这里选 <code>RUNTIME</code> 是为了在 <strong>拦截数据库操作的方法时</strong> 能获取注解信息，动态填充字段。</p><p><strong>3. <code>OperationType value();</code> —— 注解的属性</strong></p><ul><li>注解内部声明的方法就是<strong>属性</strong>（也叫“成员变量”）。</li><li>返回值可以是 <em>原始类型、String、Class、枚举、注解、以及它们的一维数组</em>。</li><li>如果属性名是 <code>value</code>，使用时可以省略 <code>value =</code>，见下方示例。</li></ul><p><strong>2）：OperationType</strong></p><p>在sky-common模块中定义</p><pre><code class="language-java">package com.sky.enumeration;/** * 数据库操作类型 */public enum OperationType &#123;    /**     * 更新操作     */    UPDATE,    /**     * 插入操作     */    INSERT&#125;</code></pre><p><strong>3）：自定义切面AutoFillAspect</strong></p><p>在sky-server模块，创建com.sky.aspect包。</p><pre><code class="language-java">package com.sky.aspect;import com.sky.annotation.AutoFill;import com.sky.constant.AutoFillConstant;import com.sky.context.BaseContext;import com.sky.enumeration.OperationType;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;import java.time.LocalDateTime;/** * 自定义切面，实现公共字段自动填充处理逻辑 */@Aspect@Component@Slf4jpublic class AutoFillAspect &#123;    /**     * 切入点     */    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)    public void autoFillPointCut()&#123;&#125;    /**     * 前置通知，在通知中进行公共字段的赋值     */    @Before(&quot;autoFillPointCut()&quot;)    public void autoFill(JoinPoint joinPoint)&#123;        log.info(&quot;开始进行公共字段自动填充...&quot;);        //获取到当前被拦截的方法上的数据库操作类型        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象        OperationType operationType = autoFill.value();//获得数据库操作类型        //获取到当前被拦截的方法的参数--实体对象        Object[] args = joinPoint.getArgs();        if(args == null || args.length == 0)&#123;            return;        &#125;        Object entity = args[0];        //准备赋值的数据        LocalDateTime now = LocalDateTime.now();        Long currentId = BaseContext.getCurrentId();        //根据当前不同的操作类型，为对应的属性通过反射来赋值        if(operationType == OperationType.INSERT)&#123;            //为4个公共字段赋值            try &#123;                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setCreateTime.invoke(entity,now);                setCreateUser.invoke(entity,currentId);                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;else if(operationType == OperationType.UPDATE)&#123;            //为2个公共字段赋值            try &#123;                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>4）：对方法加上AutoFill注解</strong></p><p>Mapper接口的方法上添加，来代替公共字段</p><pre><code class="language-java"> /**     * 插入数据     * @param category     */    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +            &quot; VALUES&quot; +            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)    @AutoFill(value = OperationType.INSERT)    void insert(Category category);    /**     * 根据id修改分类     * @param category     */    @AutoFill(value = OperationType.UPDATE)    void update(Category category);</code></pre><p>这样在Service实现层上就可以省略公共字段的填充。</p><p>例如：</p><pre><code class="language-java">   /**     * 新增分类     * @param categoryDTO     */    public void save(CategoryDTO categoryDTO) &#123;        Category category = new Category();        //属性拷贝        BeanUtils.copyProperties(categoryDTO, category);        //分类状态默认为禁用状态0        category.setStatus(StatusConstant.DISABLE);        //在mapper层添加了注解   @AutoFill(value = OperationType.INSERT)，来自挂填充公共字段//        //设置创建时间、修改时间、创建人、修改人//        category.setCreateTime(LocalDateTime.now());//        category.setUpdateTime(LocalDateTime.now());//        category.setCreateUser(BaseContext.getCurrentId());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.insert(category);    &#125;/**     * 修改分类     * @param categoryDTO     */    public void update(CategoryDTO categoryDTO) &#123;        Category category = new Category();        BeanUtils.copyProperties(categoryDTO,category);        //在mapper层添加了注解   @AutoFill(value = OperationType.update)，来自挂填充公共字段//        //设置修改时间、修改人//        category.setUpdateTime(LocalDateTime.now());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.update(category);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2025/07/16/SpringSecurity/"/>
      <url>/2025/07/16/SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="引入SpringSecurity"><a href="#引入SpringSecurity" class="headerlink" title="引入SpringSecurity"></a>引入SpringSecurity</h1><p>Spring Security是一个Java框架，用于保护应用程序的安全性。它提供了一套全面的安全解决方案，包括身份验证、授权、防止攻击等功能。Spring Security基于过滤器链的概念，可以轻松地集成到任何基于Spring的应用程序中。它支持多种身份验证选项和授权策略，开发人员可以根据需要选择适合的方式。此外，Spring Security还提供了一些附加功能，如集成第三方身份验证提供商和单点登录，以及会话管理和密码编码等。总之，Spring Security是一个强大且易于使用的框架，可以帮助开发人员提高应用程序的安全性和可靠性。</p><p><strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p><p><strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p><blockquote><p>相关依赖：</p></blockquote><pre><code class="language-java">&lt;!--        SpringSecurity启动器--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>启动运行之后，发现SpringSecurity自带登录校验，需要登录成功后才能看到”hello word“的界面。</p><img src="/2025/07/16/SpringSecurity/image-20250717144929768.png" class="" alt="image-20250717144929768"><p><strong>默认账号为 user ,密码会初始化在控制台中</strong></p><img src="/2025/07/16/SpringSecurity/image-20250717145032873.png" class="" alt="image-20250717145032873"><h1 id="SpringSecurity完整流程"><a href="#SpringSecurity完整流程" class="headerlink" title="SpringSecurity完整流程"></a>SpringSecurity完整流程</h1><p>SpringSecurity的原理是<strong>过滤器链</strong>，内部包含了各种功能的过滤器。</p><p>核心过滤器：</p><img src="/2025/07/16/SpringSecurity/image-20250717145322230.png" class="" alt="image-20250717145322230"><p><code>UsernamePasswordAuthenticationFilter:</code>负责处理我们在登陆页面<strong>填写了用户名密码后的登陆请求</strong>。<br><code>ExceptionTranslationFilter</code>:处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException。<br><code>FilterSecurityInterceptor</code>:<strong>负责权限校验的过滤器。</strong></p><p>我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p><pre><code class="language-java">@SpringBootApplicationpublic class SanGengSecurityApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext run = SpringApplication.run(SanGengSecurityApplication.class, args);        System.out.println(&quot;args = &quot; + args);    &#125;&#125;</code></pre><img src="/2025/07/16/SpringSecurity/image-20250717154521396.png" class="" alt="image-20250717154521396"><p>输入 <code>run.getBean(DefaultSecurityFilterChain.class)</code> 求值</p><img src="/2025/07/16/SpringSecurity/image-20250717150858572.png" class="" alt="image-20250717150858572"><img src="/2025/07/16/SpringSecurity/image-20250717151723314.png" class="" alt="image-20250717151723314"><p>相关概念：<br>Authentication接口：它的实现类，表示当前访问系统的用户，封装了用户相关信息。<br>AuthenticationManager接口:定义了认证Authentication的方法<br>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。<br>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将<br>这些信息封装到Authentication对象中。</p><h1 id="登录和校验流程"><a href="#登录和校验流程" class="headerlink" title="登录和校验流程"></a>登录和校验流程</h1><p>登录：</p><ol><li>自定义登录接口 <ol><li>在ProciderMangerd1authenticate方法进行认证。 如果认证通过生成JWT令牌。</li><li>把用户信息存入到redis中</li></ol></li><li>自定义UserDetailsServoce 在这个实现列中去查询数据库</li></ol><img src="/2025/07/16/SpringSecurity/image-20250717152451849.png" class="" alt="image-20250717152451849"><img src="/2025/07/16/SpringSecurity/image-20250717153047665.png" class="" alt="image-20250717153047665"><p>校验：</p><ol><li>定义JWT认证过滤器<ol><li>获取tiken</li><li>解析token，获取其中的userid</li><li>从reids中获取用户信息</li><li>存入SecurityContextHolde中</li></ol></li></ol><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.<strong>添加依赖</strong>(pom.xml)</p><pre><code class="language-xml">        &lt;!-- Spring Boot 安全功能的starter包，用于web应用的安全控制 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- Spring Boot Web功能的starter包，提供web应用的基本功能 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- Lombok，提供简单的代码生成工具，减少样板代码，设置为可选依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;!-- Spring Boot的测试starter包，用于单元测试和集成测试 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- Spring Security的测试包，用于安全测试 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- Redis的starter包，用于集成Redis作为缓存或持久化方案 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- FastJSON，一个Java语言编写的高性能功能完备的JSON库 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.33&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- JWT（JSON Web Token）的库，用于生成和解析JWT --&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;            &lt;version&gt;0.9.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- JAXB API，用于XML和Java对象之间的绑定 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;            &lt;version&gt;2.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- MyBatis Plus的Spring Boot starter，用于简化MyBatis的使用 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;            &lt;version&gt;3.5.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- MySQL连接器，用于连接和操作MySQL数据库 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.29&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring Boot的测试starter包，重复项，可能用于不同目的 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>2.<strong>添加Redis相关配置</strong>(com.sangeng.utils | com.sangeng.config)</p><pre><code class="language-java">public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; &#123;    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);    private Class&lt;T&gt; clazz;    static &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);    &#125;    public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123;        super();        this.clazz = clazz;    &#125;    @Override    public byte[] serialize(T t) throws SerializationException &#123;        if (t == null) &#123;            return new byte[0];        &#125;        return JSON.toJSONString(t,                SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);    &#125;    @Override    public T deserialize(byte[] bytes) throws SerializationException &#123;        if (bytes == null || bytes.length &lt;= 0) &#123;            return null;        &#125;        String str = new String(bytes, DEFAULT_CHARSET);        return JSON.parseObject(str, clazz);    &#125;    protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123;        return TypeFactory.defaultInstance().constructType(clazz);    &#125;&#125;</code></pre><pre><code class="language-java">@Configurationpublic class RedisConfig &#123;    @Bean    @SuppressWarnings(value = &#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory                                                               connectionFactory) &#123;        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(connectionFactory);        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);        // 使用StringRedisSerializer来序列化和反序列化redis的key值        template.setKeySerializer(new StringRedisSerializer());        template.setValueSerializer(serializer);        // Hash的key也采用StringRedisSerializer的序列化方式        template.setHashKeySerializer(new StringRedisSerializer());        template.setHashValueSerializer(serializer);        template.afterPropertiesSet();        return template;    &#125;&#125;</code></pre><ol start="3"><li><strong>响应类</strong>(com.sangeng.domain)</li></ol><pre><code class="language-java">@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123;    /**     * 状态码     */    private Integer code;    /**     * 提示信息，如果有错误时，前端可以获取该字段进行提示     */    private String msg;    /**     * 查询到的结果数据，     */    private T data;    public ResponseResult(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;    public ResponseResult(Integer code, T data) &#123;        this.code = code;        this.data = data;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public void setCode(Integer code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public ResponseResult(Integer code, String msg, T data) &#123;        this.code = code;        this.msg = msg;        this.data = data;    &#125;&#125;</code></pre><ol start="4"><li><strong>工具类</strong>(com.sangeng.utils)</li></ol><pre><code class="language-java">/** * JWT工具类 */public class JwtUtil &#123;    //有效期为    public static final Long JWT_TTL = 60 * 60 * 1000L;// 60 * 60 *1000 一个小时    //设置秘钥明文    public static final String JWT_KEY = &quot;sangeng&quot;;    public static String getUUID() &#123;        String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);        return token;    &#125;    /**     * 生成jtw     *     * @param subject token中要存放的数据（json格式）     * @return     */    public static String createJWT(String subject) &#123;        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间        return builder.compact();    &#125;    /**     * 生成jtw     *     * @param subject   token中要存放的数据（json格式）     * @param ttlMillis token超时时间     * @return     */    public static String createJWT(String subject, Long ttlMillis) &#123;        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间        return builder.compact();    &#125;    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis,                                            String uuid) &#123;        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;        SecretKey secretKey = generalKey();        long nowMillis = System.currentTimeMillis();        Date now = new Date(nowMillis);        if (ttlMillis == null) &#123;            ttlMillis = JwtUtil.JWT_TTL;        &#125;        long expMillis = nowMillis + ttlMillis;        Date expDate = new Date(expMillis);        return Jwts.builder()                .setId(uuid) //唯一的ID                .setSubject(subject) // 主题 可以是JSON数据                .setIssuer(&quot;sg&quot;) // 签发者                .setIssuedAt(now) // 签发时间                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥                .setExpiration(expDate);    &#125;    /**     * 创建token     *     * @param id     * @param subject     * @param ttlMillis     * @return     */    public static String createJWT(String id, String subject, Long ttlMillis) &#123;        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间        return builder.compact();    &#125;    public static void main(String[] args) throws Exception &#123;        String token =&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg &quot;;        Claims claims = parseJWT(token);        System.out.println(claims);    &#125;    /**     * 生成加密后的秘钥 secretKey     *     * @return     */    public static SecretKey generalKey() &#123;        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length,                &quot;AES&quot;);        return key;    &#125;    /**     * 解析     *     * @param jwt     * @return     * @throws Exception     */    public static Claims parseJWT(String jwt) throws Exception &#123;        SecretKey secretKey = generalKey();        return Jwts.parser()                .setSigningKey(secretKey)                .parseClaimsJws(jwt)                .getBody();    &#125;&#125;</code></pre><pre><code class="language-java">@SuppressWarnings(value = &#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)@Componentpublic class RedisCache &#123;    @Autowired    public RedisTemplate redisTemplate;    /**     * 缓存基本的对象，Integer、String、实体类等     *     * @param key   缓存的键值     * @param value 缓存的值     */    public &lt;T&gt; void setCacheObject(final String key, final T value) &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    /**     * 缓存基本的对象，Integer、String、实体类等     *     * @param key      缓存的键值     * @param value    缓存的值     * @param timeout  时间     * @param timeUnit 时间颗粒度     */    public &lt;T&gt; void setCacheObject(final String key, final T value, final    Integer timeout, final TimeUnit timeUnit) &#123;        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);    &#125;    /**     * 设置有效时间     *     * @param key     Redis键     * @param timeout 超时时间     * @return true=设置成功；false=设置失败     */    public boolean expire(final String key, final long timeout) &#123;        return expire(key, timeout, TimeUnit.SECONDS);    &#125;    /**     * 设置有效时间     *     * @param key     Redis键     * @param timeout 超时时间     * @param unit    时间单位     * @return true=设置成功；false=设置失败     */    public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123;        return redisTemplate.expire(key, timeout, unit);    &#125;    /**     * 获得缓存的基本对象。     *     * @param key 缓存键值     * @return 缓存键值对应的数据     */    public &lt;T&gt; T getCacheObject(final String key) &#123;        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();        return operation.get(key);    &#125;    /**     * 删除单个对象     *     * @param key     */    public boolean deleteObject(final String key) &#123;        return redisTemplate.delete(key);    &#125;    /**     * 删除集合对象     *     * @param collection 多个对象     * @return     */    public long deleteObject(final Collection collection) &#123;        return redisTemplate.delete(collection);    &#125;    /**     * 缓存List数据     *     * @param key      缓存的键值     * @param dataList 待缓存的List数据     * @return 缓存的对象     */    public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123;        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);        return count == null ? 0 : count;    &#125;    /**     * 获得缓存的list对象     *     * @param key 缓存的键值     * @return 缓存键值对应的数据     */    public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123;        return redisTemplate.opsForList().range(key, 0, -1);    &#125;    /**     * 缓存Set     *     * @param key     缓存键值     * @param dataSet 缓存的数据     * @return 缓存数据的对象     */    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final    Set&lt;T&gt; dataSet) &#123;        BoundSetOperations&lt;String, T&gt; setOperation =                redisTemplate.boundSetOps(key);        Iterator&lt;T&gt; it = dataSet.iterator();        while (it.hasNext()) &#123;            setOperation.add(it.next());        &#125;        return setOperation;    &#125;    /**     * 获得缓存的set     *     * @param key     * @return     */    public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123;        return redisTemplate.opsForSet().members(key);    &#125;    /**     * 缓存Map     *     * @param key     * @param dataMap     */    public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123;        if (dataMap != null) &#123;            redisTemplate.opsForHash().putAll(key, dataMap);        &#125;    &#125;    /**     * 获得缓存的Map     *     * @param key     * @return     */    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    /**     * 往Hash中存入数据     *     * @param key   Redis键     * @param hKey  Hash键     * @param value 值     */    public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final    T value) &#123;        redisTemplate.opsForHash().put(key, hKey, value);    &#125;    /**     * 获取Hash中的数据     *     * @param key  Redis键     * @param hKey Hash键     * @return Hash中的对象     */    public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123;        HashOperations&lt;String, String, T&gt; opsForHash =                redisTemplate.opsForHash();        return opsForHash.get(key, hKey);    &#125;    /**     * 删除Hash中的数据     *     * @param key     * @param hkey     */    public void delCacheMapValue(final String key, final String hkey) &#123;        HashOperations hashOperations = redisTemplate.opsForHash();        hashOperations.delete(key, hkey);    &#125;    /**     * 获取多个Hash中的数据     *     * @param key   Redis键     * @param hKeys Hash键集合     * @return Hash对象集合     */    public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final    Collection&lt;Object&gt; hKeys) &#123;        return redisTemplate.opsForHash().multiGet(key, hKeys);    &#125;    /**     * 获得缓存的基本对象列表     *     * @param pattern 字符串前缀     * @return 对象列表     */    public Collection&lt;String&gt; keys(final String pattern) &#123;        return redisTemplate.keys(pattern);    &#125;&#125;</code></pre><pre><code class="language-java">public class WebUtils &#123;    /**     * 将字符串渲染到客户端     *     * @param response 渲染对象     * @param string   待渲染的字符串     * @return null     */    public static String renderString(HttpServletResponse response, String            string) &#123;        try &#123;            response.setStatus(200);            response.setContentType(&quot;application/json&quot;);            response.setCharacterEncoding(&quot;utf-8&quot;);            response.getWriter().print(string);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;</code></pre><pre><code class="language-java">public class RedisUtils &#123;    // 启动Redis服务器    public static void startRedisServer() &#123;        try &#123;            Process process = Runtime.getRuntime().exec(&quot;C:\\develop1\\Redis-x64-3.2.100\\redis-server.exe C:\\develop1\\Redis-x64-3.2.100\\redis.windows.conf&quot;);            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));            String line;            while ((line = reader.readLine()) != null) &#123;                System.out.println(line);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 登录到Redis服务器    public static void loginRedisCli(String host, int port, String password) &#123;        try &#123;            String command = &quot;redis-cli.exe -h &quot; + host + &quot; -p &quot; + port + &quot; -a &quot; + password;            Process process = Runtime.getRuntime().exec(command);            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));            String line;            while ((line = reader.readLine()) != null) &#123;                System.out.println(line);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        // 启动Redis服务器        startRedisServer();        // 登录到Redis服务器        loginRedisCli(&quot;localhost&quot;, 6379, &quot;123456&quot;);    &#125;&#125;</code></pre><p>5.<strong>实体类</strong></p><pre><code class="language-java">/** * &lt;p&gt; * 用户表 * &lt;/p&gt; * * @author 哈纳桑 * @since 2024-05-07 */@TableName(&quot;sys_user&quot;)@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123;    private static final long serialVersionUID = 1L;    /**     * 主键     */    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    /**     * 用户名     */    private String userName;    /**     * 昵称     */    private String nickName;    /**     * 密码     */    private String password;    /**     * 用户类型：0代表普通用户，1代表管理员     */    private String type;    /**     * 账号状态（0正常 1停用）     */    private String status;    /**     * 邮箱     */    private String email;    /**     * 手机号     */    private String phonenumber;    /**     * 用户性别（0男，1女，2未知）     */    private String sex;    /**     * 头像     */    private String avatar;    /**     * 创建人的用户id     */    private Long createBy;    /**     * 创建时间     */    private LocalDateTime createTime;    /**     * 更新人     */    private Long updateBy;    /**     * 更新时间     */    private LocalDateTime updateTime;    /**     * 删除标志（0代表未删除，1代表已删除）     */    private Integer delFlag;&#125;</code></pre><p><strong>项目结构</strong></p><img src="/2025/07/16/SpringSecurity/image-20250717154709572.png" class="" alt="image-20250717154709572"><h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3><h4 id="1-数据库校验用户"><a href="#1-数据库校验用户" class="headerlink" title="1.数据库校验用户"></a>1.数据库校验用户</h4><p>从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的</p><p>UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。</p><ol><li><strong>准备工作</strong></li></ol><p>数据库表, 建表语句如下</p><pre><code class="language-sql"> CREATE TABLE `sys_user` (   `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,   `user_name` varchar(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,   `nick_name` varchar(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,   `password` varchar(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,   `type` char(1) DEFAULT &#39;0&#39; COMMENT &#39;用户类型：0代表普通用户，1代表管理员&#39;,   `status` char(1) DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,   `email` varchar(64) DEFAULT NULL COMMENT &#39;邮箱&#39;,   `phonenumber` varchar(32) DEFAULT NULL COMMENT &#39;手机号&#39;,   `sex` char(1) DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,   `avatar` varchar(128) DEFAULT NULL COMMENT &#39;头像&#39;,   `create_by` bigint DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,   `create_time` datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,   `update_by` bigint DEFAULT NULL COMMENT &#39;更新人&#39;,   `update_time` datetime DEFAULT NULL COMMENT &#39;更新时间&#39;,   `del_flag` int DEFAULT &#39;0&#39; COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,   PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=14787164048663 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#39;用户表&#39;</code></pre><ol><li><strong>引入MybatisPuls和mysql驱动的依赖</strong>(前面已经引入过了)</li></ol><pre><code class="language-xml">         &lt;!-- MyBatis Plus的Spring Boot starter，用于简化MyBatis的使用 --&gt;         &lt;dependency&gt;             &lt;groupId&gt;com.baomidou&lt;/groupId&gt;             &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;             &lt;version&gt;3.5.5&lt;/version&gt;         &lt;/dependency&gt;         &lt;!-- MySQL连接器，用于连接和操作MySQL数据库 --&gt;         &lt;dependency&gt;             &lt;groupId&gt;mysql&lt;/groupId&gt;             &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;             &lt;version&gt;8.0.29&lt;/version&gt;         &lt;/dependency&gt;</code></pre><ol><li><strong>配置数据库信息</strong></li></ol><pre><code class="language-yml"> spring:   application:     name: SecurityTest   datasource:       driver-class-name: com.mysql.cj.jdbc.Driver       url: jdbc:mysql://localhost:3306/sg_blog?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai       username: root       password: qq1664546939   data:       redis:         host: localhost         port: 6379         password: 123456         database: 10</code></pre><ol><li><strong>定义Mapper接口</strong>(com.sangeng.mapper)</li></ol><pre><code class="language-java"> public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;</code></pre><ol><li><strong>配置Mapper扫描</strong>(com.sangeng)</li></ol><pre><code class="language-java"> @SpringBootApplication @MapperScan(&quot;com.example.securitytest.mapper&quot;)//扫描mapper public class SecurityTestApplication &#123;      public static void main(String[] args) &#123;         SpringApplication.run(SecurityTestApplication.class, args);     &#125;  &#125; </code></pre><ol><li><strong>测试MP是否能正常使用</strong></li></ol><pre><code class="language-java"> package com.example.securitytest;  import com.example.securitytest.domain.User; import com.example.securitytest.mapper.UserMapper; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest;  import java.util.List;  @SpringBootTest class SecurityTestApplicationTests &#123;      @Autowired     UserMapper userMapper;     @Test     void contextLoads() &#123;         List&lt;User&gt; users = userMapper.selectList(null);         System.out.println(users);     &#125;  &#125;</code></pre><h4 id="2-核心代码"><a href="#2-核心代码" class="headerlink" title="2.核心代码"></a>2.核心代码</h4><p><strong>分析:</strong></p><blockquote><p><code>SpringSecurity</code> 默认是在内存中查找对应的用户名密码然后<code>UserDetailsService</code>的默认实现类使用封装成<code>UserDetai</code>l对象交给<code>DaoAuthenticationProcider</code>校验</p><p>但是我们在实际运用场景中是从数据库中查找用户信息</p><p>所以此时我们需要写一个<code>UserDetailsService</code>的实现类用来在数据库中查询用户信息并且封装到<code>UserDetai</code>l对象中</p><p>并且需要写一个<code>UserDetai</code>的实现类因为用户信息不仅仅只有用户名和密码还有其他信息</p></blockquote><h5 id="1-创建UserDetailsService实现类"><a href="#1-创建UserDetailsService实现类" class="headerlink" title="1.创建UserDetailsService实现类"></a>1.创建UserDetailsService实现类</h5><p>(com.sangeng.service)</p><pre><code class="language-java">  @Service public class UserDetailsServiceImpl implements UserDetailsService &#123;     @Autowired     UserMapper userMapper;     @Override     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;          // 根据用户名查询用户信息         LambdaQueryWrapper wrapper = new LambdaQueryWrapper&lt;User&gt;().eq(User::getUserName, username);         User user = userMapper.selectOne(wrapper);          //如果没有该用户就抛出异常         if (Objects.isNull(user)) &#123;             throw new RuntimeException(&quot;用户名或密码错误&quot;);         &#125;          //TODO: 查询权限信息封装到LoginUser中           // 将用户信息封装到UserDetails实现类中         return new LoginUser(user);     &#125; &#125;</code></pre><h5 id="2-创建UserDetail实现类"><a href="#2-创建UserDetail实现类" class="headerlink" title="2.创建UserDetail实现类"></a>2.创建UserDetail实现类</h5><p>(com.sangeng.domain)</p><pre><code class="language-java">  @Data @AllArgsConstructor @NoArgsConstructor public class LoginUser implements UserDetails &#123;      private User user;//封装用户信息      //获取权限     @Override     public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;         return null;     &#125;      //获取密码     @Override     public String getPassword() &#123;         return user.getPassword();     &#125;      //获取用户名     @Override     public String getUsername() &#123;         return user.getUserName();     &#125;      //账户是否未过期     @Override     public boolean isAccountNonExpired() &#123;         return true;     &#125;      //账户是否未锁定     @Override     public boolean isAccountNonLocked() &#123;         return true;     &#125;      //密码是否未过期     @Override     public boolean isCredentialsNonExpired() &#123;         return true;     &#125;      //账户是否可用     @Override     public boolean isEnabled() &#123;         return true;     &#125;      &#125; </code></pre><p><strong>注意</strong>：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如:</p><img src="/2025/07/16/SpringSecurity/image-20240510150930053.png" class="" alt="image-20240510150930053"><p>这样登陆的时候就可以用libai作为用户名，123456作为密码来登陆了。</p><h5 id="3-密码加密存储模式更改"><a href="#3-密码加密存储模式更改" class="headerlink" title="3.密码加密存储模式更改"></a>3.密码加密存储模式更改</h5><blockquote><p>实际项目中我们不会把密码明文存储在数据库中。</p><p>默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。</p><p>但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</p><p>我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p><p>我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码验。</p><p>我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承</p><p>WebSecurityConfigurerAdapter。</p></blockquote><p><strong>创建SpringSecurity配置类</strong>(com.sangeng.config)</p><pre><code class="language-JAVA"> @Configuration //配置类 @EnableWebSecurity // 开启Spring Security的功能 代替了 implements WebSecurityConfigurerAdapter public class SecurityConfig &#123;      @Bean     public PasswordEncoder passwordEncoder() &#123;         return new BCryptPasswordEncoder();     &#125; &#125;</code></pre><h5 id="4-登陆接口"><a href="#4-登陆接口" class="headerlink" title="4.登陆接口"></a>4.登陆接口</h5><blockquote><p>接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。</p><p>在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。</p><p>认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是</p><p>哪个用户，我们需要把用户信息存入redis，可以把用户id作为key</p></blockquote><p>(com.sangeng.controller)</p><pre><code class="language-java"> @RestController public class LoginController &#123;     @Autowired     private LoginServcie loginServcie;     @PostMapping(&quot;/user/login&quot;)     public ResponseResult login(@RequestBody User user)&#123;         return loginServcie.login(user);     &#125; &#125;</code></pre><p>(com.sangeng.service)</p><pre><code class="language-java"> public interface LoginServcie &#123;     ResponseResult login(User user); &#125;</code></pre><p>(com.sangeng.service.impl)</p><pre><code class="language-java"> @Service public class LoginServiceImpl implements LoginServcie &#123;     @Autowired     AuthenticationManager authenticationManager;     @Autowired     RedisCache redisCache;      @Override     public ResponseResult login(User user) &#123;          //1.封装Authentication对象         UsernamePasswordAuthenticationToken authenticationToken =                 new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword());          //2.通过AuthenticationManager的authenticate方法来进行用户认证         Authentication authenticated = authenticationManager.authenticate(authenticationToken);          //3.在Authentication中获取用户信息         LoginUser loginUser = (LoginUser) authenticated.getPrincipal();         String userId = loginUser.getUser().getId().toString();         //4.认证通过生成token         String jwt = JwtUtil.createJWT(userId);         //5.用户信息存入redis         redisCache.setCacheObject(&quot;login:&quot; + userId, loginUser);         //6.把token返回给前端         HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();         hashMap.put(&quot;token&quot;, jwt);         return new ResponseResult(200, &quot;登录成功&quot;, hashMap);     &#125; &#125;</code></pre><p>(com.sangeng.config)</p><pre><code class="language-java"> @Configuration //配置类 @EnableWebSecurity // 开启Spring Security的功能 代替了 implements WebSecurityConfigurerAdapter public class SecurityConfig &#123;     @Autowired     AuthenticationConfiguration authenticationConfiguration;//获取AuthenticationManager      @Bean     public PasswordEncoder passwordEncoder() &#123;         return new BCryptPasswordEncoder();     &#125;     @Bean     public AuthenticationManager authenticationManagerBean() throws Exception &#123;         return authenticationConfiguration.getAuthenticationManager();     &#125;      /**      * 配置Spring Security的过滤链。      *      * @param http 用于构建安全配置的HttpSecurity对象。      * @return 返回配置好的SecurityFilterChain对象。      * @throws Exception 如果配置过程中发生错误，则抛出异常。      */     @Bean     SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;         http                 // 禁用CSRF保护                 .csrf(csrf -&gt; csrf.disable())                 // 设置会话创建策略为无状态                 .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))                 // 配置授权规则   指定user/login路径.允许匿名访问(未登录可访问已登陆不能访问). 其他路径需要身份认证                 .authorizeHttpRequests(auth -&gt; auth.requestMatchers(&quot;/user/login&quot;).anonymous().anyRequest().authenticated())                 //开启跨域访问                 .cors(AbstractHttpConfigurer::disable);          // 构建并返回安全过滤链         return http.build();     &#125; &#125;</code></pre><p><strong>测试</strong></p><img src="/2025/07/16/SpringSecurity/image-20240510160632441.png" class="" alt="image-20240510160632441"><h5 id="5-认证过滤器"><a href="#5-认证过滤器" class="headerlink" title="5.认证过滤器"></a>5.认证过滤器</h5><blockquote><p>我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。(主要作用于除登录外的请求)</p><p>使用userid去redis中获取对应的LoginUser对象。</p><p>然后封装Authentication对象存入SecurityContextHolder</p></blockquote><p>(com.sangeng.filter)</p><pre><code class="language-java"> @Component //OncePerRequestFilter特点是在处理单个HTTP请求时确保过滤器的 doFilterInternal 方法只被调用一次 public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;     @Autowired     RedisCache redisCache;     @Override     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;          //1.在请求头中获取token         String token = request.getHeader(&quot;token&quot;);          //此处需要判断token是否为空         if (!StringUtils.hasText(token))&#123;             //没有token放行 此时的SecurityContextHolder没有用户信息 会被后面的过滤器拦截             filterChain.doFilter(request,response);             return;         &#125;          //2.解析token获取用户id         String subject;         try &#123;             Claims claims = JwtUtil.parseJWT(token);             subject = claims.getSubject();         &#125; catch (Exception e) &#123;             //解析失败             throw new RuntimeException(&quot;token非法&quot;);         &#125;         //3.在redis中获取用户信息 注意：redis中的key是login：+userId         String redisKey = &quot;login:&quot; + subject;         LoginUser loginUser = redisCache.getCacheObject(redisKey);          //此处需要判断loginUser是否为空         if (Objects.isNull(loginUser))&#123;             throw new RuntimeException(&quot;用户未登录&quot;);         &#125;         //4.将获取到的用户信息存入SecurityContextHolder 参数（用户信息，，权限信息）         UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);         SecurityContextHolder.getContext().setAuthentication(authenticationToken);          //5.放行         filterChain.doFilter(request,response);     &#125; &#125;</code></pre><p><strong>把token校验过滤器添加到过滤器链中</strong></p><p>(com.sangeng.config)</p><pre><code class="language-java"> @Configuration //配置类 @EnableWebSecurity // 开启Spring Security的功能 代替了 implements WebSecurityConfigurerAdapter public class SecurityConfig &#123;     @Autowired     AuthenticationConfiguration authenticationConfiguration;//获取AuthenticationManager     @Autowired     JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;      @Bean     public PasswordEncoder passwordEncoder() &#123;         return new BCryptPasswordEncoder();     &#125;      @Bean     public AuthenticationManager authenticationManagerBean() throws Exception &#123;         return authenticationConfiguration.getAuthenticationManager();     &#125;      /**      * 配置Spring Security的过滤链。      *      * @param http 用于构建安全配置的HttpSecurity对象。      * @return 返回配置好的SecurityFilterChain对象。      * @throws Exception 如果配置过程中发生错误，则抛出异常。      */     @Bean     SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;         http                 // 禁用CSRF保护                 .csrf(csrf -&gt; csrf.disable())                 // 设置会话创建策略为无状态                 .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))                 // 配置授权规则                 指定user/login路径.允许匿名访问(未登录可访问已登陆不能访问). 其他路径需要身份认证                 .authorizeHttpRequests(auth -&gt; auth.requestMatchers(&quot;/user/login&quot;).anonymous().anyRequest().authenticated())                 //开启跨域访问                 .cors(AbstractHttpConfigurer::disable)                 // 添加JWT认证过滤器                 .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);          // 构建并返回安全过滤链         return http.build();     &#125;   &#125; </code></pre><h5 id="6-退出登录"><a href="#6-退出登录" class="headerlink" title="6.退出登录"></a>6.退出登录</h5><p>我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。</p><p>(com.sangeng.service.impl.LoginServiceImpl)</p><pre><code class="language-java">   @Override     public ResponseResult logout() &#123;         //获取SecurityContextHolder中的用户id         Authentication authentication = SecurityContextHolder.getContext().getAuthentication();         LoginUser loginUser = (LoginUser) authentication.getPrincipal();         Long userId = loginUser.getUser().getId();         //删除redis中的用户信息         redisCache.deleteObject(&quot;login:&quot; + userId);         return new ResponseResult(200, &quot;退出成功&quot;);     &#125;</code></pre><p>(com.sangeng.controller.LoginController)</p><pre><code class="language-java">     @PostMapping(&quot;/user/logout&quot;)     public ResponseResult logout()&#123;         System.out.println(&quot;开始登出&quot;);         return loginServcie.logout();     &#125;</code></pre><h5 id="7-自定义失败处理器"><a href="#7-自定义失败处理器" class="headerlink" title="7.自定义失败处理器"></a>7.自定义失败处理器</h5><blockquote><p>我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p><p>在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p><p>如果是认证过程中出现的异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p><p>如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p><p>所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置SpringSecurity即可。</p></blockquote><p>(com.sangeng.handler)</p><pre><code class="language-java"> @Component public class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;     @Override     public void handle(HttpServletRequest request, HttpServletResponse response,                        AccessDeniedException accessDeniedException) throws IOException,             ServletException &#123;         ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(),                 &quot;权限不足&quot;);         String json = JSON.toJSONString(result);         WebUtils.renderString(response, json);     &#125; &#125; @Component public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;     @Override     public void commence(HttpServletRequest request, HttpServletResponse             response, AuthenticationException authException) throws IOException,             ServletException &#123;         ResponseResult result = new                 ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;);         String json = JSON.toJSONString(result);         WebUtils.renderString(response, json);     &#125; &#125;</code></pre><p><strong>修改配置类</strong></p><pre><code class="language-java"> @Configuration //配置类 @EnableWebSecurity // 开启Spring Security的功能 代替了 implements WebSecurityConfigurerAdapter public class SecurityConfig &#123;     @Autowired     AuthenticationConfiguration authenticationConfiguration;//获取AuthenticationManager     @Autowired     JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;     @Autowired     AccessDeniedHandlerImpl accessDeniedHandler;     @Autowired     AuthenticationEntryPointImpl authenticationEntryPoint;       @Bean     public PasswordEncoder passwordEncoder() &#123;         return new BCryptPasswordEncoder();     &#125;      @Bean     public AuthenticationManager authenticationManagerBean() throws Exception &#123;         return authenticationConfiguration.getAuthenticationManager();     &#125;      /**      * 配置Spring Security的过滤链。      *      * @param http 用于构建安全配置的HttpSecurity对象。      * @return 返回配置好的SecurityFilterChain对象。      * @throws Exception 如果配置过程中发生错误，则抛出异常。      */     @Bean     SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;         http                 // 禁用CSRF保护                 .csrf(csrf -&gt; csrf.disable())                 // 设置会话创建策略为无状态                 .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))                 // 配置授权规则                 指定user/login路径.允许匿名访问(未登录可访问已登陆不能访问). 其他路径需要身份认证                 .authorizeHttpRequests(auth -&gt; auth.requestMatchers(&quot;/user/login&quot;).anonymous().anyRequest().authenticated())                 //开启跨域访问                 .cors(AbstractHttpConfigurer::disable)                 // 添加JWT认证过滤器                 .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)                 // 配置异常处理                 .exceptionHandling(exception -&gt; exception.accessDeniedHandler(accessDeniedHandler).authenticationEntryPoint(authenticationEntryPoint));           // 构建并返回安全过滤链         return http.build();     &#125;</code></pre><p><strong>测试</strong></p><p>正常登录</p><img src="/2025/07/16/SpringSecurity/image-20240510172654681.png" class="" alt="image-20240510172654681"><p><strong>访问接口</strong></p><img src="/2025/07/16/SpringSecurity/image-20240510172740820.png" class="" alt="image-20240510172740820"><p><strong>退出登录</strong></p><img src="/2025/07/16/SpringSecurity/image-20240510172818241.png" class="" alt="image-20240510172818241"><p><strong>再次访问接口</strong></p><img src="/2025/07/16/SpringSecurity/image-20240510172844046.png" class="" alt="image-20240510172844046"><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h4 id="权限系统的作用"><a href="#权限系统的作用" class="headerlink" title="权限系统的作用"></a>权限系统的作用</h4><blockquote><p>例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到</p><p>并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就</p><p>能看到并使用添加书籍信息，删除书籍信息等功能。</p><p>总结起来就是<strong>不同的用户可以使用不同的功能</strong>。这就是权限系统要去实现的效果。</p><p>我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知</p><p>道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。</p><p>所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能</p><p>进行相应的操作。</p></blockquote><h4 id="授权基本流程"><a href="#授权基本流程" class="headerlink" title="授权基本流程"></a>授权基本流程</h4><blockquote><p>在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在</p><p>FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的</p><p>权限信息。当前用户是否拥有访问当前资源所需的权限。</p><p>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p><p>然后设置我们的资源所需要的权限即可。</p></blockquote><h4 id="授权基本实现"><a href="#授权基本实现" class="headerlink" title="授权基本实现"></a>授权基本实现</h4><h5 id="1-限制访问资源所需权限"><a href="#1-限制访问资源所需权限" class="headerlink" title="1.限制访问资源所需权限"></a>1.限制访问资源所需权限</h5><blockquote><p>SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以</p><p>使用注解去指定访问对应的资源所需的权限。</p><p>但是要使用它我们需要先开启相关配置。</p></blockquote><p>(com.sangeng.config.SecurityConfig)</p><pre><code class="language-java"> @EnableGlobalMethodSecurity(prePostEnabled = true)</code></pre><blockquote><p>然后就可以使用对应的注解。@PreAuthorize</p></blockquote><p>(com.sangeng.controller.HelloController)</p><pre><code class="language-java">     @RequestMapping(&quot;hello&quot;)     @PreAuthorize(&quot;hasAuthority(&#39;user&#39;)&quot;)     public String hello()&#123;         return &quot;hello world&quot;;     &#125;</code></pre><h5 id="2-封装权限信息"><a href="#2-封装权限信息" class="headerlink" title="2.封装权限信息"></a>2.封装权限信息</h5><p>我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。</p><p>我们先直接把权限信息写死封装到UserDetails中进行测试。</p><p>我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改</p><p>(com.sangeng.domain.LoginUser)</p><pre><code class="language-java">  @Data @NoArgsConstructor public class LoginUser implements UserDetails &#123;      private User user;//封装用户信息      private List&lt;String&gt; permissions;//存储权限信息      public LoginUser(User user, List&lt;String&gt; list) &#123;         this.user = user;         this.permissions = list;     &#125;     //获取权限     @JSONField(serialize = false) //忽略     private List&lt;SimpleGrantedAuthority&gt; authorities;     @Override     public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;         if (authorities != null)&#123;             return authorities;         &#125;         ////把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities         authorities = permissions.stream()                 .map(SimpleGrantedAuthority::new)                 .collect(Collectors.toList());         return authorities;     &#125;      //获取密码     @Override     public String getPassword() &#123;         return user.getPassword();     &#125;      //获取用户名     @Override     public String getUsername() &#123;         return user.getUserName();     &#125;      //账户是否未过期     @Override     public boolean isAccountNonExpired() &#123;         return true;     &#125;      //账户是否未锁定     @Override     public boolean isAccountNonLocked() &#123;         return true;     &#125;      //密码是否未过期     @Override     public boolean isCredentialsNonExpired() &#123;         return true;     &#125;      //账户是否可用     @Override     public boolean isEnabled() &#123;         return true;     &#125;  &#125; </code></pre><p>LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。</p><pre><code class="language-java">  @Service public class UserDetailsServiceImpl implements UserDetailsService &#123;     @Autowired     UserMapper userMapper;     @Override     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;          // 根据用户名查询用户信息         LambdaQueryWrapper wrapper = new LambdaQueryWrapper&lt;User&gt;().eq(User::getUserName, username);         User user = userMapper.selectOne(wrapper);          //如果没有该用户就抛出异常         if (Objects.isNull(user)) &#123;             throw new RuntimeException(&quot;用户名或密码错误&quot;);         &#125;          //TODO: 查询权限信息封装到LoginUser中         ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();         list.add(&quot;user&quot;);           // 将用户信息封装到UserDetails实现类中         return new LoginUser(user,list);     &#125; &#125; </code></pre><p>在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在</p><p>FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的</p><p>权限信息。当前用户是否拥有访问当前资源所需的权限。</p><p>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p><pre><code class="language-java"> @Component //OncePerRequestFilter特点是在处理单个HTTP请求时确保过滤器的 doFilterInternal 方法只被调用一次 public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;     @Autowired     RedisCache redisCache;     @Override     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;          //1.在请求头中获取token         String token = request.getHeader(&quot;token&quot;);          //此处需要判断token是否为空         if (!StringUtils.hasText(token))&#123;             //没有token放行 此时的SecurityContextHolder没有用户信息 会被后面的过滤器拦截             filterChain.doFilter(request,response);             return;         &#125;          //2.解析token获取用户id         String subject;         try &#123;             Claims claims = JwtUtil.parseJWT(token);             subject = claims.getSubject();         &#125; catch (Exception e) &#123;             //解析失败             throw new RuntimeException(&quot;token非法&quot;);         &#125;         //3.在redis中获取用户信息 注意：redis中的key是login：+userId         String redisKey = &quot;login:&quot; + subject;         LoginUser loginUser = redisCache.getCacheObject(redisKey);          //此处需要判断loginUser是否为空         if (Objects.isNull(loginUser))&#123;             throw new RuntimeException(&quot;用户未登录&quot;);         &#125;         //4.将获取到的用户信息存入SecurityContextHolder 参数（用户信息，，权限信息）         UsernamePasswordAuthenticationToken authenticationToken =                 new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities());         SecurityContextHolder.getContext().setAuthentication(authenticationToken);          //5.放行         filterChain.doFilter(request,response);     &#125; &#125;</code></pre><p><strong>测试</strong></p><h4 id="从数据库查询权限信息"><a href="#从数据库查询权限信息" class="headerlink" title="从数据库查询权限信息"></a>从数据库查询权限信息</h4><h5 id="1-RBAC权限模型"><a href="#1-RBAC权限模型" class="headerlink" title="1.RBAC权限模型"></a>1.RBAC权限模型</h5><p>RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。</p><img src="/2025/07/16/SpringSecurity/image-20250717154958422.png" class="" alt="image-20250717154958422"><h5 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h5><pre><code class="language-sql"> CREATE TABLE `sys_menu` (   `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#39;菜单ID&#39;,   `menu_name` varchar(50) NOT NULL COMMENT &#39;菜单名称&#39;,   `parent_id` bigint DEFAULT &#39;0&#39; COMMENT &#39;父菜单ID&#39;,   `order_num` int DEFAULT &#39;0&#39; COMMENT &#39;显示顺序&#39;,   `path` varchar(200) DEFAULT &#39;&#39; COMMENT &#39;路由地址&#39;,   `component` varchar(255) DEFAULT NULL COMMENT &#39;组件路径&#39;,   `is_frame` int DEFAULT &#39;1&#39; COMMENT &#39;是否为外链（0是 1否）&#39;,   `menu_type` char(1) DEFAULT &#39;&#39; COMMENT &#39;菜单类型（M目录 C菜单 F按钮）&#39;,   `visible` char(1) DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0显示 1隐藏）&#39;,   `status` char(1) DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0正常 1停用）&#39;,   `perms` varchar(100) DEFAULT NULL COMMENT &#39;权限标识&#39;,   `icon` varchar(100) DEFAULT &#39;#&#39; COMMENT &#39;菜单图标&#39;,   `create_by` bigint DEFAULT NULL COMMENT &#39;创建者&#39;,   `create_time` datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,   `update_by` bigint DEFAULT NULL COMMENT &#39;更新者&#39;,   `update_time` datetime DEFAULT NULL COMMENT &#39;更新时间&#39;,   `remark` varchar(500) DEFAULT &#39;&#39; COMMENT &#39;备注&#39;,   `del_flag` char(1) DEFAULT &#39;0&#39;,   PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2034 DEFAULT CHARSET=utf8mb3 COMMENT=&#39;菜单权限表&#39;  CREATE TABLE `sys_role` (   `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#39;角色ID&#39;,   `role_name` varchar(30) NOT NULL COMMENT &#39;角色名称&#39;,   `role_key` varchar(100) NOT NULL COMMENT &#39;角色权限字符串&#39;,   `role_sort` int NOT NULL COMMENT &#39;显示顺序&#39;,   `status` char(1) NOT NULL COMMENT &#39;角色状态（0正常 1停用）&#39;,   `del_flag` char(1) DEFAULT &#39;0&#39; COMMENT &#39;删除标志（0代表存在 1代表删除）&#39;,   `create_by` bigint DEFAULT NULL COMMENT &#39;创建者&#39;,   `create_time` datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,   `update_by` bigint DEFAULT NULL COMMENT &#39;更新者&#39;,   `update_time` datetime DEFAULT NULL COMMENT &#39;更新时间&#39;,   `remark` varchar(500) DEFAULT NULL COMMENT &#39;备注&#39;,   PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb3 COMMENT=&#39;角色信息表&#39;  CREATE TABLE `sys_role_menu` (   `role_id` bigint NOT NULL COMMENT &#39;角色ID&#39;,   `menu_id` bigint NOT NULL COMMENT &#39;菜单ID&#39;,   PRIMARY KEY (`role_id`,`menu_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT=&#39;角色和菜单关联表&#39;  CREATE TABLE `sys_user_role` (   `user_id` bigint NOT NULL COMMENT &#39;用户ID&#39;,   `role_id` bigint NOT NULL COMMENT &#39;角色ID&#39;,   PRIMARY KEY (`user_id`,`role_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT=&#39;用户和角色关联表&#39;  </code></pre><p>(com.sangeng.domain)</p><pre><code class="language-java"> @Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @TableName(&quot;sys_menu&quot;) public class Menu implements Serializable &#123;      private static final long serialVersionUID = 1L;      /**      * 菜单ID      */     @TableId(value = &quot;id&quot;, type = IdType.AUTO)     private Long id;      /**      * 菜单名称      */     private String menuName;      /**      * 父菜单ID      */     private Long parentId;      /**      * 显示顺序      */     private Integer orderNum;      /**      * 路由地址      */     private String path;      /**      * 组件路径      */     private String component;      /**      * 是否为外链（0是 1否）      */     private Integer isFrame;      /**      * 菜单类型（M目录 C菜单 F按钮）      */     private String menuType;      /**      * 菜单状态（0显示 1隐藏）      */     private String visible;      /**      * 菜单状态（0正常 1停用）      */     private String status;      /**      * 权限标识      */     private String perms;      /**      * 菜单图标      */     private String icon;      /**      * 创建者      */     private Long createBy;      /**      * 创建时间      */     private LocalDateTime createTime;      /**      * 更新者      */     private Long updateBy;      /**      * 更新时间      */     private LocalDateTime updateTime;      /**      * 备注      */     private String remark;      private String delFlag;   &#125;</code></pre><h5 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h5><p>(com.sangeng.mapper)</p><pre><code class="language-java"> public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123;     List&lt;String&gt; selectPermsByUserId (Long userId);  &#125;</code></pre><p>(classpath:mapper)</p><pre><code class="language-java"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.example.securitytest.mapper.MenuMapper&quot;&gt;      &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;         select             distinct perms         from sys_user_role sur                  left join sys_role sr on sur.role_id = sr.id                  left join sys_role_menu srm on sur.role_id = srm.role_id                  left join sys_menu sm on srm.menu_id = sm.id         where user_id = #&#123;userId&#125; and sr.status = 0 and sm.status = 0     &lt;/select&gt; &lt;/mapper&gt;</code></pre><p>然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可</p><img src="/2025/07/16/SpringSecurity/image-20250717154940592.png" class="" alt="image-20250717154940592"><pre><code class="language-java"> @Service public class UserDetailsServiceImpl implements UserDetailsService &#123;     @Autowired     UserMapper userMapper;     @Autowired     MenuMapper menuMapper;     @Override     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;          // 根据用户名查询用户信息         LambdaQueryWrapper wrapper = new LambdaQueryWrapper&lt;User&gt;().eq(User::getUserName, username);         User user = userMapper.selectOne(wrapper);          //如果没有该用户就抛出异常         if (Objects.isNull(user)) &#123;             throw new RuntimeException(&quot;用户名或密码错误&quot;);         &#125;          //TODO: 查询权限信息封装到LoginUser中 //        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //        list.add(&quot;user&quot;);         List&lt;String&gt; list = menuMapper.selectPermsByUserId(user.getId());           // 将用户信息封装到UserDetails实现类中         return new LoginUser(user,list);     &#125; &#125;</code></pre><p><strong>注意</strong>🍪此处需要注意修改HelloController中的权限 之前写的是@PreAuthorize(“hasAuthority(‘user’)”) 要改为数据库中对应有的权限</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，</p><p>默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p><p>前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p><p>所以我们就要处理一下，让前端能进行跨域请求。</p><ol><li>先对SpringBoot配置，运行跨域请求</li></ol><pre><code class="language-java"> @Configuration public class CorsConfig implements WebMvcConfigurer &#123;     @Override     public void addCorsMappings(CorsRegistry registry) &#123;          registry.addMapping(&quot;/**&quot;)                 // 设置允许跨域请求的域名                 .allowedOriginPatterns(&quot;*&quot;)                 // 是否允许cookie                 .allowCredentials(true)                 // 设置允许的请求方式                 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)                 // 设置允许的header属性                 .allowedHeaders(&quot;*&quot;)                 // 跨域允许时间                 .maxAge(3600);     &#125; &#125;</code></pre><ol><li><p>开启SpringSecurity的跨域访问</p><p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p></li></ol><pre><code class="language-java">  /**      * 配置Spring Security的过滤链。      *      * @param http 用于构建安全配置的HttpSecurity对象。      * @return 返回配置好的SecurityFilterChain对象。      * @throws Exception 如果配置过程中发生错误，则抛出异常。      */     @Bean     SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;         http                 // 添加JWT认证过滤器jwtAuthenticationTokenFilter在UsernamePasswordAuthenticationFilter之前                 .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)                 // 禁用CSRF保护                 .csrf(csrf -&gt; csrf.disable())                 // 设置会话创建策略为无状态                 .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))                 // 配置授权规则                 指定user/login路径.允许匿名访问(未登录可访问已登陆不能访问). 其他路径需要身份认证                 .authorizeHttpRequests(auth -&gt; auth.requestMatchers(&quot;/user/login&quot;).anonymous().anyRequest().authenticated())                 // 配置异常处理                 .exceptionHandling(exception -&gt; exception.accessDeniedHandler(accessDeniedHandler).authenticationEntryPoint(authenticationEntryPoint))                 //开启跨域访问                 .cors();          // 构建并返回安全过滤链         return http.build();     &#125;</code></pre><h2 id="遗留小问题"><a href="#遗留小问题" class="headerlink" title="遗留小问题"></a>遗留小问题</h2><h3 id="其它权限校验方法"><a href="#其它权限校验方法" class="headerlink" title="其它权限校验方法"></a>其它权限校验方法</h3><blockquote><p>我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。</p><p>SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p><p>这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更</p><p>容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p><p>hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知</p><p>道它内部的校验原理。</p><p>它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法</p><p>参数数据在权限列表中。</p></blockquote><p>hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p><pre><code class="language-java"> @PreAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;,&#39;test&#39;,&#39;system:dept:list&#39;)&quot;) public String hello()&#123;       return &quot;hello&quot;; &#125;</code></pre><p>hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所</p><p>以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><pre><code class="language-java"> @PreAuthorize(&quot;hasRole(&#39;system:dept:list&#39;)&quot;) public String hello()&#123;     return &quot;hello&quot;; &#125;</code></pre><p>hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以</p><p>这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><pre><code class="language-java"> @PreAuthorize(&quot;hasAnyRole(&#39;admin&#39;,&#39;system:dept:list&#39;)&quot;) public String hello()&#123;     return &quot;hello&quot;; &#125;</code></pre><h3 id="自定义权限校验方法"><a href="#自定义权限校验方法" class="headerlink" title="自定义权限校验方法"></a>自定义权限校验方法</h3><p>我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p><pre><code class="language-java"> @Component(&quot;ex&quot;) public class SGExpressionRoot &#123;     public boolean hasAuthority(String authority) &#123;         //获取当前用户的权限         Authentication authentication =                 SecurityContextHolder.getContext().getAuthentication();         LoginUser loginUser = (LoginUser) authentication.getPrincipal();         List&lt;String&gt; permissions = loginUser.getPermissions();         //判断用户权限集合中是否存在authority         return permissions.contains(authority);     &#125; &#125;</code></pre><p>在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的</p><p>hasAuthority方法</p><pre><code class="language-java"> @RequestMapping(&quot;/hello&quot;) @PreAuthorize(&quot;@ex.hasAuthority(&#39;system:dept:list&#39;)&quot;) public String hello()&#123;     return &quot;hello&quot;; &#125;</code></pre><h3 id="基于配置的权限控制"><a href="#基于配置的权限控制" class="headerlink" title="基于配置的权限控制"></a>基于配置的权限控制</h3><p>我们也可以在配置类中使用使用配置的方式对资源进行权限控制。</p><pre><code class="language-java">  @Override     protected void configure(HttpSecurity http) throws Exception &#123;         http //关闭csrf                 .csrf().disable() //不通过Session获取SecurityContext                 .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)                 .and()                 .authorizeRequests() // 对于登录接口 允许匿名访问                 .antMatchers(&quot;/user/login&quot;).anonymous()                 .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;) // 除上面外的所有请求全部需要鉴权认证                 .anyRequest().authenticated(); //添加过滤器         http.addFilterBefore(jwtAuthenticationTokenFilter,                 UsernamePasswordAuthenticationFilter.class); //配置异常处理器         http.exceptionHandling() //配置认证失败处理器                 .authenticationEntryPoint(authenticationEntryPoint)                 .accessDeniedHandler(accessDeniedHandler); //允许跨域         http.cors();     &#125;</code></pre><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p><p><a href="https://blog.csdn.net/freeking101/article/details/86537087">https://blog.csdn.net/freeking101/article/details/86537087</a></p><p>SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请</p><p>求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p><p>我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信</p><p>息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可</p><p>以，所以CSRF攻击也就不用担心了。</p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>在本文档的编写过程中，我们深受启发于三更老师在哔哩哔哩上发布的Spring Security框架教程。三更老师的视频教程《Spring Security+JWT实现项目级前端分离认证授权》为我们提供了宝贵的知识资源和实践指导。特别感谢三更老师的专业分享和无私奉献，这对我们的学习和理解Spring Security框架起到了极大的帮助。</p><p>感谢哔哩哔哩平台提供的分享环境，使得知识共享和传播变得更加便捷。</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1mm4y1X7Hc/?spm_id_from=333.337.search-card.all.click&vd_source=e9ac64741304a7d5005b7c0ec74c2d53">点击访问</a></p><p>我深知，没有大家的帮助，这份文档不可能如此顺利完成。希望本文档能够为使用Spring Security的开发者们提供有价值的参考和指导。</p><p>我们向三更老师和所有为开源社区和教育事业做出贡献的人士致以崇高的敬意。</p>]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（三）公共字段填充、菜品CRUD</title>
      <link href="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/"/>
      <url>/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/</url>
      
        <content type="html"><![CDATA[<h1 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在<strong>新增员工</strong>或者<strong>新增菜品分类</strong>时需要设置创建时间、创建人、修改时间、修改人等字段，在<strong>编辑员工</strong>或者<strong>编辑菜品分类</strong>时需要设置修改时间、修改人等字段。这些字段属于公共字段，也就是也就是在我们的系统中很多表中都会有这些字段，如下：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>字段名</strong></th><th><strong>含义</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>1</td><td>create_time</td><td>创建时间</td><td>datetime</td></tr><tr><td>2</td><td>create_user</td><td>创建人id</td><td>bigint</td></tr><tr><td>3</td><td>update_time</td><td>修改时间</td><td>datetime</td></tr><tr><td>4</td><td>update_user</td><td>修改人id</td><td>bigint</td></tr></tbody></table><p>而针对于这些字段，我们的赋值方式为： </p><p>1). 在新增数据时, 将createTime、updateTime 设置为当前时间, createUser、updateUser设置为当前登录用户ID。</p><p>2). 在更新数据时, 将updateTime 设置为当前时间, updateUser设置为当前登录用户ID。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>我们使用AOP切面编程，实现功能增强，来完成公共字段自动填充功能。</strong></p><p><strong>实现步骤：</strong></p><p>1). 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法</p><p>2). 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</p><p>3). 在 Mapper 的方法上加入 AutoFill 注解</p><h2 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h2><p><strong>1）：自定义注解</strong></p><p>进入到sky-server模块，创建com.sky.annotation包。</p><pre><code class="language-java">package com.sky.annotation;import com.sky.enumeration.OperationType;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AutoFill &#123;    //数据库操作类型：UPDATE INSERT    OperationType value();&#125;</code></pre><blockquote><p>解释如下：</p></blockquote><p><strong>1.<code>@Target(ElementType.METHOD)</code> —— 约束适用范围</strong></p><p><code>@Target</code> 是 <strong>元注解</strong>（用来修饰注解的注解），用来指定 <strong>AutoFill</strong> 只能放在什么元素上。</p><ul><li><code>ElementType.METHOD</code>：说明 <strong><em>只能</em> 用在方法</strong>声明上；不能放在类、字段、参数等位置。</li><li>常见的取值还包括 <code>TYPE</code>（类&#x2F;接口）、<code>FIELD</code>（字段）、<code>PARAMETER</code>（形参）……可以同时指定多个，例如 <code>&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;</code>。</li></ul><p><strong>2.<code>@Retention(RetentionPolicy.RUNTIME)</code> —— 生命周期</strong></p><p>另一枚元注解，决定编译后字节码里保留多久。</p><ul><li><code>SOURCE</code>：只存在于源码阶段，编译后即消失（如 Lombok 的大多数注解）。</li><li><code>CLASS</code>：编译后仍在 <code>.class</code> 文件中，但 <strong>运行时</strong> 通过反射拿不到（默认值）。</li><li><code>RUNTIME</code>：不仅编译期保留，而且 JVM 运行时依旧保留，可用反射读取——<strong>AOP、拦截器、框架自动装配</strong> 等场景全靠它。</li></ul><p>所以，这里选 <code>RUNTIME</code> 是为了在 <strong>拦截数据库操作的方法时</strong> 能获取注解信息，动态填充字段。</p><p><strong>3. <code>OperationType value();</code> —— 注解的属性</strong></p><ul><li>注解内部声明的方法就是<strong>属性</strong>（也叫“成员变量”）。</li><li>返回值可以是 <em>原始类型、String、Class、枚举、注解、以及它们的一维数组</em>。</li><li>如果属性名是 <code>value</code>，使用时可以省略 <code>value =</code>，见下方示例。</li></ul><p><strong>2）：OperationType</strong></p><p>在sky-common模块中定义</p><pre><code class="language-java">package com.sky.enumeration;/** * 数据库操作类型 */public enum OperationType &#123;    /**     * 更新操作     */    UPDATE,    /**     * 插入操作     */    INSERT&#125;</code></pre><p><strong>3）：自定义切面AutoFillAspect</strong></p><p>在sky-server模块，创建com.sky.aspect包。</p><pre><code class="language-java">package com.sky.aspect;import com.sky.annotation.AutoFill;import com.sky.constant.AutoFillConstant;import com.sky.context.BaseContext;import com.sky.enumeration.OperationType;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;import java.time.LocalDateTime;/** * 自定义切面，实现公共字段自动填充处理逻辑 */@Aspect@Component@Slf4jpublic class AutoFillAspect &#123;    /**     * 切入点     */    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)    public void autoFillPointCut()&#123;&#125;    /**     * 前置通知，在通知中进行公共字段的赋值     */    @Before(&quot;autoFillPointCut()&quot;)    public void autoFill(JoinPoint joinPoint)&#123;        log.info(&quot;开始进行公共字段自动填充...&quot;);        //获取到当前被拦截的方法上的数据库操作类型        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象        OperationType operationType = autoFill.value();//获得数据库操作类型        //获取到当前被拦截的方法的参数--实体对象        Object[] args = joinPoint.getArgs();        if(args == null || args.length == 0)&#123;            return;        &#125;        Object entity = args[0];        //准备赋值的数据        LocalDateTime now = LocalDateTime.now();        Long currentId = BaseContext.getCurrentId();        //根据当前不同的操作类型，为对应的属性通过反射来赋值        if(operationType == OperationType.INSERT)&#123;            //为4个公共字段赋值            try &#123;                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setCreateTime.invoke(entity,now);                setCreateUser.invoke(entity,currentId);                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;else if(operationType == OperationType.UPDATE)&#123;            //为2个公共字段赋值            try &#123;                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>4）：对方法加上AutoFill注解</strong></p><p>Mapper接口的方法上添加，来代替公共字段</p><pre><code class="language-java"> /**     * 插入数据     * @param category     */    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +            &quot; VALUES&quot; +            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)    @AutoFill(value = OperationType.INSERT)    void insert(Category category);    /**     * 根据id修改分类     * @param category     */    @AutoFill(value = OperationType.UPDATE)    void update(Category category);</code></pre><p>这样在Service实现层上就可以省略公共字段的填充。</p><p>例如：</p><pre><code class="language-java">   /**     * 新增分类     * @param categoryDTO     */    public void save(CategoryDTO categoryDTO) &#123;        Category category = new Category();        //属性拷贝        BeanUtils.copyProperties(categoryDTO, category);        //分类状态默认为禁用状态0        category.setStatus(StatusConstant.DISABLE);        //在mapper层添加了注解   @AutoFill(value = OperationType.INSERT)，来自挂填充公共字段//        //设置创建时间、修改时间、创建人、修改人//        category.setCreateTime(LocalDateTime.now());//        category.setUpdateTime(LocalDateTime.now());//        category.setCreateUser(BaseContext.getCurrentId());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.insert(category);    &#125;/**     * 修改分类     * @param categoryDTO     */    public void update(CategoryDTO categoryDTO) &#123;        Category category = new Category();        BeanUtils.copyProperties(categoryDTO,category);        //在mapper层添加了注解   @AutoFill(value = OperationType.update)，来自挂填充公共字段//        //设置修改时间、修改人//        category.setUpdateTime(LocalDateTime.now());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.update(category);    &#125;</code></pre><h2 id="前后端联调测试"><a href="#前后端联调测试" class="headerlink" title="前后端联调测试"></a>前后端联调测试</h2><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716152014926.png" class="" alt="image-20250716152014926"><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716152150264.png" class="" alt="image-20250716152150264"><h1 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h1><h2 id="需求分析与设计"><a href="#需求分析与设计" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型"></a>产品原型</h3><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716152348497.png" class="" alt="image-20250716152348497"><p><strong>业务规则：</strong></p><ul><li>菜品名称必须是唯一的</li><li>菜品必须属于某个分类下，不能单独存在</li><li>新增菜品时可以根据情况选择菜品的口味</li><li>每个菜品必须对应一张图片</li></ul><p>接口设计</p><p><strong>接口设计：</strong></p><ul><li>根据类型查询分类（已完成）</li><li>文件上传</li><li>新增菜品</li></ul><p><strong>1. 根据类型查询分类</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154458323.png" class="" alt="image-20250716154458323"><p><strong>2. 文件上传</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154511145.png" class="" alt="image-20250716154511145"><p><strong>3. 新增菜品</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154523491.png" class="" alt="image-20250716154523491"><p>表设计</p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154545162.png" class="" alt="image-20250716154545162"><p>通过原型图进行分析：</p><p>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据。所以在新增菜品时，涉及到两个表：</p><table><thead><tr><th>表名</th><th>说明</th></tr></thead><tbody><tr><td>dish</td><td>菜品表</td></tr><tr><td>dish_flavor</td><td>菜品口味表</td></tr></tbody></table><p><strong>1). 菜品表:dish</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>name</td><td>varchar(32)</td><td>菜品名称</td><td>唯一</td></tr><tr><td>category_id</td><td>bigint</td><td>分类id</td><td>逻辑外键</td></tr><tr><td>price</td><td>decimal(10,2)</td><td>菜品价格</td><td></td></tr><tr><td>image</td><td>varchar(255)</td><td>图片路径</td><td></td></tr><tr><td>description</td><td>varchar(255)</td><td>菜品描述</td><td></td></tr><tr><td>status</td><td>int</td><td>售卖状态</td><td>1起售 0停售</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>update_time</td><td>datetime</td><td>最后修改时间</td><td></td></tr><tr><td>create_user</td><td>bigint</td><td>创建人id</td><td></td></tr><tr><td>update_user</td><td>bigint</td><td>最后修改人id</td><td></td></tr></tbody></table><p><strong>2). 菜品口味表:dish_flavor</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>dish_id</td><td>bigint</td><td>菜品id</td><td>逻辑外键</td></tr><tr><td>name</td><td>varchar(32)</td><td>口味名称</td><td></td></tr><tr><td>value</td><td>varchar(255)</td><td>口味值</td><td></td></tr></tbody></table><h2 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>因为在新增菜品时，需要上传菜品对应的图片(文件)，包括后绪其它功能也会使用到文件上传，故要实现通用的文件上传接口。</p><p>文件上传，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发抖音、发朋友圈都用到了文件上传功能。</p><p>实现文件上传服务，需要有存储的支持，那么我们的解决方案将以下几种：</p><ol><li>直接将图片保存到服务的硬盘（springmvc中的文件上传）<ol><li>优点：开发便捷，成本低</li><li>缺点：扩容困难</li></ol></li><li>使用分布式文件系统进行存储<ol><li>优点：容易实现扩容</li><li>缺点：开发复杂度稍大（有成熟的产品可以使用，比如：FastDFS,MinIO）</li></ol></li><li>使用第三方的存储服务（例如OSS）<ol><li>优点：开发简单，拥有强大功能，免维护</li><li>缺点：付费</li></ol></li></ol><p>在本项目选用阿里云的OSS服务进行文件存储。</p><p><strong>实现步骤：</strong></p><p><strong>1). 定义OSS相关配置</strong></p><p>在sky-server模块</p><p>application-dev.yml</p><pre><code class="language-yaml">sky: #阿里云OSS配置  alioss:    endpoint: 填自己的，github保护    accessKeyId: 填自己的，github保护    accessKeySecret: 填自己的，github保护    bucketName: 填自己的，github保护</code></pre><p>application.yml</p><pre><code class="language-yaml">spring:  profiles:    active: dev    #设置环境sky:   alioss:    endpoint: $&#123;sky.alioss.endpoint&#125;    access-key-id: $&#123;sky.alioss.access-key-id&#125;    access-key-secret: $&#123;sky.alioss.access-key-secret&#125;    bucket-name: $&#123;sky.alioss.bucket-name&#125;</code></pre><p><strong>2). 读取OSS配置</strong></p><p>在sky-common模块中，已定义</p><pre><code class="language-java">package com.sky.properties;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;sky.alioss&quot;)@Datapublic class AliOssProperties &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;&#125;</code></pre><p><strong>3). 生成OSS工具类对象</strong></p><p>在sky-server模块</p><pre><code class="language-java">package com.sky.config;import com.sky.properties.AliOssProperties;import com.sky.utils.AliOssUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 配置类，用于创建AliOssUtil对象 */@Configuration@Slf4jpublic class OssConfiguration &#123;    @Bean    @ConditionalOnMissingBean    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties)&#123;        log.info(&quot;开始创建阿里云文件上传工具类对象：&#123;&#125;&quot;,aliOssProperties);        return new AliOssUtil(aliOssProperties.getEndpoint(),                aliOssProperties.getAccessKeyId(),                aliOssProperties.getAccessKeySecret(),                aliOssProperties.getBucketName());    &#125;&#125;</code></pre><p>其中，AliOssUtil.java已在sky-common模块中定义</p><pre><code class="language-java">package com.sky.utils;import com.aliyun.oss.ClientException;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.aliyun.oss.OSSException;import lombok.AllArgsConstructor;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.io.ByteArrayInputStream;@Data@AllArgsConstructor@Slf4jpublic class AliOssUtil &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;    /**     * 文件上传     *     * @param bytes     * @param objectName     * @return     */    public String upload(byte[] bytes, String objectName) &#123;        // 创建OSSClient实例。        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);        try &#123;            // 创建PutObject请求。            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));        &#125; catch (OSSException oe) &#123;            System.out.println(&quot;Caught an OSSException, which means your request made it to OSS, &quot;                    + &quot;but was rejected with an error response for some reason.&quot;);            System.out.println(&quot;Error Message:&quot; + oe.getErrorMessage());            System.out.println(&quot;Error Code:&quot; + oe.getErrorCode());            System.out.println(&quot;Request ID:&quot; + oe.getRequestId());            System.out.println(&quot;Host ID:&quot; + oe.getHostId());        &#125; catch (ClientException ce) &#123;            System.out.println(&quot;Caught an ClientException, which means the client encountered &quot;                    + &quot;a serious internal problem while trying to communicate with OSS, &quot;                    + &quot;such as not being able to access the network.&quot;);            System.out.println(&quot;Error Message:&quot; + ce.getMessage());        &#125; finally &#123;            if (ossClient != null) &#123;                ossClient.shutdown();            &#125;        &#125;        //文件访问路径规则 https://BucketName.Endpoint/ObjectName        StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;);        stringBuilder                .append(bucketName)                .append(&quot;.&quot;)                .append(endpoint)                .append(&quot;/&quot;)                .append(objectName);        log.info(&quot;文件上传到:&#123;&#125;&quot;, stringBuilder.toString());        return stringBuilder.toString();    &#125;&#125;</code></pre><p><strong>4). 定义文件上传接口</strong></p><p>在sky-server模块中定义接口</p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.constant.MessageConstant;import com.sky.result.Result;import com.sky.utils.AliOssUtil;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.util.UUID;/** * 通用接口 */@RestController@RequestMapping(&quot;/admin/common&quot;)@Api(tags = &quot;通用接口&quot;)@Slf4jpublic class CommonController &#123;    @Autowired    private AliOssUtil aliOssUtil;    /**     * 文件上传     * @param file     * @return     */    @PostMapping(&quot;/upload&quot;)    @ApiOperation(&quot;文件上传&quot;)    public Result&lt;String&gt; upload(MultipartFile file)&#123;        log.info(&quot;文件上传：&#123;&#125;&quot;,file);        try &#123;            //原始文件名            String originalFilename = file.getOriginalFilename();            //截取原始文件名的后缀   dfdfdf.png            String extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));            //构造新文件名称            String objectName = UUID.randomUUID().toString() + extension;            //文件的请求路径            String filePath = aliOssUtil.upload(file.getBytes(), objectName);            return Result.success(filePath);        &#125; catch (IOException e) &#123;            log.error(&quot;文件上传失败：&#123;&#125;&quot;, e);        &#125;        return Result.error(MessageConstant.UPLOAD_FAILED);    &#125;&#125;</code></pre><h3 id="新增菜品实现"><a href="#新增菜品实现" class="headerlink" title="新增菜品实现"></a>新增菜品实现</h3><p><strong>1). 设计DTO类</strong></p><p>在sky-pojo模块中</p><pre><code class="language-java">package com.sky.dto;import com.sky.entity.DishFlavor;import lombok.Data;import java.io.Serializable;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;@Datapublic class DishDTO implements Serializable &#123;    private Long id;    //菜品名称    private String name;    //菜品分类id    private Long categoryId;    //菜品价格    private BigDecimal price;    //图片    private String image;    //描述信息    private String description;    //0 停售 1 起售    private Integer status;    //口味    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();&#125;</code></pre><p><strong>2). Controller层</strong></p><p>进入到sky-server模块</p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.dto.DishDTO;import com.sky.dto.DishPageQueryDTO;import com.sky.entity.Dish;import com.sky.result.PageResult;import com.sky.result.Result;import com.sky.service.DishService;import com.sky.vo.DishVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;import java.util.Set;/** * 菜品管理 */@RestController@RequestMapping(&quot;/admin/dish&quot;)@Api(tags = &quot;菜品相关接口&quot;)@Slf4jpublic class DishController &#123;    @Autowired    private DishService dishService;    /**     * 新增菜品     *     * @param dishDTO     * @return     */    @PostMapping    @ApiOperation(&quot;新增菜品&quot;)    public Result save(@RequestBody DishDTO dishDTO) &#123;        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);        dishService.saveWithFlavor(dishDTO);//后绪步骤开发        return Result.success();    &#125;&#125;</code></pre><p><strong>3). Service层接口</strong></p><pre><code class="language-java">package com.sky.service;import com.sky.dto.DishDTO;import com.sky.entity.Dish;public interface DishService &#123;    /**     * 新增菜品和对应的口味     *     * @param dishDTO     */    public void saveWithFlavor(DishDTO dishDTO);&#125;</code></pre><p><strong>4). Service层实现类</strong></p><pre><code class="language-java">package com.sky.service.impl;@Service@Slf4jpublic class DishServiceImpl implements DishService &#123;    @Autowired    private DishMapper dishMapper;    @Autowired    private DishFlavorMapper dishFlavorMapper;    /**     * 新增菜品和对应的口味     *     * @param dishDTO     */    @Transactional    public void saveWithFlavor(DishDTO dishDTO) &#123;        Dish dish = new Dish();        BeanUtils.copyProperties(dishDTO, dish);        //向菜品表插入1条数据        dishMapper.insert(dish);//后绪步骤实现        //获取insert语句生成的主键值        Long dishId = dish.getId();        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;            flavors.forEach(dishFlavor -&gt; &#123;                dishFlavor.setDishId(dishId);            &#125;);            //向口味表插入n条数据            dishFlavorMapper.insertBatch(flavors);//后绪步骤实现        &#125;    &#125;&#125;</code></pre><p><strong>5). Mapper层</strong></p><p>DishMapper.java中添加</p><pre><code class="language-java">/**     * 插入菜品数据     *     * @param dish     */    @AutoFill(value = OperationType.INSERT)    void insert(Dish dish);</code></pre><p>在&#x2F;resources&#x2F;mapper中创建DishMapper.xml</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,update_user, status)        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;, #&#123;status&#125;)    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>DishFlavorMapper.java</p><pre><code class="language-java">package com.sky.mapper;import com.sky.entity.DishFlavor;import java.util.List;@Mapperpublic interface DishFlavorMapper &#123;    /**     * 批量插入口味数据     * @param flavors     */    void insertBatch(List&lt;DishFlavor&gt; flavors);&#125;</code></pre><p>在&#x2F;resources&#x2F;mapper中创建DishFlavorMapper.xml</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.DishFlavorMapper&quot;&gt;    &lt;insert id=&quot;insertBatch&quot;&gt;        insert into dish_flavor (dish_id, name, value) VALUES        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)        &lt;/foreach&gt;    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716164928367.png" class="" alt="image-20250716164928367"><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716170757070.png" class="" alt="image-20250716170757070"><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716170810326.png" class="" alt="image-20250716170810326"><h1 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h1><h2 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><h3 id="产品原型-1"><a href="#产品原型-1" class="headerlink" title="产品原型"></a>产品原型</h3><p><strong>菜品分页原型：</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716162007515.png" class="" alt="image-20250716162007515"> <p>在菜品列表展示时，除了菜品的基本信息(名称、售价、售卖状态、最后操作时间)外，还有两个字段略微特殊，第一个是图片字段 ，我们从数据库查询出来的仅仅是图片的名字，图片要想在表格中回显展示出来，就需要下载这个图片。第二个是菜品分类，这里展示的是分类名称，而不是分类ID，此时我们就需要根据菜品的分类ID，去分类表中查询分类信息，然后在页面展示。</p><p><strong>业务规则：</strong></p><ul><li>根据页码展示菜品信息</li><li>每页展示10条数据</li><li>分页查询时可以根据需要输入菜品名称、菜品分类、菜品状态进行查询</li></ul><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>根据上述原型图，设计出相应的接口。</p><p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221121202019258.png" alt="image-20221121202019258" style="zoom:50%;" /> <img src="D:/A_MyselfData/cqwm/讲义/讲义/day03/assets/image-20221121202033284.png" alt="image-20221121202033284" style="zoom:50%;" /></p><h2 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="设计DTO类"><a href="#设计DTO类" class="headerlink" title="设计DTO类"></a>设计DTO类</h3><p><strong>根据菜品分页查询接口定义设计对应的DTO：</strong></p><p>在sky-pojo模块中，已定义</p><pre><code class="language-java">package com.sky.dto;import lombok.Data;import java.io.Serializable;@Datapublic class DishPageQueryDTO implements Serializable &#123;    private int page;    private int pageSize;    private String name;    private Integer categoryId; //分类id    private Integer status; //状态 0表示禁用 1表示启用&#125;</code></pre><h3 id="设计VO类"><a href="#设计VO类" class="headerlink" title="设计VO类"></a>设计VO类</h3><p><strong>根据菜品分页查询接口定义设计对应的VO：</strong></p><p>在sky-pojo模块中，已定义</p><pre><code class="language-java">package com.sky.vo;import com.sky.entity.DishFlavor;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.math.BigDecimal;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class DishVO implements Serializable &#123;    private Long id;    //菜品名称    private String name;    //菜品分类id    private Long categoryId;    //菜品价格    private BigDecimal price;    //图片    private String image;    //描述信息    private String description;    //0 停售 1 起售    private Integer status;    //更新时间    private LocalDateTime updateTime;    //分类名称    private String categoryName;    //菜品关联的口味    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();&#125;</code></pre><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p><strong>根据接口定义创建DishController的page分页查询方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    @GetMapping(&quot;/page&quot;)    @ApiOperation(&quot;菜品分页查询&quot;)    public Result&lt;PageResult&gt; page(DishPageQueryDTO dishPageQueryDTO) &#123;        log.info(&quot;菜品分页查询:&#123;&#125;&quot;, dishPageQueryDTO);        PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);//后绪步骤定义        return Result.success(pageResult);    &#125;</code></pre><h3 id="Service层接口"><a href="#Service层接口" class="headerlink" title="Service层接口"></a>Service层接口</h3><p><strong>在 DishService 中扩展分页查询方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);</code></pre><h3 id="Service层实现类"><a href="#Service层实现类" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p><strong>在 DishServiceImpl 中实现分页查询方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);//后绪步骤实现        return new PageResult(page.getTotal(), page.getResult());    &#125;</code></pre><h3 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h3><p><strong>在 DishMapper 接口中声明 pageQuery 方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    Page&lt;DishVO&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO);</code></pre><p><strong>在 DishMapper.xml 中编写SQL：</strong></p><pre><code class="language-xml">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;        select d.* , c.name as categoryName from dish d left outer join category c on d.category_id = c.id        &lt;where&gt;            &lt;if test=&quot;name != null&quot;&gt;                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)            &lt;/if&gt;            &lt;if test=&quot;categoryId != null&quot;&gt;                and d.category_id = #&#123;categoryId&#125;            &lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;                and d.status = #&#123;status&#125;            &lt;/if&gt;        &lt;/where&gt;        order by d.create_time desc&lt;/select&gt;</code></pre><h2 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h2><h1 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h1><h2 id="需求分析和设计-1"><a href="#需求分析和设计-1" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><h3 id="产品原型-2"><a href="#产品原型-2" class="headerlink" title="产品原型"></a>产品原型</h3><p><strong>删除菜品原型：</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250721093334801.png" class="" alt="image-20250721093334801"> <p><strong>业务规则：</strong></p><ul><li>可以一次删除一个菜品，也可以批量删除菜品</li><li>起售中的菜品不能删除</li><li>被套餐关联的菜品不能删除</li><li>删除菜品后，关联的口味数据也需要删除掉</li></ul><h3 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h3><p>根据上述原型图，设计出相应的接口。</p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250721093327029.png" class="" alt="image-20250721093327029"> <img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三)公共字段填充、菜品CRUD\image-20221121211814429.png" alt="image-20221121211814429" style="zoom:50%;" /><p>**注意：**删除一个菜品和批量删除菜品共用一个接口，故ids可包含多个菜品id,之间用逗号分隔。</p><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><p>在进行删除菜品操作时，会涉及到以下三张表。</p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250721093320051.png" class="" alt="image-20250721093320051"> <p><strong>注意事项：</strong></p><ul><li>在dish表中删除菜品基本数据时，同时，也要把关联在dish_flavor表中的数据一块删除。</li><li>setmeal_dish表为菜品和套餐关联的中间表。</li><li>若删除的菜品数据关联着某个套餐，此时，删除失败。</li><li>若要删除套餐关联的菜品数据，先解除两者关联，再对菜品进行删除。</li></ul><h2 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><p><strong>根据删除菜品的接口定义在DishController中创建方法：</strong></p><pre><code class="language-java">/**     * 菜品批量删除     *     * @param ids     * @return     */    @DeleteMapping    @ApiOperation(&quot;菜品批量删除&quot;)    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;        log.info(&quot;菜品批量删除：&#123;&#125;&quot;, ids);        dishService.deleteBatch(ids);//后绪步骤实现        return Result.success();    &#125;</code></pre><h3 id="Service层接口-1"><a href="#Service层接口-1" class="headerlink" title="Service层接口"></a>Service层接口</h3><p><strong>在DishService接口中声明deleteBatch方法：</strong></p><pre><code class="language-java">/**     * 菜品批量删除     *     * @param ids     */    void deleteBatch(List&lt;Long&gt; ids);</code></pre><h3 id="Service层实现类-1"><a href="#Service层实现类-1" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p><strong>在DishServiceImpl中实现deleteBatch方法：</strong></p><pre><code class="language-java">    @Autowired    private SetmealDishMapper setmealDishMapper;/**     * 菜品批量删除     *     * @param ids     */    @Transactional//事务    public void deleteBatch(List&lt;Long&gt; ids) &#123;        //判断当前菜品是否能够删除---是否存在起售中的菜品？？        for (Long id : ids) &#123;            Dish dish = dishMapper.getById(id);//后绪步骤实现            if (dish.getStatus() == StatusConstant.ENABLE) &#123;                //当前菜品处于起售中，不能删除                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);            &#125;        &#125;        //判断当前菜品是否能够删除---是否被套餐关联了？？        List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);        if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;            //当前菜品被套餐关联了，不能删除            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);        &#125;        //删除菜品表中的菜品数据        for (Long id : ids) &#123;            dishMapper.deleteById(id);//后绪步骤实现            //删除菜品关联的口味数据            dishFlavorMapper.deleteByDishId(id);//后绪步骤实现        &#125;    &#125;</code></pre><h3 id="Mapper层-1"><a href="#Mapper层-1" class="headerlink" title="Mapper层"></a>Mapper层</h3><p><strong>在DishMapper中声明getById方法，并配置SQL：</strong></p><pre><code class="language-java">/**     * 根据主键查询菜品     *     * @param id     * @return     */    @Select(&quot;select * from dish where id = #&#123;id&#125;&quot;)    Dish getById(Long id);</code></pre><p><strong>创建SetmealDishMapper，声明getSetmealIdsByDishIds方法，并在xml文件中编写SQL：</strong></p><pre><code class="language-java">package com.sky.mapper;import com.sky.entity.SetmealDish;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface SetmealDishMapper &#123;    /**     * 根据菜品id查询对应的套餐id     *     * @param dishIds     * @return     */    //select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)    List&lt;Long&gt; getSetmealIdsByDishIds(List&lt;Long&gt; dishIds);&#125;</code></pre><p>SetmealDishMapper.xml</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.SetmealDishMapper&quot;&gt;    &lt;select id=&quot;getSetmealIdsByDishIds&quot; resultType=&quot;java.lang.Long&quot;&gt;        select setmeal_id from setmeal_dish where dish_id in        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;            #&#123;dishId&#125;        &lt;/foreach&gt;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong>在DishMapper.java中声明deleteById方法并配置SQL：</strong></p><pre><code class="language-java">/**     * 根据主键删除菜品数据     *     * @param id     */    @Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)    void deleteById(Long id);</code></pre><p><strong>在DishFlavorMapper中声明deleteByDishId方法并配置SQL：</strong></p><pre><code class="language-java">    /**     * 根据菜品id删除对应的口味数据     * @param dishId     */    @Delete(&quot;delete from dish_flavor where dish_id = #&#123;dishId&#125;&quot;)    void deleteByDishId(Long dishId);</code></pre><h2 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h2><h1 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h1><h2 id="需求分析和设计-2"><a href="#需求分析和设计-2" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><h3 id="产品原型-3"><a href="#产品原型-3" class="headerlink" title="产品原型"></a>产品原型</h3><p>在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击保存按钮完成修改操作。</p><p><strong>修改菜品原型：</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250721093230823.png" class="" alt="image-20250721093230823"> <h3 id="接口设计-2"><a href="#接口设计-2" class="headerlink" title="接口设计"></a>接口设计</h3><p>通过对上述原型图进行分析，该页面共涉及4个接口。</p><p><strong>接口：</strong></p><ul><li>根据id查询菜品</li><li>根据类型查询分类(已实现)</li><li>文件上传(已实现)</li><li>修改菜品</li></ul><p>我们只需要实现<strong>根据id查询菜品</strong>和<strong>修改菜品</strong>两个接口，接下来，我们来重点分析这两个接口。</p><p><strong>1). 根据id查询菜品</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250721093241717.png" class="" alt="image-20250721093241717"><p><strong>2). 修改菜品</strong> <img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250721093252102.png" class="" alt="image-20250721093252102"></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250721093303754.png" class="" alt="image-20250721093303754"> <p><strong>注:因为是修改功能，请求方式可设置为PUT。</strong></p><h2 id="代码开发-4"><a href="#代码开发-4" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="根据id查询菜品实现"><a href="#根据id查询菜品实现" class="headerlink" title="根据id查询菜品实现"></a>根据id查询菜品实现</h3><p><strong>1). Controller层</strong></p><p><strong>根据id查询菜品的接口定义在DishController中创建方法：</strong></p><pre><code class="language-java">    /**     * 根据id查询菜品     *     * @param id     * @return     */    @GetMapping(&quot;/&#123;id&#125;&quot;)    @ApiOperation(&quot;根据id查询菜品&quot;)    public Result&lt;DishVO&gt; getById(@PathVariable Long id) &#123;        log.info(&quot;根据id查询菜品：&#123;&#125;&quot;, id);        DishVO dishVO = dishService.getByIdWithFlavor(id);//后绪步骤实现        return Result.success(dishVO);    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p><strong>在DishService接口中声明getByIdWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id查询菜品和对应的口味数据     *     * @param id     * @return     */    DishVO getByIdWithFlavor(Long id);</code></pre><p><strong>3). Service层实现类</strong></p><p><strong>在DishServiceImpl中实现getByIdWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id查询菜品和对应的口味数据     *     * @param id     * @return     */    public DishVO getByIdWithFlavor(Long id) &#123;        //根据id查询菜品数据        Dish dish = dishMapper.getById(id);        //根据菜品id查询口味数据        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);//后绪步骤实现        //将查询到的数据封装到VO        DishVO dishVO = new DishVO();        BeanUtils.copyProperties(dish, dishVO);        dishVO.setFlavors(dishFlavors);        return dishVO;    &#125;</code></pre><p><strong>4). Mapper层</strong></p><p><strong>在DishFlavorMapper中声明getByDishId方法，并配置SQL：</strong></p><pre><code class="language-java">    /**     * 根据菜品id查询对应的口味数据     * @param dishId     * @return     */    @Select(&quot;select * from dish_flavor where dish_id = #&#123;dishId&#125;&quot;)    List&lt;DishFlavor&gt; getByDishId(Long dishId);</code></pre><h3 id="修改菜品实现"><a href="#修改菜品实现" class="headerlink" title="修改菜品实现"></a>修改菜品实现</h3><p><strong>1). Controller层</strong></p><p><strong>根据修改菜品的接口定义在DishController中创建方法：</strong></p><pre><code class="language-java">/**     * 修改菜品     *     * @param dishDTO     * @return     */    @PutMapping    @ApiOperation(&quot;修改菜品&quot;)    public Result update(@RequestBody DishDTO dishDTO) &#123;        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);        dishService.updateWithFlavor(dishDTO);        return Result.success();    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p><strong>在DishService接口中声明updateWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id修改菜品基本信息和对应的口味信息     *     * @param dishDTO     */    void updateWithFlavor(DishDTO dishDTO);</code></pre><p><strong>3). Service层实现类</strong></p><p><strong>在DishServiceImpl中实现updateWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id修改菜品基本信息和对应的口味信息     *     * @param dishDTO     */    public void updateWithFlavor(DishDTO dishDTO) &#123;        Dish dish = new Dish();        BeanUtils.copyProperties(dishDTO, dish);        //修改菜品表基本信息        dishMapper.update(dish);        //删除原有的口味数据        dishFlavorMapper.deleteByDishId(dishDTO.getId());        //重新插入口味数据        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;            flavors.forEach(dishFlavor -&gt; &#123;                dishFlavor.setDishId(dishDTO.getId());            &#125;);            //向口味表插入n条数据            dishFlavorMapper.insertBatch(flavors);        &#125;    &#125;</code></pre><p><strong>4). Mapper层</strong></p><p><strong>在DishMapper中，声明update方法：</strong></p><pre><code class="language-java">/**     * 根据id动态修改菜品数据     *     * @param dish     */    @AutoFill(value = OperationType.UPDATE)    void update(Dish dish);</code></pre><p><strong>并在DishMapper.xml文件中编写SQL:</strong></p><pre><code class="language-xml">&lt;update id=&quot;update&quot;&gt;        update dish        &lt;set&gt;            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;            &lt;if test=&quot;categoryId != null&quot;&gt;category_id = #&#123;categoryId&#125;,&lt;/if&gt;            &lt;if test=&quot;price != null&quot;&gt;price = #&#123;price&#125;,&lt;/if&gt;            &lt;if test=&quot;image != null&quot;&gt;image = #&#123;image&#125;,&lt;/if&gt;            &lt;if test=&quot;description != null&quot;&gt;description = #&#123;description&#125;,&lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;update_time = #&#123;updateTime&#125;,&lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;update_user = #&#123;updateUser&#125;,&lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;&lt;/update&gt;</code></pre><h2 id="接口测试-3"><a href="#接口测试-3" class="headerlink" title="接口测试"></a>接口测试</h2><h1 id="启售禁售菜品"><a href="#启售禁售菜品" class="headerlink" title="启售禁售菜品"></a>启售禁售菜品</h1><h2 id="根据产品原型进行需求分析，分析出业务规则"><a href="#根据产品原型进行需求分析，分析出业务规则" class="headerlink" title="根据产品原型进行需求分析，分析出业务规则"></a>根据产品原型进行需求分析，分析出业务规则</h2><p>菜品起售表示该菜品可以对外售卖，在用户端可以点餐，菜品停售表示此菜品下架，用户端无法点餐。</p><p>业务规则为：如果执行停售操作，则包含此菜品的套餐也需要停售。</p><h2 id="设计-菜品起售停售-功能的接口"><a href="#设计-菜品起售停售-功能的接口" class="headerlink" title="设计 菜品起售停售 功能的接口"></a>设计 菜品起售停售 功能的接口</h2><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716163254205.png" class="" alt="image-20250716163254205"><h2 id="根据接口设计进行代码实现"><a href="#根据接口设计进行代码实现" class="headerlink" title="根据接口设计进行代码实现"></a>根据接口设计进行代码实现</h2><h4 id="DishController"><a href="#DishController" class="headerlink" title="DishController"></a>DishController</h4><pre><code class="language-java">/**     * 菜品起售停售     * @param status     * @param id     * @return*/@PostMapping(&quot;/status/&#123;status&#125;&quot;)@ApiOperation(&quot;菜品起售停售&quot;)public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id)&#123;    dishService.startOrStop(status,id);    return Result.success();&#125;</code></pre><h4 id="DishService"><a href="#DishService" class="headerlink" title="DishService"></a>DishService</h4><pre><code class="language-java">/**     * 菜品起售停售     * @param status     * @param id*/void startOrStop(Integer status, Long id);</code></pre><h4 id="DishServiceImpl"><a href="#DishServiceImpl" class="headerlink" title="DishServiceImpl"></a>DishServiceImpl</h4><pre><code class="language-java">/**     * 菜品起售停售     *     * @param status     * @param id*/@Transactionalpublic void startOrStop(Integer status, Long id) &#123;    Dish dish = Dish.builder()        .id(id)        .status(status)        .build();    dishMapper.update(dish);    if (status == StatusConstant.DISABLE) &#123;        // 如果是停售操作，还需要将包含当前菜品的套餐也停售        List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();        dishIds.add(id);        // select setmeal_id from setmeal_dish where dish_id in (?,?,?)        List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);        if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;            for (Long setmealId : setmealIds) &#123;                Setmeal setmeal = Setmeal.builder()                    .id(setmealId)                    .status(StatusConstant.DISABLE)                    .build();                setmealMapper.update(setmeal);            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="SetmealMapper"><a href="#SetmealMapper" class="headerlink" title="SetmealMapper"></a>SetmealMapper</h4><pre><code class="language-java">/**     * 根据id修改套餐     *     * @param setmeal */@AutoFill(OperationType.UPDATE)void update(Setmeal setmeal);</code></pre><h4 id="SetmealMapper-xml"><a href="#SetmealMapper-xml" class="headerlink" title="SetmealMapper.xml"></a>SetmealMapper.xml</h4><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;        update setmeal        &lt;set&gt;            &lt;if test=&quot;name != null&quot;&gt;                name = #&#123;name&#125;,            &lt;/if&gt;            &lt;if test=&quot;categoryId != null&quot;&gt;                category_id = #&#123;categoryId&#125;,            &lt;/if&gt;            &lt;if test=&quot;price != null&quot;&gt;                price = #&#123;price&#125;,            &lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;                status = #&#123;status&#125;,            &lt;/if&gt;            &lt;if test=&quot;description != null&quot;&gt;                description = #&#123;description&#125;,            &lt;/if&gt;            &lt;if test=&quot;image != null&quot;&gt;                image = #&#123;image&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;                update_time = #&#123;updateTime&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;                update_user = #&#123;updateUser&#125;            &lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;</code></pre><h2 id="接口测试-4"><a href="#接口测试-4" class="headerlink" title="接口测试"></a>接口测试</h2>]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（0）过程解惑</title>
      <link href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/"/>
      <url>/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/</url>
      
        <content type="html"><![CDATA[<h1 id="DTO-VO-Entity-实体类-区别"><a href="#DTO-VO-Entity-实体类-区别" class="headerlink" title="DTO,VO,Entity(实体类)区别"></a>DTO,VO,Entity(实体类)区别</h1><table><thead><tr><th>类型</th><th>全称</th><th>作用</th><th>用途</th></tr></thead><tbody><tr><td>VO</td><td>Value Object</td><td>值对象，表示<strong>只读的展示数据</strong></td><td>通常用于前端展示层，封装用户需要展示的数据，<strong>包装返回的数据</strong></td></tr><tr><td>DTO</td><td>Data Transfer Object</td><td>数据传输对象，用于<strong>系统内部层与层之间的数据传输</strong></td><td>常用于 Controller ↔ Service 或远程接口间的<strong>数据传输</strong></td></tr><tr><td>实体类（Entity）</td><td>实体类&#x2F;模型类</td><td>表示数据库中的一张表</td><td>用于 ORM 映射（如 JPA、MyBatis），直接与数据库交互</td></tr></tbody></table><h1 id="数据库字段与变量名的对应"><a href="#数据库字段与变量名的对应" class="headerlink" title="数据库字段与变量名的对应"></a>数据库字段与变量名的对应</h1><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/image-20250715145106151.png" class="" alt="image-20250715145106151"><h1 id="统一登录验证—JWT令牌"><a href="#统一登录验证—JWT令牌" class="headerlink" title="统一登录验证—JWT令牌"></a>统一登录验证—JWT令牌</h1><h1 id="统一封装返回给前端的结果-Result封装返回结果"><a href="#统一封装返回给前端的结果-Result封装返回结果" class="headerlink" title="统一封装返回给前端的结果-Result封装返回结果"></a>统一封装返回给前端的结果-Result封装返回结果</h1><p>进入sky-common模块，在com.sky.result包下定义了Result.java</p><pre><code class="language-java">package com.sky.result;import lombok.Data;import java.io.Serializable;/** * 后端统一返回结果 * @param &lt;T&gt; */@Datapublic class Result&lt;T&gt; implements Serializable &#123;    private Integer code; //编码：1成功，0和其它数字为失败    private String msg; //错误信息    private T data; //数据    public static &lt;T&gt; Result&lt;T&gt; success() &#123;        Result&lt;T&gt; result = new Result&lt;T&gt;();        result.code = 1;        return result;    &#125;    public static &lt;T&gt; Result&lt;T&gt; success(T object) &#123;        Result&lt;T&gt; result = new Result&lt;T&gt;();        result.data = object;        result.code = 1;        return result;    &#125;    public static &lt;T&gt; Result&lt;T&gt; error(String msg) &#123;        Result result = new Result();        result.msg = msg;        result.code = 0;        return result;    &#125;&#125;</code></pre><h1 id="DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils"><a href="#DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils" class="headerlink" title="DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils"></a>DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils</h1><blockquote><p>注意：</p><p>​前端传来的数据字段 和 插入数据库中的字段数量不一致，缺少的需要补充。</p></blockquote><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/image-20250715155059419.png" class="" alt="image-20250715155059419"><p>对应代码如下：</p><pre><code class="language-java"> //对象属性拷贝BeanUtils.copyProperties(employeeDTO, employee);//设置账号的状态，默认正常状态 1表示正常 0表示锁定-------为了代码的可读性，将其封装为了常量类StatusConstant.javaemployee.setStatus(StatusConstant.ENABLE);//设置密码，默认密码123456employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</code></pre><h1 id="如何从JWT令牌中动态获取当前登录人的id。"><a href="#如何从JWT令牌中动态获取当前登录人的id。" class="headerlink" title="如何从JWT令牌中动态获取当前登录人的id。"></a>如何从JWT令牌中动态获取当前登录人的id。</h1><p><strong>1. JWT令牌中携带的id信息</strong></p><p><strong>2. 将id放到线程中</strong></p><p>因为在员工登录成功后生成的JWT令牌，后端会返回一个JWT令牌给前端，在后续的请求中，前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id。</p><pre><code class="language-java">  try &#123;            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);            //解析出令牌中的id            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());            log.info(&quot;当前员工id：&quot;, empId);            //将解析出的id，放到线程中      //--------------------------------------            BaseContext.setCurrentId(empId);//-------------------------------------                        //3、通过，放行            return true;        &#125; catch (Exception ex) &#123;            //4、不通过，响应401状态码            response.setStatus(401);            return false;        &#125;</code></pre><p><strong>解析出登录员工id后，如何传递给Service的save方法？</strong></p><p>​通过ThreadLocal进行传递。</p><p>在sky-common模块，中的com.sky.context</p><pre><code class="language-java">package com.sky.context;public class BaseContext &#123;    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) &#123;        threadLocal.set(id);    &#125;    public static Long getCurrentId() &#123;        return threadLocal.get();    &#125;    public static void removeCurrentId() &#123;        threadLocal.remove();    &#125;&#125;</code></pre><p><strong>在Service中获取线程局部变量中的值：</strong></p><pre><code class="language-java">/**     * 新增员工     *     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        //.............................        //设置当前记录创建人id和修改人id        employee.setCreateUser(BaseContext.getCurrentId());//目前写个假数据，后期修改        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.insert(employee);    &#125;</code></pre><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><strong>介绍：</strong></p><p>ThreadLocal 并不是一个Thread，而是Thread的局部变量。<br>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p><p><strong>常用方法：</strong></p><ul><li>public void set(T value) 设置当前线程的线程局部变量的值</li><li>public T get() 返回当前线程所对应的线程局部变量的值</li><li>public void remove()        移除当前线程的线程局部变量</li></ul><p>对ThreadLocal有了一定认识后，接下来继续解决<strong>问题二</strong></p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（0）过程解惑\image-20221111212349365.png" alt="image-20221111212349365" style="zoom:67%;" /> <p>ThreadLocal 操作的工具类：</p><pre><code class="language-java">package com.sky.context;public class BaseContext &#123;    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) &#123;        threadLocal.set(id);    &#125;    public static Long getCurrentId() &#123;        return threadLocal.get();    &#125;    public static void removeCurrentId() &#123;        threadLocal.remove();    &#125;&#125;</code></pre><h1 id="统一分页查询"><a href="#统一分页查询" class="headerlink" title="统一分页查询"></a>统一分页查询</h1><p>统一都封装为PageResult对象。</p><p>在sky-common模块</p><pre><code class="language-java">package com.sky.result;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.List;/** * 封装分页查询结果 */@Data@AllArgsConstructor@NoArgsConstructorpublic class PageResult implements Serializable &#123;    private long total; //总记录数    private List records; //当前页数据集合&#125;</code></pre><p>在EmployeeServiceImpl中实现pageQuery方法：</p><pre><code class="language-java">/**     * 分页查询     *     * @param employeePageQueryDTO     * @return     */    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;        // select * from employee limit 0,10        //开始分页查询        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());        Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);//后续定义        long total = page.getTotal();        List&lt;Employee&gt; records = page.getResult();        return new PageResult(total, records);    &#125;</code></pre><p>**注意：**此处使用 mybatis 的分页插件 PageHelper 来简化分页代码的开发。底层基于 mybatis 的拦截器实现。</p><p>故在pom.xml文中添加依赖(初始工程已添加)</p><pre><code class="language-xml">&lt;dependency&gt;   &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;   &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;$&#123;pagehelper&#125;&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="统一日期格式-全局处理"><a href="#统一日期格式-全局处理" class="headerlink" title="统一日期格式-全局处理"></a>统一日期格式-全局处理</h1><p>在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理</p><p> Spring MVC 框架的 <strong>消息转换器扩展（MessageConverter）</strong>，核心目的是用自定义的 <code>JacksonObjectMapper</code> 来替代 Spring 默认的 Jackson 配置，从而定制 JSON 的序列化和反序列化行为。</p><pre><code class="language-java">/**     * 扩展Spring MVC框架的消息转化器     * @param converters     */    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        log.info(&quot;扩展消息转换器...&quot;);        //创建一个消息转换器对象        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据        converter.setObjectMapper(new JacksonObjectMapper());        //将自己的消息转化器加入容器中        converters.add(0,converter);    &#125;</code></pre><p>时间格式定义，sky-common模块中</p><pre><code class="language-java">/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123;    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;    public JacksonObjectMapper() &#123;        super();        //收到未知属性时不报异常        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);        //反序列化时，属性不存在的兼容处理        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        SimpleModule simpleModule = new SimpleModule()                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));        //注册功能模块 例如，可以添加自定义序列化器和反序列化器        this.registerModule(simpleModule);    &#125;&#125;</code></pre><h2 id="针对处理："><a href="#针对处理：" class="headerlink" title="针对处理："></a>针对处理：</h2><p>在属性上加上注解，对日期进行格式化</p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（0）过程解惑\image-20221112103501581.png" alt="image-20221112103501581" style="zoom:67%;" /> <p>但这种方式，需要在每个时间属性上都要加上该注解，使用较麻烦，不能全局处理。</p><h1 id="自定义注解切面编程"><a href="#自定义注解切面编程" class="headerlink" title="自定义注解切面编程"></a>自定义注解切面编程</h1><p><strong>我们使用AOP切面编程，实现功能增强，来完成公共字段自动填充功能。</strong></p><p><strong>实现步骤：</strong></p><p>1). 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法</p><p>2). 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</p><p>3). 在 Mapper 的方法上加入 AutoFill 注解</p><p><strong>自定义注解：</strong></p><pre><code class="language-java">package com.sky.annotation;import com.sky.enumeration.OperationType;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AutoFill &#123;    //数据库操作类型：UPDATE INSERT    OperationType value();&#125;</code></pre><p><strong>OperationType</strong></p><p>在sky-common模块中定义</p><pre><code class="language-java">package com.sky.enumeration;/** * 数据库操作类型 */public enum OperationType &#123;    /**     * 更新操作     */    UPDATE,    /**     * 插入操作     */    INSERT&#125;</code></pre><p><strong>自定义切面类：</strong></p><pre><code class="language-java">package com.sky.aspect;import com.sky.annotation.AutoFill;import com.sky.constant.AutoFillConstant;import com.sky.context.BaseContext;import com.sky.enumeration.OperationType;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;import java.time.LocalDateTime;/** * 自定义切面，实现公共字段自动填充处理逻辑 */@Aspect@Component@Slf4jpublic class AutoFillAspect &#123;    /**     * 切入点     */    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)    public void autoFillPointCut()&#123;&#125;    /**     * 前置通知，在通知中进行公共字段的赋值     */    @Before(&quot;autoFillPointCut()&quot;)    public void autoFill(JoinPoint joinPoint)&#123;        log.info(&quot;开始进行公共字段自动填充...&quot;);        //获取到当前被拦截的方法上的数据库操作类型        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象        OperationType operationType = autoFill.value();//获得数据库操作类型        //获取到当前被拦截的方法的参数--实体对象        Object[] args = joinPoint.getArgs();        if(args == null || args.length == 0)&#123;            return;        &#125;        Object entity = args[0];        //准备赋值的数据        LocalDateTime now = LocalDateTime.now();        Long currentId = BaseContext.getCurrentId();        //根据当前不同的操作类型，为对应的属性通过反射来赋值        if(operationType == OperationType.INSERT)&#123;            //为4个公共字段赋值            try &#123;                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setCreateTime.invoke(entity,now);                setCreateUser.invoke(entity,currentId);                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;else if(operationType == OperationType.UPDATE)&#123;            //为2个公共字段赋值            try &#123;                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>4）：对方法加上AutoFill注解</strong></p><p>Mapper接口的方法上添加，来代替公共字段</p><pre><code class="language-java"> /**     * 插入数据     * @param category     */    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +            &quot; VALUES&quot; +            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)    @AutoFill(value = OperationType.INSERT)    void insert(Category category);    /**     * 根据id修改分类     * @param category     */    @AutoFill(value = OperationType.UPDATE)    void update(Category category);</code></pre><p>这样在Service实现层上就可以省略公共字段的填充。</p><p>例如：</p><pre><code class="language-java">   /**     * 新增分类     * @param categoryDTO     */    public void save(CategoryDTO categoryDTO) &#123;        Category category = new Category();        //属性拷贝        BeanUtils.copyProperties(categoryDTO, category);        //分类状态默认为禁用状态0        category.setStatus(StatusConstant.DISABLE);        //在mapper层添加了注解   @AutoFill(value = OperationType.INSERT)，来自挂填充公共字段//        //设置创建时间、修改时间、创建人、修改人//        category.setCreateTime(LocalDateTime.now());//        category.setUpdateTime(LocalDateTime.now());//        category.setCreateUser(BaseContext.getCurrentId());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.insert(category);    &#125;/**     * 修改分类     * @param categoryDTO     */    public void update(CategoryDTO categoryDTO) &#123;        Category category = new Category();        BeanUtils.copyProperties(categoryDTO,category);        //在mapper层添加了注解   @AutoFill(value = OperationType.update)，来自挂填充公共字段//        //设置修改时间、修改人//        category.setUpdateTime(LocalDateTime.now());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.update(category);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（二）员工管理、菜品分类管理</title>
      <link href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/"/>
      <url>/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h1><h2 id="需求分析与设计"><a href="#需求分析与设计" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型"></a>产品原型</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716102526489.png" class="" alt="image-20250716102526489"><p>当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据, 然后将数据保存至数据库中。</p><p><strong>注意事项：</strong></p><ol><li>账号必须是唯一的</li><li>手机号为合法的11位手机号码</li><li>身份证号为合法的18位身份证号码</li><li>密码默认为123456</li></ol><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715113036861.png" class="" alt="image-20250715113036861"><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><p>新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。</p><p><strong>employee表结构：</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>name</td><td>varchar(32)</td><td>姓名</td><td></td></tr><tr><td>username</td><td>varchar(32)</td><td>用户名</td><td>唯一</td></tr><tr><td>password</td><td>varchar(64)</td><td>密码</td><td></td></tr><tr><td>phone</td><td>varchar(11)</td><td>手机号</td><td></td></tr><tr><td>sex</td><td>varchar(2)</td><td>性别</td><td></td></tr><tr><td>id_number</td><td>varchar(18)</td><td>身份证号</td><td></td></tr><tr><td>status</td><td>Int</td><td>账号状态</td><td>1启用0禁用</td></tr><tr><td>create_time</td><td>Datetime</td><td>创建时间</td><td></td></tr><tr><td>update_time</td><td>datetime</td><td>最后修改时间</td><td></td></tr><tr><td>create_user</td><td>bigint</td><td>创建人id</td><td></td></tr><tr><td>update_user</td><td>bigint</td><td>最后修改人id</td><td></td></tr></tbody></table><h2 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="设计DTO"><a href="#设计DTO" class="headerlink" title="设计DTO"></a>设计DTO</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715144100437.png" class=""><p><strong>进入sky-pojo模块，在com.sky.dto包下，定义EmployeeDTO</strong></p><pre><code class="language-java">package com.sky.dto;import lombok.Data;import java.io.Serializable;@Datapublic class EmployeeDTO implements Serializable &#123;    private Long id;    private String username;    private String name;    private String phone;    private String sex;    private String idNumber;&#125;</code></pre><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>进入到sky-server模块中，在com.sky.controller.admin包下，在EmployeeController中创建新增员工方法，接收前端提交的参数。</p><pre><code class="language-java">/**     * 新增员工     * @param employeeDTO     * @return     */    @PostMapping    @ApiOperation(&quot;新增员工&quot;)    public Result save(@RequestBody EmployeeDTO employeeDTO)&#123;        log.info(&quot;新增员工：&#123;&#125;&quot;,employeeDTO);        employeeService.save(employeeDTO);//该方法后续步骤会定义        return Result.success();    &#125;</code></pre><h3 id="Service层接口"><a href="#Service层接口" class="headerlink" title="Service层接口"></a>Service层接口</h3><p>进入到sky-server模块中,com.sky.server.EmployeeService</p><pre><code class="language-java">/**     * 新增员工     * @param employeeDTO     */    void save(EmployeeDTO employeeDTO);</code></pre><h3 id="Service层实现类"><a href="#Service层实现类" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p>com.sky.server.impl.EmployeeServiceImpl中创建方法</p><pre><code class="language-java">/**     * 新增员工     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        //对象属性拷贝        BeanUtils.copyProperties(employeeDTO, employee);        //设置账号的状态，默认正常状态 1表示正常 0表示锁定-------为了代码的可读性，将其封装为了常量类StatusConstant.java        employee.setStatus(StatusConstant.ENABLE);        //设置密码，默认密码123456        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));        //设置当前记录的创建时间和修改时间        employee.setCreateTime(LocalDateTime.now());        employee.setUpdateTime(LocalDateTime.now());        //设置当前记录创建人id和修改人id        employee.setCreateUser(10L);//目前写个假数据，后期修改        employee.setUpdateUser(10L);        employeeMapper.insert(employee);//后续步骤定义    &#125;</code></pre><p>在sky-common模块com.sky.constants包下已定义StatusConstant.java</p><pre><code class="language-java">package com.sky.constant;/** * 状态常量，启用或者禁用 */public class StatusConstant &#123;    //启用    public static final Integer ENABLE = 1;    //禁用    public static final Integer DISABLE = 0;&#125;</code></pre><blockquote><p>注意：</p><p>​前端传来的数据字段 和 插入数据库中的字段数量不一致，缺少的需要补充。</p></blockquote><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715155059419.png" class="" alt="image-20250715155059419"><p>对应代码如下：</p><pre><code class="language-java"> //对象属性拷贝BeanUtils.copyProperties(employeeDTO, employee);//设置账号的状态，默认正常状态 1表示正常 0表示锁定-------为了代码的可读性，将其封装为了常量类StatusConstant.javaemployee.setStatus(StatusConstant.ENABLE);//设置密码，默认密码123456employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</code></pre><h3 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h3><p>com.sky.EmployeeMapper中添加方法</p><pre><code class="language-java">/**     * 插入员工数据     * @param employee     */    @Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +            &quot;values &quot; +            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)    void insert(Employee employee);</code></pre><p>在application.yml中已开启驼峰命名，故id_number和idNumber可对应。</p><pre><code class="language-yaml">mybatis:  configuration:    #开启驼峰命名    map-underscore-to-camel-case: true</code></pre><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><p>因为在登录过程，我们使用了<strong>JWT令牌验证</strong>的方式，所以在访问其他网站时都要在请求头上携带token令牌。</p><p><strong>获取token令牌</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715151131283.png" class="" alt="image-20250715151131283"><p><strong>将token令牌放到请求头中</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715151218200-1752563539574-1.png" class="" alt="image-20250715151218200"><p><strong>传入新增员工的信息</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715151254711.png" class="" alt="image-20250715151254711"><h2 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h2><h3 id="当员工姓名重复时，系统直接报错，停止"><a href="#当员工姓名重复时，系统直接报错，停止" class="headerlink" title="当员工姓名重复时，系统直接报错，停止"></a><strong>当员工姓名重复时，系统直接报错，停止</strong></h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715152230360.png" class="" alt="image-20250715152230360"><p>事实上：</p><p><strong>为了系统的正常运行，应该是出现提示错误  “该员工已存在”  而不是系统报错。</strong></p><p>针对手段：</p><p><strong>添加全局异常处理器来统一处理用户名已存在的错误。</strong></p><ol><li><p>截取错误信息ex</p></li><li><p>对ex进行字符串匹配</p></li><li><p>返回错误信息提示</p><br><p>具体整改如下：</p></li></ol><p>进入到sky-server模块，com.sky.hander包下，GlobalExceptionHandler.java添加方法</p><pre><code class="language-java">   /**     *重复出现相同的用户名     */    @ExceptionHandler    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123;        //异常信息        //Duplicate entry &#39;小智&#39; for key &#39;employee.idx_username&#39;        //下标：0     1       2    3   4     5        /**         * 1.获取异常信息         * 2.如果异常信息中存在Duplicate entry 则为该异常         *      如果不包含Duplicate entry 则为未知错误         * 3.如果是该异常，则返回异常信息：“用户名已存在”         *         1.对提取出来的异常信息使用 空格 划分数组元素         *         2.取出用户名所在下标的元素         *         3.打印提示信息         */        String message = ex.getMessage();        /*        message.contains(&quot;Duplicate entry&quot;) 的作用是 检查字符串 message 中是否包含子串 &quot;Duplicate entry&quot;        */        if (message.contains(&quot;Duplicate entry&quot;))&#123;            String[] split = message.split(&quot; &quot;);            String username = split[2];            String msy = username + &quot;已存在&quot;;            return Result.error(msy);        &#125;else &#123;            return  Result.error(&quot;未知错误&quot;);        &#125;    &#125;</code></pre><p>进入到sky-common模块，在MessageConstant.java添加</p><pre><code class="language-java">public static final String ALREADY_EXISTS = &quot;已存在&quot;;</code></pre><p><strong>再次，接口测试</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715153930092.png" class="" alt="image-20250715153930092"><h3 id="无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的"><a href="#无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的" class="headerlink" title="无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的"></a>无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的</h3><p><strong>1. JWT令牌中携带的id信息</strong></p><p><strong>2. 将id放到线程中</strong></p><p>因为在员工登录成功后生成的JWT令牌，后端会返回一个JWT令牌给前端，在后续的请求中，前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id。</p><pre><code class="language-java">  try &#123;            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);            //解析出令牌中的id            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());            log.info(&quot;当前员工id：&quot;, empId);            //将解析出的id，放到线程中      //--------------------------------------            BaseContext.setCurrentId(empId);//-------------------------------------                        //3、通过，放行            return true;        &#125; catch (Exception ex) &#123;            //4、不通过，响应401状态码            response.setStatus(401);            return false;        &#125;</code></pre><p><strong>解析出登录员工id后，如何传递给Service的save方法？</strong></p><p>​通过ThreadLocal进行传递。</p><p>在sky-common模块，中的com.sky.context</p><pre><code class="language-java">package com.sky.context;public class BaseContext &#123;    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) &#123;        threadLocal.set(id);    &#125;    public static Long getCurrentId() &#123;        return threadLocal.get();    &#125;    public static void removeCurrentId() &#123;        threadLocal.remove();    &#125;&#125;</code></pre><p><strong>在Service中获取线程局部变量中的值：</strong></p><pre><code class="language-java">/**     * 新增员工     *     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        //.............................        //设置当前记录创建人id和修改人id        employee.setCreateUser(BaseContext.getCurrentId());//目前写个假数据，后期修改        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.insert(employee);    &#125;</code></pre><p>再次，接口测试</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715162700866.png" class="" alt="image-20250715162700866"><h1 id="员工分页查询"><a href="#员工分页查询" class="headerlink" title="员工分页查询"></a>员工分页查询</h1><h2 id="产品原型-1"><a href="#产品原型-1" class="headerlink" title="产品原型"></a>产品原型</h2><p><strong>查询员工原型：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715162934812.png" class="" alt="image-20250715162934812"> <p><strong>业务规则</strong>：</p><ul><li>根据页码展示员工信息</li><li>每页展示10条数据</li><li>分页查询时可以根据需要，输入员工姓名进行查询</li></ul><h2 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h2><p><strong>1). 根据id查询员工信息</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715163120523.png" class=""><p><strong>注意事项：</strong></p><ul><li>请求参数类型为Query，不是json格式提交，在路径后直接拼接。&#x2F;admin&#x2F;employee&#x2F;page?name&#x3D;zhangsan</li><li>返回数据中records数组中使用Employee实体类对属性进行封装。</li></ul><h2 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="设计DTO类"><a href="#设计DTO类" class="headerlink" title="设计DTO类"></a>设计DTO类</h3><p>根据请求参数进行封装，在sky-pojo模块中</p><pre><code class="language-java">package com.sky.dto;import lombok.Data;import java.io.Serializable;@Datapublic class EmployeePageQueryDTO implements Serializable &#123;    //员工姓名    private String name;    //页码    private int page;    //每页显示记录数    private int pageSize;&#125;</code></pre><h3 id="封装分页查询结果—–PageResult"><a href="#封装分页查询结果—–PageResult" class="headerlink" title="封装分页查询结果—–PageResult"></a>封装分页查询结果—–PageResult</h3><p>统一都封装为PageResult对象。</p><p>在sky-common模块</p><pre><code class="language-java">package com.sky.result;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.List;/** * 封装分页查询结果 */@Data@AllArgsConstructor@NoArgsConstructorpublic class PageResult implements Serializable &#123;    private long total; //总记录数    private List records; //当前页数据集合&#125;</code></pre><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><p>在sky-server模块中，com.sky.controller.admin.EmployeeController中添加分页查询方法。</p><pre><code class="language-java">/**     * 员工分页查询     * @param employeePageQueryDTO     * @return     */    @GetMapping(&quot;/page&quot;)    @ApiOperation(&quot;员工分页查询&quot;)    public Result&lt;PageResult&gt; page(EmployeePageQueryDTO employeePageQueryDTO)&#123;        log.info(&quot;员工分页查询，参数为：&#123;&#125;&quot;, employeePageQueryDTO);        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);//后续定义        return Result.success(pageResult);    &#125;</code></pre><h3 id="Service层接口-1"><a href="#Service层接口-1" class="headerlink" title="Service层接口"></a>Service层接口</h3><p>在EmployeeService接口中声明pageQuery方法：</p><pre><code class="language-java">/**     * 分页查询     * @param employeePageQueryDTO     * @return     */    PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);</code></pre><h3 id="Service层实现类-1"><a href="#Service层实现类-1" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><blockquote><p>Page的依赖</p></blockquote><blockquote><pre><code class="language-java">import com.github.pagehelper.Page;</code></pre></blockquote><p>在EmployeeServiceImpl中实现pageQuery方法：</p><pre><code class="language-java">/**     * 分页查询     *     * @param employeePageQueryDTO     * @return     */    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;        // select * from employee limit 0,10        //开始分页查询                               页码                              每页记录数        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());        Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);//后续定义        long total = page.getTotal();        List&lt;Employee&gt; records = page.getResult();        return new PageResult(total, records);    &#125;</code></pre><p>**注意：**此处使用 mybatis 的分页插件 PageHelper 来简化分页代码的开发。底层基于 mybatis 的拦截器实现。</p><p>故在pom.xml文中添加依赖(初始工程已添加)</p><pre><code class="language-xml">&lt;dependency&gt;   &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;   &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;$&#123;pagehelper&#125;&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Mapper层-1"><a href="#Mapper层-1" class="headerlink" title="Mapper层"></a>Mapper层</h3><p>在 EmployeeMapper 中声明 pageQuery 方法：</p><pre><code class="language-java">/**     * 分页查询     * @param employeePageQueryDTO     * @return     */    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);</code></pre><p>在 src&#x2F;main&#x2F;resources&#x2F;mapper&#x2F;EmployeeMapper.xml 中编写SQL：</p><pre><code class="language-sql">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Employee&quot;&gt;        select * from employee        &lt;where&gt;            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)            &lt;/if&gt;        &lt;/where&gt;        order by create_time desc    &lt;/select&gt;</code></pre><h2 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715171559054.png" class="" alt="image-20250715171559054"><h2 id="代码完善-1"><a href="#代码完善-1" class="headerlink" title="代码完善"></a>代码完善</h2><h4 id="操作时间（系统时间）-表示错误"><a href="#操作时间（系统时间）-表示错误" class="headerlink" title="操作时间（系统时间）-表示错误"></a>操作时间（系统时间）-表示错误</h4><p>在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理</p><p> Spring MVC 框架的 <strong>消息转换器扩展（MessageConverter）</strong>，核心目的是用自定义的 <code>JacksonObjectMapper</code> 来替代 Spring 默认的 Jackson 配置，从而定制 JSON 的序列化和反序列化行为。</p><pre><code class="language-java">/**     * 扩展Spring MVC框架的消息转化器     * @param converters     */    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        log.info(&quot;扩展消息转换器...&quot;);        //创建一个消息转换器对象        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据        converter.setObjectMapper(new JacksonObjectMapper());        //将自己的消息转化器加入容器中        converters.add(0,converter);    &#125;</code></pre><p>时间格式定义，sky-common模块中</p><pre><code class="language-java">/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123;    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;    public JacksonObjectMapper() &#123;        super();        //收到未知属性时不报异常        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);        //反序列化时，属性不存在的兼容处理        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        SimpleModule simpleModule = new SimpleModule()                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));        //注册功能模块 例如，可以添加自定义序列化器和反序列化器        this.registerModule(simpleModule);    &#125;&#125;</code></pre><p><strong>再次，接口测试</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715173302970.png" class="" alt="image-20250715173302970"><h1 id="启用禁用员工账号"><a href="#启用禁用员工账号" class="headerlink" title="启用禁用员工账号"></a>启用禁用员工账号</h1><h2 id="产品原型-2"><a href="#产品原型-2" class="headerlink" title="产品原型"></a>产品原型</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715174422570.png" class="" alt="image-20250715174422570"><p><strong>业务规则：</strong></p><ul><li>可以对状态为“启用” 的员工账号进行“禁用”操作</li><li>可以对状态为“禁用”的员工账号进行“启用”操作</li><li>状态为“禁用”的员工账号不能登录系统</li></ul><h2 id="接口设计-2"><a href="#接口设计-2" class="headerlink" title="接口设计"></a>接口设计</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715174450579.png" class="" alt="image-20250715174450579"><p>1). 路径参数携带状态值。</p><p>2). 同时，把id传递过去，明确对哪个用户进行操作。</p><p>3). 返回数据code状态是必须，其它是非必须。</p><h2 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="Controller层-2"><a href="#Controller层-2" class="headerlink" title="Controller层"></a>Controller层</h3><p>在sky-server模块中，根据接口设计中的请求参数形式对应的在 EmployeeController 中创建启用禁用员工账号的方法：</p><pre><code class="language-java">/**     * 启用禁用员工账号     * @param status     * @param id     * @return     */    @PostMapping(&quot;/status/&#123;status&#125;&quot;)    @ApiOperation(&quot;启用禁用员工账号&quot;)    public Result startOrStop(@PathVariable Integer status,Long id)&#123;        log.info(&quot;启用禁用员工账号：&#123;&#125;,&#123;&#125;&quot;,status,id);        employeeService.startOrStop(status,id);//后绪步骤定义        return Result.success();    &#125;</code></pre><h3 id="Service层接口-2"><a href="#Service层接口-2" class="headerlink" title="Service层接口"></a>Service层接口</h3><p>在 EmployeeService 接口中声明启用禁用员工账号的业务方法：</p><pre><code class="language-java">/**     * 启用禁用员工账号     * @param status     * @param id     */    void startOrStop(Integer status, Long id);</code></pre><h3 id="Service层实现类-2"><a href="#Service层实现类-2" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p>在 EmployeeServiceImpl 中实现启用禁用员工账号的业务方法：</p><pre><code class="language-java">/**     * 启用禁用员工账号     *     * @param status     * @param id     */    public void startOrStop(Integer status, Long id) &#123;        Employee employee = Employee.builder()                .status(status)                .id(id)                .build();        employeeMapper.update(employee);    &#125;</code></pre><h3 id="Mapper层-2"><a href="#Mapper层-2" class="headerlink" title="Mapper层"></a>Mapper层</h3><p>在 EmployeeMapper 接口中声明 update 方法：</p><pre><code class="language-java">/**     * 根据主键动态修改属性     * @param employee     */    void update(Employee employee);</code></pre><p>在 EmployeeMapper.xml 中编写SQL：</p><pre><code class="language-sql">&lt;update id=&quot;update&quot; parameterType=&quot;Employee&quot;&gt;        update employee        &lt;set&gt;            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;            &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt;            &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt;            &lt;if test=&quot;phone != null&quot;&gt;phone = #&#123;phone&#125;,&lt;/if&gt;            &lt;if test=&quot;sex != null&quot;&gt;sex = #&#123;sex&#125;,&lt;/if&gt;            &lt;if test=&quot;idNumber != null&quot;&gt;id_Number = #&#123;idNumber&#125;,&lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;update_Time = #&#123;updateTime&#125;,&lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;update_User = #&#123;updateUser&#125;,&lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;    &lt;/update&gt;</code></pre><h2 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716084543164.png" class="" alt="image-20250716084543164"><h1 id="编辑员工"><a href="#编辑员工" class="headerlink" title="编辑员工"></a>编辑员工</h1><h2 id="需求分析与设计-1"><a href="#需求分析与设计-1" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型-3"><a href="#产品原型-3" class="headerlink" title="产品原型"></a>产品原型</h3><p><strong>修改页面原型</strong>：</p><blockquote><p>注：点击修改时，数据应该正常回显到修改页面。</p><p>因此必须先需要根据id查询员工信息，来回显数据</p></blockquote><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716090435476.png" class="" alt="image-20250716090435476"><h2 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="回显员工信息"><a href="#回显员工信息" class="headerlink" title="回显员工信息"></a>回显员工信息</h3><p><strong>1). Controller层</strong></p><p>在 EmployeeController 中创建 getById 方法：</p><pre><code class="language-java">/**     * 根据id查询员工信息     * @param id     * @return     */    @GetMapping(&quot;/&#123;id&#125;&quot;)    @ApiOperation(&quot;根据id查询员工信息&quot;)    public Result&lt;Employee&gt; getById(@PathVariable Long id)&#123;        Employee employee = employeeService.getById(id);        return Result.success(employee);    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p>在 EmployeeService 接口中声明 getById 方法：</p><pre><code class="language-java">    /**     * 根据id查询员工     * @param id     * @return     */    Employee getById(Long id);</code></pre><p><strong>3). Service层实现类</strong></p><p>在 EmployeeServiceImpl 中实现 getById 方法：</p><pre><code class="language-java"> /**     * 根据id查询员工     *     * @param id     * @return     */    public Employee getById(Long id) &#123;        Employee employee = employeeMapper.getById(id);        employee.setPassword(&quot;****&quot;);        return employee;    &#125;</code></pre><p><strong>4). Mapper层</strong></p><p>在 EmployeeMapper 接口中声明 getById 方法：</p><pre><code class="language-java">/**     * 根据id查询员工信息     * @param id     * @return     */    @Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)    Employee getById(Long id);</code></pre><h3 id="修改员工信息功能"><a href="#修改员工信息功能" class="headerlink" title="修改员工信息功能"></a>修改员工信息功能</h3><p><strong>1). Controller层</strong></p><p>在 EmployeeController 中创建 update 方法：</p><pre><code class="language-java">/**     * 编辑员工信息     * @param employeeDTO     * @return     */    @PutMapping    @ApiOperation(&quot;编辑员工信息&quot;)    public Result update(@RequestBody EmployeeDTO employeeDTO)&#123;        log.info(&quot;编辑员工信息：&#123;&#125;&quot;, employeeDTO);        employeeService.update(employeeDTO);        return Result.success();    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p>在 EmployeeService 接口中声明 update 方法：</p><pre><code class="language-java">    /**     * 编辑员工信息     * @param employeeDTO     */    void update(EmployeeDTO employeeDTO);</code></pre><p><strong>3). Service层实现类</strong></p><p>在 EmployeeServiceImpl 中实现 update 方法：</p><pre><code class="language-java"> /**     * 编辑员工信息     *     * @param employeeDTO     */    public void update(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        BeanUtils.copyProperties(employeeDTO, employee);        employee.setUpdateTime(LocalDateTime.now());        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.update(employee);    &#125;</code></pre><p>在实现<strong>启用禁用员工账号</strong>功能时，已实现employeeMapper.update(employee)，在此不需写Mapper层代码。</p><h2 id="接口测试-3"><a href="#接口测试-3" class="headerlink" title="接口测试"></a>接口测试</h2><p><strong>1)：根据id查询并回显信息到编辑页面</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716093851763.png" class="" alt="image-20250716093851763"><p><strong>2)：编辑页面</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716093819962.png" class="" alt="image-20250716093819962"><h1 id="分类模块功能"><a href="#分类模块功能" class="headerlink" title="分类模块功能"></a>分类模块功能</h1><h2 id="需求分析与设计-2"><a href="#需求分析与设计-2" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型-4"><a href="#产品原型-4" class="headerlink" title="产品原型"></a>产品原型</h3><p>后台系统中可以管理分类信息，分类包括两种类型，分别是 <strong>菜品分类</strong> 和 <strong>套餐分类</strong> 。</p><p>先来分析<strong>菜品分类</strong>相关功能。</p><p>**新增菜品分类：**当我们在后台系统中添加菜品时需要选择一个菜品分类，在移动端也会按照菜品分类来展示对应的菜品。</p><p>**菜品分类分页查询：**系统中的分类很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p><p>**根据id删除菜品分类：**在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。</p><p>**修改菜品分类：**在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作。</p><p>**启用禁用菜品分类：**在分类管理列表页面，可以对某个分类进行启用或者禁用操作。</p><p>**分类类型查询：**当点击分类类型下拉框时，从数据库中查询所有的菜品分类数据进行展示。</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094626559.png" class="" alt="image-20250716094626559"><p><strong>业务规则：</strong></p><ul><li>分类名称必须是唯一的</li><li>分类按照类型可以分为菜品分类和套餐分类</li><li>新添加的分类状态默认为“禁用”</li></ul><h3 id="接口设计-3"><a href="#接口设计-3" class="headerlink" title="接口设计"></a>接口设计</h3><p>根据上述原型图分析，菜品分类模块共涉及6个接口。</p><ul><li>新增分类</li><li>分类分页查询</li><li>根据id删除分类</li><li>修改分类</li><li>启用禁用分类</li><li>根据类型查询分类</li></ul><p><strong>1). 新增分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094733102.png" class="" alt="image-20250716094733102"><p><strong>2). 分类分页查询</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094804295.png" class="" alt="image-20250716094804295"><p><strong>3). 根据id删除分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094816303.png" class="" alt="image-20250716094816303"><p><strong>4). 修改分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094830240.png" class="" alt="image-20250716094830240"><p><strong>5). 启用禁用分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094843290.png" class="" alt="image-20250716094843290"><p><strong>6). 根据类型查询分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094855582.png" class="" alt="image-20250716094855582"><h3 id="表设计-1"><a href="#表设计-1" class="headerlink" title="表设计"></a>表设计</h3><p><strong>category表结构：</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>name</td><td>varchar(32)</td><td>分类名称</td><td>唯一</td></tr><tr><td>type</td><td>int</td><td>分类类型</td><td>1菜品分类 2套餐分类</td></tr><tr><td>sort</td><td>int</td><td>排序字段</td><td>用于分类数据的排序</td></tr><tr><td>status</td><td>int</td><td>状态</td><td>1启用 0禁用</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>update_time</td><td>datetime</td><td>最后修改时间</td><td></td></tr><tr><td>create_user</td><td>bigint</td><td>创建人id</td><td></td></tr><tr><td>update_user</td><td>bigint</td><td>最后修改人id</td><td></td></tr></tbody></table><h2 id="代码导入"><a href="#代码导入" class="headerlink" title="代码导入"></a>代码导入</h2><p>进入到sky-server模块中</p><h3 id="Mapper层-3"><a href="#Mapper层-3" class="headerlink" title="Mapper层"></a>Mapper层</h3><p><strong>DishMapper.java</strong></p><pre><code class="language-java">package com.sky.mapper;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;@Mapperpublic interface DishMapper &#123;    /**     * 根据分类id查询菜品数量     * @param categoryId     * @return     */    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)    Integer countByCategoryId(Long categoryId);&#125;</code></pre><p><strong>SetmealMapper.java</strong></p><pre><code class="language-java">package com.sky.mapper;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;@Mapperpublic interface SetmealMapper &#123;    /**     * 根据分类id查询套餐的数量     * @param id     * @return     */    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)    Integer countByCategoryId(Long id);&#125;</code></pre><p><strong>CategoryMapper.java</strong></p><pre><code class="language-java">package com.sky.mapper;import com.github.pagehelper.Page;import com.sky.dto.CategoryPageQueryDTO;import com.sky.entity.Category;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface CategoryMapper &#123;    /**     * 插入数据     * @param category     */    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +            &quot; VALUES&quot; +            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)    void insert(Category category);    /**     * 分页查询     * @param categoryPageQueryDTO     * @return     */    Page&lt;Category&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);    /**     * 根据id删除分类     * @param id     */    @Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)    void deleteById(Long id);    /**     * 根据id修改分类     * @param category     */    void update(Category category);    /**     * 根据类型查询分类     * @param type     * @return     */    List&lt;Category&gt; list(Integer type);&#125;</code></pre><p><strong>CategoryMapper.xml</strong>,进入到resources&#x2F;mapper目录下</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.CategoryMapper&quot;&gt;    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Category&quot;&gt;        select * from category        &lt;where&gt;            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)            &lt;/if&gt;            &lt;if test=&quot;type != null&quot;&gt;                and type = #&#123;type&#125;            &lt;/if&gt;        &lt;/where&gt;        order by sort asc , create_time desc    &lt;/select&gt;    &lt;update id=&quot;update&quot; parameterType=&quot;Category&quot;&gt;        update category        &lt;set&gt;            &lt;if test=&quot;type != null&quot;&gt;                type = #&#123;type&#125;,            &lt;/if&gt;            &lt;if test=&quot;name != null&quot;&gt;                name = #&#123;name&#125;,            &lt;/if&gt;            &lt;if test=&quot;sort != null&quot;&gt;                sort = #&#123;sort&#125;,            &lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;                status = #&#123;status&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;                update_time = #&#123;updateTime&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;                update_user = #&#123;updateUser&#125;            &lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;    &lt;/update&gt;    &lt;select id=&quot;list&quot; resultType=&quot;Category&quot;&gt;        select * from category        where status = 1        &lt;if test=&quot;type != null&quot;&gt;            and type = #&#123;type&#125;        &lt;/if&gt;        order by sort asc,create_time desc    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="5-2-2-Service层"><a href="#5-2-2-Service层" class="headerlink" title="5.2.2 Service层"></a>5.2.2 Service层</h3><p><strong>CategoryService.java</strong></p><pre><code class="language-java">package com.sky.service;import com.sky.dto.CategoryDTO;import com.sky.dto.CategoryPageQueryDTO;import com.sky.entity.Category;import com.sky.result.PageResult;import java.util.List;public interface CategoryService &#123;    /**     * 新增分类     * @param categoryDTO     */    void save(CategoryDTO categoryDTO);    /**     * 分页查询     * @param categoryPageQueryDTO     * @return     */    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);    /**     * 根据id删除分类     * @param id     */    void deleteById(Long id);    /**     * 修改分类     * @param categoryDTO     */    void update(CategoryDTO categoryDTO);    /**     * 启用、禁用分类     * @param status     * @param id     */    void startOrStop(Integer status, Long id);    /**     * 根据类型查询分类     * @param type     * @return     */    List&lt;Category&gt; list(Integer type);&#125;</code></pre><p><strong>EmployeeServiceImpl.java</strong></p><pre><code class="language-java">package com.sky.service.impl;import com.github.pagehelper.Page;import com.github.pagehelper.PageHelper;import com.sky.constant.MessageConstant;import com.sky.constant.PasswordConstant;import com.sky.constant.StatusConstant;import com.sky.context.BaseContext;import com.sky.dto.EmployeeDTO;import com.sky.dto.EmployeeLoginDTO;import com.sky.dto.EmployeePageQueryDTO;import com.sky.entity.Employee;import com.sky.exception.AccountLockedException;import com.sky.exception.AccountNotFoundException;import com.sky.exception.PasswordErrorException;import com.sky.mapper.EmployeeMapper;import com.sky.result.PageResult;import com.sky.service.EmployeeService;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.DigestUtils;import java.time.LocalDateTime;import java.util.List;@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123;    @Autowired    private EmployeeMapper employeeMapper;    /**     * 员工登录     *     * @param employeeLoginDTO     * @return     */    public Employee login(EmployeeLoginDTO employeeLoginDTO) &#123;        String username = employeeLoginDTO.getUsername();        String password = employeeLoginDTO.getPassword();        //1、根据用户名查询数据库中的数据        Employee employee = employeeMapper.getByUsername(username);        //2、处理各种异常情况（用户名不存在、密码不对、账号被锁定）        if (employee == null) &#123;            //账号不存在            throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND);        &#125;        //密码比对        // TODO 后期需要进行md5加密，然后再进行比对        password = DigestUtils.md5DigestAsHex(password.getBytes());        if (!password.equals(employee.getPassword())) &#123;            //密码错误            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);        &#125;        if (employee.getStatus() == StatusConstant.DISABLE) &#123;            //账号被锁定            throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED);        &#125;        //3、返回实体对象        return employee;    &#125;    /**     * 新增员工     *     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        //对象属性拷贝        BeanUtils.copyProperties(employeeDTO, employee);        //设置账号的状态，默认正常状态 1表示正常 0表示锁定        employee.setStatus(StatusConstant.ENABLE);        //设置密码，默认密码123456        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));        //设置当前记录的创建时间和修改时间        employee.setCreateTime(LocalDateTime.now());        employee.setUpdateTime(LocalDateTime.now());        //设置当前记录创建人id和修改人id        employee.setCreateUser(BaseContext.getCurrentId());//目前写个假数据，后期修改        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.insert(employee);    &#125;    /**     * 分页查询     *     * @param employeePageQueryDTO     * @return     */    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;        // select * from employee limit 0,10        //开始分页查询        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());        Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);        long total = page.getTotal();        List&lt;Employee&gt; records = page.getResult();        return new PageResult(total, records);    &#125;    /**     * 启用禁用员工账号     *     * @param status     * @param id     */    public void startOrStop(Integer status, Long id) &#123;        Employee employee = Employee.builder()                .status(status)                .id(id)                .build();        employeeMapper.update(employee);    &#125;    /**     * 根据id查询员工     *     * @param id     * @return     */    public Employee getById(Long id) &#123;        Employee employee = employeeMapper.getById(id);        employee.setPassword(&quot;****&quot;);        return employee;    &#125;    /**     * 编辑员工信息     *     * @param employeeDTO     */    public void update(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        BeanUtils.copyProperties(employeeDTO, employee);        employee.setUpdateTime(LocalDateTime.now());        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.update(employee);    &#125;&#125;</code></pre><p><strong>CategoryServiceImpl</strong></p><pre><code class="language-java">package com.sky.service.impl;import com.github.pagehelper.Page;import com.github.pagehelper.PageHelper;import com.sky.constant.MessageConstant;import com.sky.constant.StatusConstant;import com.sky.context.BaseContext;import com.sky.dto.CategoryDTO;import com.sky.dto.CategoryPageQueryDTO;import com.sky.entity.Category;import com.sky.exception.DeletionNotAllowedException;import com.sky.mapper.CategoryMapper;import com.sky.mapper.DishMapper;import com.sky.mapper.SetmealMapper;import com.sky.result.PageResult;import com.sky.service.CategoryService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.time.LocalDateTime;import java.util.List;/** * 分类业务层 */@Service@Slf4jpublic class CategoryServiceImpl implements CategoryService &#123;    @Autowired    private CategoryMapper categoryMapper;    @Autowired    private DishMapper dishMapper;    @Autowired    private SetmealMapper setmealMapper;    /**     * 新增分类     * @param categoryDTO     */    public void save(CategoryDTO categoryDTO) &#123;        Category category = new Category();        //属性拷贝        BeanUtils.copyProperties(categoryDTO, category);        //分类状态默认为禁用状态0        category.setStatus(StatusConstant.DISABLE);        //设置创建时间、修改时间、创建人、修改人        category.setCreateTime(LocalDateTime.now());        category.setUpdateTime(LocalDateTime.now());        category.setCreateUser(BaseContext.getCurrentId());        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.insert(category);    &#125;    /**     * 分页查询     * @param categoryPageQueryDTO     * @return     */    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());        //下一条sql进行分页，自动加入limit关键字分页        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);        return new PageResult(page.getTotal(), page.getResult());    &#125;    /**     * 根据id删除分类     * @param id     */    public void deleteById(Long id) &#123;        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常        Integer count = dishMapper.countByCategoryId(id);        if(count &gt; 0)&#123;            //当前分类下有菜品，不能删除            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);        &#125;        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常        count = setmealMapper.countByCategoryId(id);        if(count &gt; 0)&#123;            //当前分类下有菜品，不能删除            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);        &#125;        //删除分类数据        categoryMapper.deleteById(id);    &#125;    /**     * 修改分类     * @param categoryDTO     */    public void update(CategoryDTO categoryDTO) &#123;        Category category = new Category();        BeanUtils.copyProperties(categoryDTO,category);        //设置修改时间、修改人        category.setUpdateTime(LocalDateTime.now());        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.update(category);    &#125;    /**     * 启用、禁用分类     * @param status     * @param id     */    public void startOrStop(Integer status, Long id) &#123;        Category category = Category.builder()                .id(id)                .status(status)                .updateTime(LocalDateTime.now())                .updateUser(BaseContext.getCurrentId())                .build();        categoryMapper.update(category);    &#125;    /**     * 根据类型查询分类     * @param type     * @return     */    public List&lt;Category&gt; list(Integer type) &#123;        return categoryMapper.list(type);    &#125;&#125;</code></pre><h3 id="5-2-3-Controller层"><a href="#5-2-3-Controller层" class="headerlink" title="5.2.3 Controller层"></a>5.2.3 Controller层</h3><p><strong>CategoryController.java</strong></p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.dto.CategoryDTO;import com.sky.dto.CategoryPageQueryDTO;import com.sky.entity.Category;import com.sky.result.PageResult;import com.sky.result.Result;import com.sky.service.CategoryService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * 分类管理 */@RestController@RequestMapping(&quot;/admin/category&quot;)@Api(tags = &quot;分类相关接口&quot;)@Slf4jpublic class CategoryController &#123;    @Autowired    private CategoryService categoryService;    /**     * 新增分类     * @param categoryDTO     * @return     */    @PostMapping    @ApiOperation(&quot;新增分类&quot;)    public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123;        log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO);        categoryService.save(categoryDTO);        return Result.success();    &#125;    /**     * 分类分页查询     * @param categoryPageQueryDTO     * @return     */    @GetMapping(&quot;/page&quot;)    @ApiOperation(&quot;分类分页查询&quot;)    public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO)&#123;        log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO);        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);        return Result.success(pageResult);    &#125;    /**     * 删除分类     * @param id     * @return     */    @DeleteMapping    @ApiOperation(&quot;删除分类&quot;)    public Result&lt;String&gt; deleteById(Long id)&#123;        log.info(&quot;删除分类：&#123;&#125;&quot;, id);        categoryService.deleteById(id);        return Result.success();    &#125;    /**     * 修改分类     * @param categoryDTO     * @return     */    @PutMapping    @ApiOperation(&quot;修改分类&quot;)    public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO)&#123;        categoryService.update(categoryDTO);        return Result.success();    &#125;    /**     * 启用、禁用分类     * @param status     * @param id     * @return     */    @PostMapping(&quot;/status/&#123;status&#125;&quot;)    @ApiOperation(&quot;启用禁用分类&quot;)    public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123;        categoryService.startOrStop(status,id);        return Result.success();    &#125;    /**     * 根据类型查询分类     * @param type     * @return     */    @GetMapping(&quot;/list&quot;)    @ApiOperation(&quot;根据类型查询分类&quot;)    public Result&lt;List&lt;Category&gt;&gt; list(Integer type)&#123;        List&lt;Category&gt; list = categoryService.list(type);        return Result.success(list);    &#125;&#125;</code></pre><p>全部导入完毕后，进行编译</p><h2 id="前后端联调测试"><a href="#前后端联调测试" class="headerlink" title="前后端联调测试"></a>前后端联调测试</h2><p><strong>1):新增分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101043331.png" class="" alt="image-20250716101043331"><p><strong>2):分页查询</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101201565.png" class="" alt="image-20250716101201565"><p><strong>3):分类查询</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101311029.png" class="" alt="image-20250716101311029"><p><strong>4):启用禁用</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101345295.png" class="" alt="image-20250716101345295"><p><strong>5):回显信息到修改界面</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101436324.png" class="" alt="image-20250716101436324"><p>修改后：</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101557511.png" class="" alt="image-20250716101557511"><p><strong>6):删除</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101636409.png" class="" alt="image-20250716101636409"><p>删除后：</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101704023.png" class="" alt="image-20250716101704023">]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（一）环境准备</title>
      <link href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
      <url>/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>我的gitee仓库，内涵源代码<a href="https://gitee.com/zhouhuiqiang5704/sky-cqwm.git">https://gitee.com/zhouhuiqiang5704/sky-cqwm.git</a></p></blockquote><h1 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>完成需求规格说明书、产品原型编写。  </p><p><strong>需求规格说明书</strong>： 一般来说就是使用 Word 文档来描述当前项目的各个组成部分，如：系统定义、应用环境、功能规格、性能需求等，都会在文档中描述。<strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110354550.png" class="" alt="image-20250715110354550"><p><strong>产品原型</strong>：一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。 <strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110407886.png" class="" alt="image-20250715110407886"><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计的内容包含 UI设计、数据库设计、接口设计。</p><p><strong>UI设计</strong>：用户界面的设计，主要设计项目的页面效果，小到一个按钮，大到一个页面布局，还有人机交互逻辑的体现。</p><p><strong>数据库设计</strong>：需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段。<strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110432975.png" class="" alt="image-20250715110432975"><p><strong>接口设计</strong>：通过分析原型图，首先，粗粒度地分析每个页面有多少接口，然后，再细粒度地分析每个接口的传入参数，返回值参数，同时明确接口路径及请求方式。<strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110442295.png" class="" alt="image-20250715110442295"><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编写项目代码、并完成单元测试。</p><p>项目代码编写：作为软件开发工程师，我们需要对项目的模块功能分析后，进行编码实现。</p><p>单元测试：编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。</p><p><strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110450986.png" class="" alt="image-20250715110450986"><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。</p><h2 id="上线运维"><a href="#上线运维" class="headerlink" title="上线运维"></a>上线运维</h2><p>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。</p><h1 id="苍穹外卖（一）环境准备项目介绍"><a href="#苍穹外卖（一）环境准备项目介绍" class="headerlink" title="苍穹外卖（一）环境准备项目介绍"></a>苍穹外卖（一）环境准备项目介绍</h1><h2 id="业务功能模块"><a href="#业务功能模块" class="headerlink" title="业务功能模块"></a>业务功能模块</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110642407.png" class="" alt="image-20250715110642407"><p><strong>1). 管理端功能</strong></p><p>员工登录&#x2F;退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 ，数据统计，来单提醒。</p><p><strong>2). 用户端功能</strong></p><p> 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 支付、分类及菜品浏览。</p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><p><strong>1). 管理端</strong></p><p><strong>餐饮企业内部员工使用。</strong> 主要功能有: </p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>内部员工必须登录后,才可以访问系统管理后台</td></tr><tr><td>员工管理</td><td>管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能</td></tr><tr><td>分类管理</td><td>主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护， 包含查询、新增、修改、删除等功能</td></tr><tr><td>菜品管理</td><td>主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>套餐管理</td><td>主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>订单管理</td><td>主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能</td></tr><tr><td>数据统计</td><td>主要完成对餐厅的各类数据统计，如营业额、用户数量、订单等</td></tr></tbody></table><p><strong>2). 用户端</strong></p><p>**移动端应用主要提供给消费者使用。**主要功能有:</p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>用户需要通过微信授权后登录使用小程序进行点餐</td></tr><tr><td>点餐-菜单</td><td>在点餐界面需要展示出菜品分类&#x2F;套餐分类, 并根据当前选择的分类加载其中的菜品信息, 供用户查询选择</td></tr><tr><td>点餐-购物车</td><td>用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除购物车、清空购物车等功能</td></tr><tr><td>订单支付</td><td>用户选完菜品&#x2F;套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支付</td></tr><tr><td>个人信息</td><td>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查询历史订单数据</td></tr></tbody></table><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20221106185646994.png" class="" alt="image-20221106185646994"><p><strong>1). 用户层</strong></p><p>本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI、apache echarts(展示图表)等技术。而在构建移动端应用时，我们会使用到微信小程序。</p><p><strong>2). 网关层</strong></p><p>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。</p><p><strong>3). 应用层</strong></p><p>SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开发。</p><p>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。</p><p>Spring Task:  由Spring提供的定时任务框架。</p><p>httpclient:  主要实现了对http请求的发送。</p><p>Spring Cache:  由Spring提供的数据缓存框架</p><p>JWT:  用于对应用程序上的用户进行身份验证的标记。</p><p>阿里云OSS:  对象存储服务，在项目中主要存储文件，如图片等。</p><p>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</p><p>POI:  封装了对Excel表格的常用操作。</p><p>WebSocket: 一种通信网络协议，使客户端和服务器之间的数据交换更加简单，用于项目的来单、催单功能实现。</p><p><strong>4). 数据层</strong></p><p>MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。</p><p>Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存。</p><p>Mybatis： 本项目持久层将会使用Mybatis开发。</p><p>pagehelper:  分页插件。</p><p>spring data redis:  简化java代码操作Redis的API。</p><p><strong>5). 工具</strong></p><p>git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。</p><p>maven: 项目构建工具。</p><p>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</p><p>postman:  接口测工具，模拟用户发起的各类HTTP请求，获取对应的响应结果。</p><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><p>开发环境搭建主要包含<strong>前端环境</strong>和<strong>后端环境</strong>两部分。作为服务端开发工程师， 我们重心放在后端的业务代码上， 前端的页面我们只需要导入资料中的nginx。</p><h2 id="前端开发环境"><a href="#前端开发环境" class="headerlink" title="前端开发环境"></a>前端开发环境</h2><p>管理端：前端资源</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093009864.png" class="" alt="image-20250715093009864"><p>双击 nginx.exe 即可启动 nginx 服务，访问端口号为 80</p><p><a href="http://localhost/">http://localhost:80</a></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093119330.png" class="" alt="image-20250715093119330"><h2 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093248485.png" class="" alt="image-20250715093248485"><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093535835.png" class="" alt="image-20250715093535835"><table><thead><tr><th><strong>序号</strong></th><th align="left"><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1</td><td align="left">sky-take-out</td><td><strong>maven父工程</strong>，统一管理<strong>依赖版本</strong>，聚合其他子模块</td></tr><tr><td>2</td><td align="left">sky-common</td><td>子模块，存放公共类，例如：工具类、常量类、异常类等</td></tr><tr><td>3</td><td align="left">sky-pojo</td><td>子模块，存放实体类、VO、DTO等</td></tr><tr><td>4</td><td align="left">sky-server</td><td>子模块，后端服务，存放配置文件、Controller、Service、Mapper等</td></tr></tbody></table><h4 id="sky-common"><a href="#sky-common" class="headerlink" title="sky-common"></a>sky-common</h4><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093730491.png" class="" alt="image-20250715093730491"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>constant</td><td>存放相关常量类</td></tr><tr><td>context</td><td>存放上下文类</td></tr><tr><td>enumeration</td><td>项目的枚举类存储</td></tr><tr><td>exception</td><td>存放自定义异常类</td></tr><tr><td>json</td><td>处理json转换的类</td></tr><tr><td>properties</td><td>存放SpringBoot相关的配置属性类</td></tr><tr><td>result</td><td>返回结果类的封装</td></tr><tr><td>utils</td><td>常用工具类</td></tr></tbody></table><h4 id="sky-pojo"><a href="#sky-pojo" class="headerlink" title="sky-pojo"></a>sky-pojo</h4><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093821373.png" class="" alt="image-20250715093821373"><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Entity</td><td>实体，通常和数据库中的表对应</td></tr><tr><td>DTO</td><td>数据传输对象，通常用于程序中各层之间传递数据</td></tr><tr><td>VO</td><td>视图对象，为前端展示数据提供的对象</td></tr><tr><td>POJO</td><td>普通Java对象，只有属性和对应的getter和setter</td></tr></tbody></table><h4 id="sky-server"><a href="#sky-server" class="headerlink" title="sky-server"></a>sky-server</h4><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093858876.png" class="" alt="image-20250715093858876"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>config</td><td>存放配置类</td></tr><tr><td>controller</td><td>存放controller类</td></tr><tr><td>interceptor</td><td>存放拦截器类</td></tr><tr><td>mapper</td><td>存放mapper接口</td></tr><tr><td>service</td><td>存放service类</td></tr><tr><td>SkyApplication</td><td>启动类</td></tr></tbody></table><h2 id="git版本控制-远程推送仓库"><a href="#git版本控制-远程推送仓库" class="headerlink" title="git版本控制-远程推送仓库"></a>git版本控制-远程推送仓库</h2><p><strong>1). 创建Git本地仓库</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110704459.png" class="" alt="image-20250715110704459"><p>当Idea中出现：</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715094309776.png" class="" alt="image-20250715094309776"><p>说明本地仓库创建成功。</p><p><strong>2).推送初始代码工程</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715095355931.png" class="" alt="image-20250715095355931"><p><strong>3).连接远程仓库</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715095657061.png" class="" alt="image-20250715095657061"><p><strong>之后会让你输入凭证（gitee账号密码）</strong>，然后就可以看见仓库中刚刚推送的文件了。</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715095937973.png" class="" alt="image-20250715095937973"><h2 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h2><p>执行sql文件</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715100224269.png" class="" alt="image-20250715100224269"><table><thead><tr><th><strong>序号</strong></th><th><strong>表名</strong></th><th><strong>中文名</strong></th></tr></thead><tbody><tr><td>1</td><td>employee</td><td>员工表</td></tr><tr><td>2</td><td>category</td><td>分类表</td></tr><tr><td>3</td><td>dish</td><td>菜品表</td></tr><tr><td>4</td><td>dish_flavor</td><td>菜品口味表</td></tr><tr><td>5</td><td>setmeal</td><td>套餐表</td></tr><tr><td>6</td><td>setmeal_dish</td><td>套餐菜品关系表</td></tr><tr><td>7</td><td>user</td><td>用户表</td></tr><tr><td>8</td><td>address_book</td><td>地址表</td></tr><tr><td>9</td><td>shopping_cart</td><td>购物车表</td></tr><tr><td>10</td><td>orders</td><td>订单表</td></tr><tr><td>11</td><td>order_detail</td><td>订单明细表</td></tr></tbody></table><h2 id="前后联调"><a href="#前后联调" class="headerlink" title="前后联调"></a>前后联调</h2><p><strong>别忘记修改数据库配置</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715100736241.png" class="" alt="image-20250715100736241"><p>访问地址：<a href="http://localhost/#/login">http://localhost:80/#/login</a></p><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：</p><ol><li>使得前后端分离开发更加方便，有利于团队协作</li><li>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</li></ol><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>目前，一般都使用knife4j框架。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><p>导入 knife4j 的maven坐标</p><p>在pom.xml中添加依赖</p><pre><code class="language-xml">&lt;dependency&gt;   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>在配置类中加入 knife4j 相关配置</p><p>WebMvcConfiguration.java</p><pre><code class="language-java">/**     * 通过knife4j生成接口文档     * @return*/    @Bean    public Docket docket() &#123;        ApiInfo apiInfo = new ApiInfoBuilder()                .title(&quot;苍穹外卖（一）环境准备项目接口文档&quot;)                .version(&quot;2.0&quot;)                .description(&quot;苍穹外卖（一）环境准备项目接口文档&quot;)                .build();        Docket docket = new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo)                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))                .paths(PathSelectors.any())                .build();        return docket;    &#125;</code></pre></li><li><p>设置静态资源映射，否则接口文档页面无法访问</p><p>WebMvcConfiguration.java</p><pre><code class="language-java">/**     * 设置静态资源映射     * @param registry*/protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);&#125;</code></pre></li><li><p>访问测试</p><p>接口文档访问路径 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110843996.png" class="" alt="image-20250715110843996"><p>接口测试:测试登录功能</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715111011456.png" class="" alt="image-20250715111011456"></li></ol><p>**思考：**通过 Swagger 就可以生成接口文档，那么我们就不需要 Yapi 了？</p><p>1、Yapi 是设计阶段使用的工具，管理和维护接口</p><p>2、Swagger 在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table><p>接下来，使用上述注解，生成可读性更好的接口文档</p><p>在sky-pojo模块中</p><p>EmployeeLoginDTO.java</p><pre><code class="language-java">package com.sky.dto;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.io.Serializable;@Data@ApiModel(description = &quot;员工登录时传递的数据模型&quot;)public class EmployeeLoginDTO implements Serializable &#123;    @ApiModelProperty(&quot;用户名&quot;)    private String username;    @ApiModelProperty(&quot;密码&quot;)    private String password;&#125;</code></pre><p>EmployeeLoginVo.java</p><pre><code class="language-java">package com.sky.vo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@Builder@NoArgsConstructor@AllArgsConstructor@ApiModel(description = &quot;员工登录返回的数据格式&quot;)public class EmployeeLoginVO implements Serializable &#123;    @ApiModelProperty(&quot;主键值&quot;)    private Long id;    @ApiModelProperty(&quot;用户名&quot;)    private String userName;    @ApiModelProperty(&quot;姓名&quot;)    private String name;    @ApiModelProperty(&quot;jwt令牌&quot;)    private String token;&#125;</code></pre><p>在sky-server模块中</p><p>EmployeeController.java</p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.constant.JwtClaimsConstant;import com.sky.dto.EmployeeLoginDTO;import com.sky.entity.Employee;import com.sky.properties.JwtProperties;import com.sky.result.Result;import com.sky.service.EmployeeService;import com.sky.utils.JwtUtil;import com.sky.vo.EmployeeLoginVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;/** * 员工管理 */@RestController@RequestMapping(&quot;/admin/employee&quot;)@Slf4j@Api(tags = &quot;员工相关接口&quot;)public class EmployeeController &#123;    @Autowired    private EmployeeService employeeService;    @Autowired    private JwtProperties jwtProperties;    /**     * 登录     *     * @param employeeLoginDTO     * @return     */    @PostMapping(&quot;/login&quot;)    @ApiOperation(value = &quot;员工登录&quot;)    public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123;        //..............            &#125;    /**     * 退出     *     * @return     */    @PostMapping(&quot;/logout&quot;)    @ApiOperation(&quot;员工退出&quot;)    public Result&lt;String&gt; logout() &#123;        return Result.success();    &#125;&#125;</code></pre><p>启动服务：访问<a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715111316655.png" class="" alt="image-20250715111316655">]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网SQL刷题总结</title>
      <link href="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="总结-基础知识"><a href="#总结-基础知识" class="headerlink" title="总结-基础知识"></a>总结-基础知识</h1><blockquote><p><a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=199">牛客网在线编程_SQL篇_SQL快速入门</a></p></blockquote><h2 id="去重复数据"><a href="#去重复数据" class="headerlink" title="去重复数据"></a>去重复数据</h2><blockquote><p>关键字：<code>distinct</code></p></blockquote><pre><code class="language-sql">select distinct university from user_profile</code></pre><h2 id="过滤空值"><a href="#过滤空值" class="headerlink" title="过滤空值"></a>过滤空值</h2><pre><code class="language-sql">where 列名 is not &#39;null&#39; where 列名 != &#39;null&#39;where 列名 &lt;&gt; &#39;null&#39; </code></pre><h2 id="多个匹配值"><a href="#多个匹配值" class="headerlink" title="多个匹配值"></a>多个匹配值</h2><blockquote><p>关键字：<code>in</code></p></blockquote><pre><code class="language-sql">select device_id,gender,age,university,gpafrom user_profilewhere university in (&#39;北京大学&#39;,&#39;复旦大学&#39;,&#39;山东大学&#39;) </code></pre><h2 id="模糊查询（匹配字符串）"><a href="#模糊查询（匹配字符串）" class="headerlink" title="模糊查询（匹配字符串）"></a>模糊查询（匹配字符串）</h2><blockquote><p>关键字：<code>like</code>   或者   <code>not like</code></p></blockquote><pre><code class="language-sql">select device_id,age,universityfrom user_profilewhere university like &#39;北京%&#39;</code></pre><blockquote><p>北京%：列名以北京开头</p><p>%北京：列名以北京结束</p><p>%北京%：列名中包括北京</p></blockquote><h2 id="MAX-最大函数值"><a href="#MAX-最大函数值" class="headerlink" title="MAX()最大函数值"></a>MAX()最大函数值</h2><blockquote><p>关键字：max()</p></blockquote><pre><code class="language-sql">select max(gpa) as gpafrom user_profilewhere university = &#39;复旦大学&#39;</code></pre><h2 id="avg-求平均值"><a href="#avg-求平均值" class="headerlink" title="avg()求平均值"></a>avg()求平均值</h2><pre><code class="language-sql">select  count(gender) as male_num,round(avg(gpa),1) as avg_gpafrom user_profilewhere gender = &#39;male&#39;</code></pre><h2 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round()四舍五入"></a>round()四舍五入</h2><blockquote><p><code>round(avg(gpa),1)</code>其中第二个参数表示保留一位小数</p></blockquote><pre><code class="language-sql">select  count(gender) as male_num,round(avg(gpa),1) as avg_gpafrom user_profilewhere gender = &#39;male&#39;</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote><p>关键字：<code>order by</code> 字段 ASC</p><p>​ASC:默认  升序</p><p>​DESC:  降序</p><p>——对多个字段排序时，按照书写的先后顺序依次排列</p></blockquote><pre><code class="language-sql">select    gender,university,count(device_id) as user_num,round(avg(active_days_within_30),1) as avg_active_day,round(avg(question_cnt),1) as avg_question_cntfrom    user_profilegroup by gender,universityorder by gender ASC,university ASC</code></pre><blockquote><p>先按照gender(性别)排序，在每个性别里面再按照university字段排序</p></blockquote><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><blockquote><p>关键字：<code>group by</code> 字段</p><p>多个字段使用<code>,</code>分隔</p></blockquote><pre><code class="language-sql">select    gender,university,count(device_id) as user_num,round(avg(active_days_within_30),1) as avg_active_day,round(avg(question_cnt),1) as avg_question_cntfrom    user_profilegroup by gender,universityorder by gender ASC,university ASC</code></pre><h3 id="对分组的字段，条件查询"><a href="#对分组的字段，条件查询" class="headerlink" title="对分组的字段，条件查询"></a>对分组的字段，条件查询</h3><blockquote><p>关键字：having    </p><p>当对字段进行<code>group by</code>分组之后，就不能使用where来限制条件，必须使用having</p></blockquote><pre><code class="language-sql">select    university,    round(avg(question_cnt), 3) as avg_question_cnt,    round(avg(answer_cnt), 3) as avg_answer_cntfrom    user_profilegroup by    universityhaving     avg(question_cnt)&lt;5 or avg(answer_cnt) &lt;20</code></pre><h2 id="多表连接-21-25"><a href="#多表连接-21-25" class="headerlink" title="多表连接 21-25"></a>多表连接 21-25</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote><p>注意点：子查询中不存在多表之间的联系，是使用<code>in</code>等关键字匹配字段的值来连接。</p><p>即 <code>from</code>关键字后都只有一个表</p></blockquote><pre><code class="language-sql">select device_id,question_id,resultfrom    question_practice_detailwhere question_practice_detail.device_id in(    select device_id    from user_profile    where university = &#39;浙江大学&#39;)</code></pre><h3 id="内连接–INNER-JOIN"><a href="#内连接–INNER-JOIN" class="headerlink" title="内连接–INNER JOIN"></a>内连接–INNER JOIN</h3><blockquote><p>关键字：<code>INNER JOIN</code>  连接的表名  <code>on</code>  关联的字段</p><p>后续可使用<code>where</code>关键字作筛选</p></blockquote><pre><code class="language-sql">select question_practice_detail.device_id,question_id,resultfrom    question_practice_detailInner JOIN user_profile on question_practice_detail.device_id = user_profile.device_idwhere university = &#39;浙江大学&#39;</code></pre><blockquote><p>在使用多个<code>INNER JOIN</code>关键字内连接其他表时，第一个表的字段与第二个表的字段连接，第二个表的字段与第三个表的字段连接。</p></blockquote><h3 id="左右连接29"><a href="#左右连接29" class="headerlink" title="左右连接29"></a>左右连接29</h3><blockquote><p>当结果中出现某一列需要输出为<code>null</code>的字段值，这么就使用左右连接</p></blockquote><pre><code class="language-sql">select Products.prod_name,OrderItems.order_numfrom Productsleft JOIN OrderItemson Products.prod_id = OrderItems.prod_id order by prod_name</code></pre><blockquote><img src="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/image-20250711085747146.png" class="" alt="image-20250711085747146"></blockquote><pre><code class="language-sql">SELECT    ROUND(        SUM(CASE WHEN p2.device_id IS NOT NULL THEN 1                ELSE 0            END        ) / COUNT(*),        4    ) AS avg_ret    # 也可以表示为    # COUNT(q2.device_id) / COUNT(q1.device_id) AS avg_ret    # 对于count（）函数计数时不会统计值为null的条目    # 因为是最左连接，会将p1表中的数据都显示，而只会显示符合条件的p2中留存的数据，否则为空        # 也就是说对于同一个人来说，第一天刷题，才会有p1.device_id。第二天刷题了，才会有p2.device_id，否则为空FROM    (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p1LEFT JOIN (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p2 ON p1.device_id = p2.device_id AND p2.date = DATE_ADD(p1.date, INTERVAL 1 DAY);</code></pre><h3 id="内连接与左右连接的区别"><a href="#内连接与左右连接的区别" class="headerlink" title="内连接与左右连接的区别"></a>内连接与左右连接的区别</h3><table><thead><tr><th align="left">连接类型</th><th align="left">行为</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>INNER JOIN</strong></td><td align="left">只返回两个表中<strong>匹配的行</strong></td><td align="left">只关心两个表都存在的关联数据</td></tr><tr><td align="left"><strong>LEFT JOIN</strong></td><td align="left">返回<strong>左表所有行</strong> + 右表<strong>匹配的行</strong>（右表无匹配则补 <code>NULL</code>）</td><td align="left">即使右表没有匹配，也要保留左表数据</td></tr><tr><td align="left"><strong>RIGHT JOIN</strong></td><td align="left">返回<strong>右表所有行</strong> + 左表<strong>匹配的行</strong>（左表无匹配则补 <code>NULL</code>）</td><td align="left">即使左表没有匹配，也要保留右表数据</td></tr></tbody></table><h3 id="联合查询-25"><a href="#联合查询-25" class="headerlink" title="联合查询 25"></a>联合查询 25</h3><blockquote><p>关键字：<code>UNION ALL</code> 或<code>UNION</code></p><p><code>UNION</code>:表示将两个查询结果连接起来，并且<strong>去重</strong></p><p><code>UNION ALL</code>:表示将两个查询结果连接起来，但是不<strong>去重</strong></p></blockquote><pre><code class="language-sql">select device_id,gender,age,gpafrom user_profilewhere university = &#39;山东大学&#39;union ALLselect device_id,gender,age,gpafrom user_profilewhere gender = &#39;male</code></pre><blockquote><ul><li><strong>结果集</strong>：包含两类数据的并集：<ol><li>山东大学的所有学生（无论性别）。</li><li>所有男性学生（无论学校）。</li></ol></li><li><strong>重复数据</strong>：如果一个山东大学的学生同时也是男性，则该学生的记录会 <strong>出现两次</strong>（因为 <code>UNION ALL</code> 保留重复）。</li></ul></blockquote><h2 id="条件逻辑"><a href="#条件逻辑" class="headerlink" title="条件逻辑"></a>条件逻辑</h2><blockquote><p>关键字：</p><pre><code class="language-sql">CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... ELSE default_resultEND</code></pre><p>当符合条件condition1时，将他设置为result1</p></blockquote><pre><code class="language-sql">select    case        when            age &lt; 25            or age is null then &#39;25岁以下&#39;            else &#39;25岁及以上&#39;    end as age_cut,    count(device_id) as numberfrom    user_profileGROUP BY    age_cut</code></pre><h2 id="年月日函数28"><a href="#年月日函数28" class="headerlink" title="年月日函数28"></a>年月日函数28</h2><blockquote><p>date:2021-05-03</p><p><code> year(date)</code>:取出date数据中的年  2021</p><p><code>month(date)</code>:取出date数据中的月  05</p><p><code>day(date)</code>:取出date数据中的日 03</p></blockquote><pre><code class="language-sql">select day(date) as day,count(question_id) as question_cntfrom question_practice_detailwhere month(date) = 8 and year(date) = 2021group by date</code></pre><h2 id="Date函数29"><a href="#Date函数29" class="headerlink" title="Date函数29"></a>Date函数29</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_now.asp">NOW()</a></td><td align="left">返回当前的日期和时间</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_curdate.asp">CURDATE()</a></td><td align="left">返回当前的日期</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_curtime.asp">CURTIME()</a></td><td align="left">返回当前的时间</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date.asp">DATE()</a></td><td align="left">提取日期或日期&#x2F;时间表达式的日期部分</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_extract.asp">EXTRACT()</a></td><td align="left">返回日期&#x2F;时间按的单独部分</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date_add.asp">DATE_ADD()</a></td><td align="left">给日期添加指定的时间间隔</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date_sub.asp">DATE_SUB()</a></td><td align="left">从日期减去指定的时间间隔</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_datediff_mysql.asp">DATEDIFF()</a></td><td align="left">返回两个日期之间的天数</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date_format.asp">DATE_FORMAT()</a></td><td align="left">用不同的格式显示日期&#x2F;时间</td></tr></tbody></table><blockquote><p>date_add()函数：<code>DATE_ADD(date,INTERVAL expr type)</code></p><p>​<em>date</em> 参数是合法的日期表达式。<em>expr</em> 参数是您希望添加的时间间隔。type参数是day,mouth,year等值。</p><p>​如果希望向 “OrderDate” 添加 2 天，<code>DATE_ADD(OrderDate,INTERVAL 2 DAY)</code>。</p></blockquote><img src="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/image-20250709150940731.png" class="" alt="image-20250709150940731"><pre><code class="language-sql">SELECT    ROUND(        SUM(CASE WHEN p2.device_id IS NOT NULL THEN 1                ELSE 0            END        ) / COUNT(*),        4    ) AS avg_ret    # 也可以表示为    # COUNT(q2.device_id) / COUNT(q1.device_id) AS avg_ret    # 对于count（）函数计数时不会统计值为null的条目    # 因为是最左 连接，会将p1表中的数据都显示，而只会显示符合条件的p2中留存的数据，否则为空        # 也就是说对于同一个人来说，第一天刷题，才会有p1.device_id。第二天刷题了，才会有p2.device_id，否则为空FROM    (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p1LEFT JOIN (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p2 ON p1.device_id = p2.device_id AND p2.date = DATE_ADD(p1.date, INTERVAL 1 DAY);</code></pre><h2 id="字符串截取30-拼接，转大小写"><a href="#字符串截取30-拼接，转大小写" class="headerlink" title="字符串截取30,拼接，转大小写"></a>字符串截取30,拼接，转大小写</h2> <img src="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/image-20250709151301784.png" class="" alt="image-20250709151301784"><img src="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/image-20250722091115521.png" class="" alt="image-20250722091115521"><pre><code class="language-sql">SELECT SUBSTRING_INDEX(profile,&quot;,&quot;,-1) gender,COUNT(*) numberFROM user_submitGROUP BY gender;</code></pre><blockquote><ul><li>使用 <code>GROUP BY gender</code> 后，SQL 会先按 <code>gender</code> 分类，再分别计算每组的 <code>COUNT(*)</code>。</li></ul></blockquote><blockquote><pre><code class="language-sql">字符串的截取：substring(字符串，起始位置，截取字符数）取字符串左边 size个字符:left(column_name,int size)字符串的拼接：concat(字符串1，字符串2，字符串3,...)字母大写：upper(字符串）字母小写：lower(字符串）</code></pre></blockquote><h3 id="case语句-模糊查询-笨蛋题解"><a href="#case语句-模糊查询-笨蛋题解" class="headerlink" title="case语句+模糊查询&#x3D;笨蛋题解"></a>case语句+模糊查询&#x3D;笨蛋题解</h3><pre><code class="language-sql">select    case        when profile like &#39;%,male&#39; then &#39;male&#39;        when profile like &#39;%,female&#39; then &#39;female&#39;    end gender,    count(device_id) as numberfrom    user_submitgroup by    gender;</code></pre><h2 id="窗口函数33-41"><a href="#窗口函数33-41" class="headerlink" title="窗口函数33,41"></a>窗口函数33,41</h2><blockquote><p>窗口函数</p></blockquote><blockquote><pre><code class="language-sql">SELECT *, DENSE_RANK() OVER (PARTITION BY university ORDER BY gpa) AS drFROM user_profile</code></pre></blockquote><pre><code class="language-sql"># 严格连续编号，即使分数相同也分配不同序号。ROW_NUMBER()# 每个大学中GPA最低的所有学生（包括并列情况）：DENSE_RANK()SELECT device_id, university, gpaFROM (    SELECT *, DENSE_RANK() OVER (PARTITION BY university ORDER BY gpa) AS dr    FROM user_profile) AS univ_minWHERE dr = 1ORDER BY university</code></pre><blockquote><h3 id="一、聚合类窗口函数"><a href="#一、聚合类窗口函数" class="headerlink" title="一、聚合类窗口函数"></a><strong>一、聚合类窗口函数</strong></h3><pre><code>SUM(), AVG(), MIN(), MAX(), COUNT()</code></pre><h3 id="二、排名类窗口函数"><a href="#二、排名类窗口函数" class="headerlink" title="二、排名类窗口函数"></a>二、排名类窗口函数</h3><table><thead><tr><th>ROW_NUMBER()</th><th>行号（相同值不同号）</th><th>1,2,3,4</th></tr></thead><tbody><tr><td>RANK()</td><td>排名（相同值并列但留空）</td><td>1,2,2,4</td></tr><tr><td>DENSE_RANK()</td><td>密集排名（相同值并列无空）</td><td>1,2,2,3</td></tr></tbody></table><h3 id="三、偏移分析类窗口函数"><a href="#三、偏移分析类窗口函数" class="headerlink" title="三、偏移分析类窗口函数"></a>三、偏移分析类窗口函数</h3><pre><code class="language-sql">LAG(column, n) -- 访问前n行值LEAD(column, n) -- 访问后n行值FIRST_VALUE(column) -- 窗口第一行LAST_VALUE(column) -- 窗口最后一行</code></pre><h3 id="四、统计类窗口函数"><a href="#四、统计类窗口函数" class="headerlink" title="四、统计类窗口函数"></a>四、统计类窗口函数</h3><pre><code class="language-sql">PERCENT_RANK() -- 排名百分比 (0-1)CUME_DIST()   -- 累计分布 (0-1)STDDEV(), VAR() -- 标准差和方差</code></pre></blockquote><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="PARTITION-BY-——-分组处理"><a href="#PARTITION-BY-——-分组处理" class="headerlink" title="PARTITION BY —— 分组处理"></a><code>PARTITION BY</code> —— 分组处理</h4><ul><li>类似 <code>GROUP BY</code>，但<strong>不聚合</strong>，仅把行划分成若干组；</li><li>每组窗口函数单独计算；</li><li>可选，不写则默认全表一组。</li></ul><h4 id="ORDER-BY-——-窗口内排序"><a href="#ORDER-BY-——-窗口内排序" class="headerlink" title="ORDER BY —— 窗口内排序"></a><code>ORDER BY</code> —— 窗口内排序</h4><ul><li>决定行的先后顺序；</li><li>排序顺序直接影响如排名、前后行等函数计算；</li><li>必须写在 <code>OVER(...)</code> 内部，否则是整个结果集排序。</li></ul><h4 id="ROWS-BETWEEN-——-明确窗口范围"><a href="#ROWS-BETWEEN-——-明确窗口范围" class="headerlink" title="ROWS BETWEEN —— 明确窗口范围"></a><code>ROWS BETWEEN</code> —— 明确窗口范围</h4><table><thead><tr><th><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></th><th>从分区第一行到当前行（累计）</th></tr></thead><tbody><tr><td><code>ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</code></td><td>当前行、前一行、后一行</td></tr><tr><td><code>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code></td><td>当前行到最后一行</td></tr></tbody></table><blockquote><p>若不写 <code>ROWS</code>，窗口函数默认是“从分区首行到当前行”或整个分区（函数而异）</p></blockquote><h2 id="if条件表达34"><a href="#if条件表达34" class="headerlink" title="if条件表达34"></a>if条件表达34</h2><pre><code class="language-sql">IF(condition, value_if_true, value_if_false)这是一个条件表达式，类似于编程语言中的三元运算符：</code></pre><blockquote><pre><code class="language-sql">sum(if(qpd.result=&#39;right&#39;, 1, 0))</code></pre><ul><li><strong><code>qpd.result=&#39;right&#39;</code></strong>：条件判断，检查 <code>result</code> 字段是否等于 ‘right’</li><li><strong><code>1</code></strong>：如果条件为真（即 result&#x3D;’right’）时返回的值</li><li><strong><code>0</code></strong>：如果条件为假（即 result≠’right’）时返回的值</li></ul></blockquote><pre><code class="language-sql">select up.device_id,university,    count(question_id) as question_cnt,    sum(if(qpd.result=&#39;right&#39;, 1, 0)) as right_question_cntfrom user_profile as upleft join question_practice_detail as qpdon qpd.device_id = up.device_id and month(qpd.date) = 8where up.university = &#39;复旦大学&#39;group by up.device_id</code></pre><h2 id="正则表达式40"><a href="#正则表达式40" class="headerlink" title="正则表达式40"></a>正则表达式40</h2><blockquote><p>关键字：regexp</p></blockquote><blockquote><ol><li>电话号码必须是 10 位数字。</li><li>电话号码的第一位不能以 0 开头。</li><li>电话号码的格式可以是连续的 10 位数字，或以-分隔的格式（如123-456-7890）。</li></ol></blockquote><pre><code class="language-sql">select *from contactswhere phone_number regexp &#39;^[1-9][0-9]&#123;9&#125;$|^[1-9][0-9]&#123;2&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&#39;order by id ASC</code></pre><blockquote><p>这个正则表达式的作用如下：</p><ul><li>^ 表示匹配字符串的开头，$ 表示匹配字符串的结尾，确保整个字符串都符合指定的模式。</li><li>[1-9] 表示电话号码的第一位不能是 0，必须是 1 到 9 之间的数字。</li><li>[0-9]{9} 表示接下来的 9 位可以是任意数字，与开头的 [1-9] 组合形成一个完整的 10 位数字电话号码。</li><li>| 是正则表达式的“或”操作符，用于分隔两种不同的匹配模式。</li><li>^[1-9]{2}-[0-9]{3}-[0-9]{4}$ 表示电话号码可以是以 “-” 分隔的格式，其中第一部分是 3 位数字，第二部分是 3 位数字，第三部分是 4 位数字。</li></ul></blockquote><h2 id="数学函数42"><a href="#数学函数42" class="headerlink" title="数学函数42"></a>数学函数42</h2><table><thead><tr><th align="left">返回类型</th><th align="left">描述</th><th align="left">例子</th><th align="left">结果</th><th></th></tr></thead><tbody><tr><td align="left"><strong>abs(x)</strong></td><td align="left"></td><td align="left"><strong>绝对值</strong></td><td align="left"><strong>abs(-17.4)</strong></td><td><strong>17.4</strong></td></tr><tr><td align="left">cbrt(double)</td><td align="left"></td><td align="left">立方根</td><td align="left">cbrt(27.0)</td><td>3</td></tr><tr><td align="left"><strong>ceil(double&#x2F;numeric)</strong></td><td align="left"></td><td align="left"><strong>向上取整</strong></td><td align="left"><strong>ceil(-42.8)</strong></td><td><strong>-42</strong></td></tr><tr><td align="left">degrees(double)</td><td align="left"></td><td align="left">把弧度转为角度</td><td align="left">degrees(0.5)</td><td>28.6478897565412</td></tr><tr><td align="left">exp(double&#x2F;numeric)</td><td align="left"></td><td align="left">自然指数</td><td align="left">exp(1.0)</td><td>2.71828182845905</td></tr><tr><td align="left"><strong>floor(double&#x2F;numeric)</strong></td><td align="left"></td><td align="left"><strong>向下取整</strong></td><td align="left"><strong>floor(-42.8)</strong></td><td><strong>-43</strong></td></tr><tr><td align="left">ln(double&#x2F;numeric)</td><td align="left"></td><td align="left">自然对数</td><td align="left">ln(2.0)</td><td>0.693147180559945</td></tr><tr><td align="left">log(double&#x2F;numeric)</td><td align="left"></td><td align="left">10为底的对数</td><td align="left">log(100.0)</td><td>2</td></tr><tr><td align="left">log(b numeric,x numeric)</td><td align="left">numeric</td><td align="left">指定底数的对数</td><td align="left">log(2.0, 64.0)</td><td>6.0000000000</td></tr><tr><td align="left"><strong>mod(y, x)</strong></td><td align="left"></td><td align="left"><strong>取余数</strong></td><td align="left"><strong>mod(9,4)</strong></td><td><strong>1</strong></td></tr><tr><td align="left">pi()</td><td align="left">double</td><td align="left">“π”常量</td><td align="left">pi()</td><td>3.14159265358979</td></tr><tr><td align="left"><strong>power(a double, b double)</strong></td><td align="left"><strong>double</strong></td><td align="left"><strong>求a的b次幂</strong></td><td align="left"><strong>power(9.0, 3.0)</strong></td><td><strong>729</strong></td></tr><tr><td align="left">power(a numeric, b numeric)</td><td align="left">numeric</td><td align="left">求a的b次幂</td><td align="left">power(9.0, 3.0)</td><td>729</td></tr><tr><td align="left">radians(double)</td><td align="left">double</td><td align="left">把角度转为弧度</td><td align="left">radians(45.0)</td><td>0.785398163397448</td></tr><tr><td align="left">random()</td><td align="left">double</td><td align="left">0.0到1.0之间的随机数值</td><td align="left">random()</td><td></td></tr><tr><td align="left">round(double&#x2F;numeric)</td><td align="left"></td><td align="left">圆整为最接近的整数</td><td align="left">round(42.4)</td><td>42</td></tr><tr><td align="left"><strong>round(v numeric, s int)</strong></td><td align="left"><strong>numeric</strong></td><td align="left"><strong>圆整为s位小数数字</strong></td><td align="left"><strong>round(42.438,2)</strong></td><td><strong>42.44</strong></td></tr><tr><td align="left">sign(double&#x2F;numeric)</td><td align="left"></td><td align="left">参数的符号(-1,0,+1)</td><td align="left">sign(-8.4)</td><td>-1</td></tr><tr><td align="left"><strong>sqrt(double&#x2F;numeric)</strong></td><td align="left"></td><td align="left"><strong>平方根</strong></td><td align="left"><strong>sqrt(2.0)</strong></td><td><strong>1.4142135623731</strong></td></tr><tr><td align="left">trunc(double&#x2F;numeric)</td><td align="left"></td><td align="left"><strong>截断</strong>(向零靠近)</td><td align="left">trunc(42.8)</td><td>42</td></tr><tr><td align="left">trunc(v numeric, s int)</td><td align="left">numeric</td><td align="left"><strong>截断</strong>为s小数位置的数字</td><td align="left">trunc(42.438,2)</td><td>42.43</td></tr></tbody></table><h2 id="Limit关键字"><a href="#Limit关键字" class="headerlink" title="Limit关键字"></a>Limit关键字</h2><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><blockquote><p>关键字：<code>LIMIT pageSize OFFSET (pageNumber - 1) * pageSize</code></p></blockquote><pre><code class="language-sql">SELECT * FROM CustomersLIMIT 10 OFFSET 20;</code></pre><blockquote><p>表示1：</p><ul><li>跳过前 20 行（OFFSET 20）</li><li>返回接下来的 10 行</li></ul><p>等价于取出第 21～30 行。</p></blockquote><blockquote><p>表示2：</p><ul><li>第 3页，每页 10 条数据</li></ul></blockquote><h3 id="取前-N-条最大-最小的值"><a href="#取前-N-条最大-最小的值" class="headerlink" title="取前 N 条最大&#x2F;最小的值"></a>取前 N 条最大&#x2F;最小的值</h3><blockquote><p>关键字：<code>LIMIT + ORDER BY</code></p></blockquote><pre><code class="language-sql">-- 取销量最高的 3 个商品SELECT product_name, salesFROM ProductsORDER BY sales DESCLIMIT 3;</code></pre><h2 id="技巧注意"><a href="#技巧注意" class="headerlink" title="技巧注意"></a>技巧注意</h2><ol><li><p><strong>是或不是</strong>的时候才能用**“is”<strong>，别的时候有</strong>关联关系<strong>还是</strong>用等号和大于小于**才行</p></li><li><p><code>select</code>关键字后面字段之间使用<code>,</code>间隔，但是最后一个字段后面不能加<code>,</code></p></li><li><p>如果<code>from</code>字段后面<strong>有多个表</strong>，那么在where语句中就必须写出这<strong>多表之间的联系</strong>。</p></li><li><p>如果是多表连接，最后的查询结果必须指明是那个表里面的字段（如果这两个表都有该字段）。</p></li><li><p>在使用多个<code>INNER JOIN</code>关键字内连接其他表时，第一个表的字段与第二个表的字段连接，第二个表的字段与第三个表的字段连接。</p><pre><code class="language-sql">select  user_profile.university,question_detail.difficult_level,ROUND(COUNT(question_practice_detail.question_id) / COUNT(DISTINCT user_profile.device_id), 4) AS avg_answer_cntFROM user_profileINNER JOIN question_practice_detailon user_profile.device_id = question_practice_detail.device_idINNER JOIN question_detailon question_practice_detail.question_id = question_detail.question_idgroup by university,difficult_level</code></pre></li><li><p>多表连接中select，group by  ,  order by 子句中的字段最好加上表名</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 政务数据_实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
