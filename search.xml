<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringAop切面类</title>
      <link href="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/"/>
      <url>/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Aop——-这是基于路径匹配的AOP—切点是方法名"><a href="#什么是Aop——-这是基于路径匹配的AOP—切点是方法名" class="headerlink" title="什么是Aop——-这是基于路径匹配的AOP—切点是方法名"></a>什么是Aop——-这是基于路径匹配的AOP—切点是方法名</h1><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091010268.png" class="" alt="image-20250703091256278"><p><em><strong>方法中存在相同的业务需求的代码，可以通过AOP动态植入这部分的代码。</strong></em></p><h1 id="AOP的应用场景"><a href="#AOP的应用场景" class="headerlink" title="AOP的应用场景"></a>AOP的应用场景</h1><p>D<img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091505678.png" class="" alt="image-20250703091505678"></p><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091623178.png" class="" alt="image-20250703091623178"><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703091704225.png" class="" alt="image-20250703091704225"><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100011716.png" class="" alt="image-20250703100011716"><h1 id="AOP中的主要概念"><a href="#AOP中的主要概念" class="headerlink" title="AOP中的主要概念"></a>AOP中的主要概念</h1><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100409875.png" class="" alt="image-20250703100409875"><h2 id="Aspect中通知的种类"><a href="#Aspect中通知的种类" class="headerlink" title="Aspect中通知的种类"></a>Aspect中通知的种类</h2><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100559967.png" class="" alt="image-20250703100559967"><h1 id="如何写切面类"><a href="#如何写切面类" class="headerlink" title="如何写切面类"></a>如何写切面类</h1><p>切面：切入方法的集合类</p><p>切点：规定执行方法的执行条件</p><p>通知：当执行时是如何执行的</p><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703100804430.png" class="" alt="image-20250703100804430"><h2 id="实现步骤代码示例"><a href="#实现步骤代码示例" class="headerlink" title="实现步骤代码示例"></a>实现步骤代码示例</h2><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703101235652.png" class="" alt="image-20250703101235652"><p>依赖：</p><pre><code class="language-java">&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;      &lt;version&gt;3.2.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;6.2.6&lt;/version&gt;    &lt;/dependency&gt;</code></pre><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703101333049.png" class="" alt="image-20250703101333049"><p>controller.* : 指controller包下所有的类</p><p>controller.* .*(): 指controller包下所有的类的所有方法</p><img src="/2025/07/16/SpringAop%E5%88%87%E9%9D%A2%E7%B1%BB/image-20250703102835162.png" class="" alt="image-20250703102835162"><p>pjp.getSignature().getname()：获取方法名</p><p>pjp.getTarfet().getClass().toString()：获取类名</p><p>pjp.geArgs(): 获取参数名</p><p>pjp.proceed() ： 执行方法</p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>测试方法：</p><pre><code class="language-java">package org.example.Controller;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.*;@Slf4j@RestController@RequestMapping(&quot;/Aop&quot;)public class CalculatorController &#123;    // http://localhost:8080/Aop/add?a=5&amp;b=3    @GetMapping(&quot;/add&quot;)    public String add(@RequestParam double a, @RequestParam double b) &#123;        log.info(&quot;这是加法&quot;);        return &quot;结果：&quot; + (a + b);    &#125;    // http://localhost:8080/Aop/sub?a=5&amp;b=3    @GetMapping(&quot;/sub&quot;)    public String subtract(@RequestParam double a, @RequestParam double b) &#123;        return &quot;结果：&quot; + (a - b);    &#125;    // http://localhost:8080/Aop/mul?a=5&amp;b=3    @GetMapping(&quot;/mul&quot;)    public String multiply(@RequestParam double a, @RequestParam double b) &#123;        return &quot;结果：&quot; + (a * b);    &#125;    // http://localhost:8080/Aop/div?a=6&amp;b=3    @GetMapping(&quot;/div&quot;)    public String divide(@RequestParam double a, @RequestParam double b) &#123;        if (b == 0) &#123;            return &quot;错误：除数不能为 0&quot;;        &#125;        return &quot;结果：&quot; + (a / b);    &#125;</code></pre><p>切面类：</p><pre><code class="language-java">package org.example.Config;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;/*日志界面管理1.定义切面类-@Aspect (注：也要加载到容器中--@Component)2.定义切点-@Pointcut(value = &quot;execution(* org.example.Controller.*.*())&quot;)3.定义Advice通知优先级排列：    @Around：环绕通知    @Before：前置通知----调用方法    @AfterReturning：最终通知--在方法调用之后执行    @After：后置通知    @AfterThrowing：异常通知---只有出现异常才会执行 */@Aspect@Component@Slf4jpublic class LoggerAdvice &#123;    //2.定义切点-@Pointcut    /*    切点名称：controllerMethodsPointcut    作用区域：在返回类型不限的org.example.Controller包下的所有类的所有的有参方法     */    @Pointcut(value = &quot;execution(* org.example.Controller.*.*(..))&quot;)    public void controllerMethodsPointcut() &#123;    &#125;    //3.定义Advice通知        //环绕通知--作用于方法的全程    /*    @Around：环绕通知，只能使用ProceedingJoinPoint，其余通知使用JoinPoint    joinPoint.proceed():固定语句--表示执行该方法    className:获取类名    methodName：获取方法名    args:获取请求参数     */    @Around(&quot;controllerMethodsPointcut()&quot;)    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;        String className = joinPoint.getTarget().getClass().getName();        String methodName = joinPoint.getSignature().getName();        Object[] args = joinPoint.getArgs();        log.info(&quot;调用类名&#123;&#125;.方法名&#123;&#125;&quot;,className,methodName);        log.info(&quot;请求参数：&#123;&#125;&quot;, Arrays.toString(args));        Object result = joinPoint.proceed();        log.info(&quot;方法完成调用类名&#123;&#125;.方法名&#123;&#125;&quot;, className, methodName);        log.info(&quot;返回结果：&#123;&#125;&quot;, result);        return result;    &#125;    /*        * 前置通知--在方法调用之前执行        * @Before(&quot;controllerMethodsPointcut()&quot;)     */    @Before(&quot;controllerMethodsPointcut()&quot;)    public void beforeAdvice() &#123;        log.info(&quot;方法调用之前执行---------------------------------&quot;);    &#125;    /*        * 后置通知--在方法调用之后执行        * @After(&quot;controllerMethodsPointcut()&quot;)     */    @After(&quot;controllerMethodsPointcut()&quot;)    public void afterAdvice() &#123;        log.info(&quot;方法调用之后执行---------------------------------&quot;);    &#125;    /*        * 异常通知--在方法调用出现异常时执行        * @AfterThrowing(value = &quot;controllerMethodsPointcut()&quot;, throwing = &quot;ex&quot;)     */    @AfterThrowing(value = &quot;controllerMethodsPointcut()&quot;, throwing = &quot;ex&quot;)    public void afterThrowingAdvice(Exception ex) &#123;        log.error(&quot;方法调用出现异常：&#123;&#125;&quot;, ex.getMessage());    &#125;    /*        * 最终通知--在方法调用之后执行，无论是否出现异常        * @AfterReturning(value = &quot;controllerMethodsPointcut()&quot;, returning = &quot;result&quot;)     */    @AfterReturning(value = &quot;controllerMethodsPointcut()&quot;, returning = &quot;result&quot;)    public void afterReturningAdvice(Object result) &#123;        log.info(&quot;方法调用完成，返回结果：&#123;&#125;&quot;, result);    &#125;&#125;</code></pre><h1 id="基于注解的AOP–切点是注解（自定义）"><a href="#基于注解的AOP–切点是注解（自定义）" class="headerlink" title="基于注解的AOP–切点是注解（自定义）"></a>基于注解的AOP–切点是注解（自定义）</h1><blockquote><p>触发AOP可以是类名、方法名、参数、返回值类型，也可以是注解</p></blockquote><p><strong>1）：自定义注解</strong></p><p>进入到sky-server模块，创建com.sky.annotation包。</p><pre><code class="language-java">package com.sky.annotation;import com.sky.enumeration.OperationType;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AutoFill &#123;    //数据库操作类型：UPDATE INSERT    OperationType value();&#125;</code></pre><blockquote><p>解释如下：</p></blockquote><p><strong>1.<code>@Target(ElementType.METHOD)</code> —— 约束适用范围</strong></p><p><code>@Target</code> 是 <strong>元注解</strong>（用来修饰注解的注解），用来指定 <strong>AutoFill</strong> 只能放在什么元素上。</p><ul><li><code>ElementType.METHOD</code>：说明 <strong><em>只能</em> 用在方法</strong>声明上；不能放在类、字段、参数等位置。</li><li>常见的取值还包括 <code>TYPE</code>（类&#x2F;接口）、<code>FIELD</code>（字段）、<code>PARAMETER</code>（形参）……可以同时指定多个，例如 <code>&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;</code>。</li></ul><p><strong>2.<code>@Retention(RetentionPolicy.RUNTIME)</code> —— 生命周期</strong></p><p>另一枚元注解，决定编译后字节码里保留多久。</p><ul><li><code>SOURCE</code>：只存在于源码阶段，编译后即消失（如 Lombok 的大多数注解）。</li><li><code>CLASS</code>：编译后仍在 <code>.class</code> 文件中，但 <strong>运行时</strong> 通过反射拿不到（默认值）。</li><li><code>RUNTIME</code>：不仅编译期保留，而且 JVM 运行时依旧保留，可用反射读取——<strong>AOP、拦截器、框架自动装配</strong> 等场景全靠它。</li></ul><p>所以，这里选 <code>RUNTIME</code> 是为了在 <strong>拦截数据库操作的方法时</strong> 能获取注解信息，动态填充字段。</p><p><strong>3. <code>OperationType value();</code> —— 注解的属性</strong></p><ul><li>注解内部声明的方法就是<strong>属性</strong>（也叫“成员变量”）。</li><li>返回值可以是 <em>原始类型、String、Class、枚举、注解、以及它们的一维数组</em>。</li><li>如果属性名是 <code>value</code>，使用时可以省略 <code>value =</code>，见下方示例。</li></ul><p><strong>2）：OperationType</strong></p><p>在sky-common模块中定义</p><pre><code class="language-java">package com.sky.enumeration;/** * 数据库操作类型 */public enum OperationType &#123;    /**     * 更新操作     */    UPDATE,    /**     * 插入操作     */    INSERT&#125;</code></pre><p><strong>3）：自定义切面AutoFillAspect</strong></p><p>在sky-server模块，创建com.sky.aspect包。</p><pre><code class="language-java">package com.sky.aspect;import com.sky.annotation.AutoFill;import com.sky.constant.AutoFillConstant;import com.sky.context.BaseContext;import com.sky.enumeration.OperationType;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;import java.time.LocalDateTime;/** * 自定义切面，实现公共字段自动填充处理逻辑 */@Aspect@Component@Slf4jpublic class AutoFillAspect &#123;    /**     * 切入点     */    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)    public void autoFillPointCut()&#123;&#125;    /**     * 前置通知，在通知中进行公共字段的赋值     */    @Before(&quot;autoFillPointCut()&quot;)    public void autoFill(JoinPoint joinPoint)&#123;        log.info(&quot;开始进行公共字段自动填充...&quot;);        //获取到当前被拦截的方法上的数据库操作类型        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象        OperationType operationType = autoFill.value();//获得数据库操作类型        //获取到当前被拦截的方法的参数--实体对象        Object[] args = joinPoint.getArgs();        if(args == null || args.length == 0)&#123;            return;        &#125;        Object entity = args[0];        //准备赋值的数据        LocalDateTime now = LocalDateTime.now();        Long currentId = BaseContext.getCurrentId();        //根据当前不同的操作类型，为对应的属性通过反射来赋值        if(operationType == OperationType.INSERT)&#123;            //为4个公共字段赋值            try &#123;                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setCreateTime.invoke(entity,now);                setCreateUser.invoke(entity,currentId);                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;else if(operationType == OperationType.UPDATE)&#123;            //为2个公共字段赋值            try &#123;                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>4）：对方法加上AutoFill注解</strong></p><p>Mapper接口的方法上添加，来代替公共字段</p><pre><code class="language-java"> /**     * 插入数据     * @param category     */    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +            &quot; VALUES&quot; +            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)    @AutoFill(value = OperationType.INSERT)    void insert(Category category);    /**     * 根据id修改分类     * @param category     */    @AutoFill(value = OperationType.UPDATE)    void update(Category category);</code></pre><p>这样在Service实现层上就可以省略公共字段的填充。</p><p>例如：</p><pre><code class="language-java">   /**     * 新增分类     * @param categoryDTO     */    public void save(CategoryDTO categoryDTO) &#123;        Category category = new Category();        //属性拷贝        BeanUtils.copyProperties(categoryDTO, category);        //分类状态默认为禁用状态0        category.setStatus(StatusConstant.DISABLE);        //在mapper层添加了注解   @AutoFill(value = OperationType.INSERT)，来自挂填充公共字段//        //设置创建时间、修改时间、创建人、修改人//        category.setCreateTime(LocalDateTime.now());//        category.setUpdateTime(LocalDateTime.now());//        category.setCreateUser(BaseContext.getCurrentId());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.insert(category);    &#125;/**     * 修改分类     * @param categoryDTO     */    public void update(CategoryDTO categoryDTO) &#123;        Category category = new Category();        BeanUtils.copyProperties(categoryDTO,category);        //在mapper层添加了注解   @AutoFill(value = OperationType.update)，来自挂填充公共字段//        //设置修改时间、修改人//        category.setUpdateTime(LocalDateTime.now());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.update(category);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（三）公共字段填充、菜品CRUD</title>
      <link href="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/"/>
      <url>/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/</url>
      
        <content type="html"><![CDATA[<h1 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在<strong>新增员工</strong>或者<strong>新增菜品分类</strong>时需要设置创建时间、创建人、修改时间、修改人等字段，在<strong>编辑员工</strong>或者<strong>编辑菜品分类</strong>时需要设置修改时间、修改人等字段。这些字段属于公共字段，也就是也就是在我们的系统中很多表中都会有这些字段，如下：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>字段名</strong></th><th><strong>含义</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>1</td><td>create_time</td><td>创建时间</td><td>datetime</td></tr><tr><td>2</td><td>create_user</td><td>创建人id</td><td>bigint</td></tr><tr><td>3</td><td>update_time</td><td>修改时间</td><td>datetime</td></tr><tr><td>4</td><td>update_user</td><td>修改人id</td><td>bigint</td></tr></tbody></table><p>而针对于这些字段，我们的赋值方式为： </p><p>1). 在新增数据时, 将createTime、updateTime 设置为当前时间, createUser、updateUser设置为当前登录用户ID。</p><p>2). 在更新数据时, 将updateTime 设置为当前时间, updateUser设置为当前登录用户ID。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>我们使用AOP切面编程，实现功能增强，来完成公共字段自动填充功能。</strong></p><p><strong>实现步骤：</strong></p><p>1). 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法</p><p>2). 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</p><p>3). 在 Mapper 的方法上加入 AutoFill 注解</p><h2 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h2><p><strong>1）：自定义注解</strong></p><p>进入到sky-server模块，创建com.sky.annotation包。</p><pre><code class="language-java">package com.sky.annotation;import com.sky.enumeration.OperationType;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AutoFill &#123;    //数据库操作类型：UPDATE INSERT    OperationType value();&#125;</code></pre><blockquote><p>解释如下：</p></blockquote><p><strong>1.<code>@Target(ElementType.METHOD)</code> —— 约束适用范围</strong></p><p><code>@Target</code> 是 <strong>元注解</strong>（用来修饰注解的注解），用来指定 <strong>AutoFill</strong> 只能放在什么元素上。</p><ul><li><code>ElementType.METHOD</code>：说明 <strong><em>只能</em> 用在方法</strong>声明上；不能放在类、字段、参数等位置。</li><li>常见的取值还包括 <code>TYPE</code>（类&#x2F;接口）、<code>FIELD</code>（字段）、<code>PARAMETER</code>（形参）……可以同时指定多个，例如 <code>&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;</code>。</li></ul><p><strong>2.<code>@Retention(RetentionPolicy.RUNTIME)</code> —— 生命周期</strong></p><p>另一枚元注解，决定编译后字节码里保留多久。</p><ul><li><code>SOURCE</code>：只存在于源码阶段，编译后即消失（如 Lombok 的大多数注解）。</li><li><code>CLASS</code>：编译后仍在 <code>.class</code> 文件中，但 <strong>运行时</strong> 通过反射拿不到（默认值）。</li><li><code>RUNTIME</code>：不仅编译期保留，而且 JVM 运行时依旧保留，可用反射读取——<strong>AOP、拦截器、框架自动装配</strong> 等场景全靠它。</li></ul><p>所以，这里选 <code>RUNTIME</code> 是为了在 <strong>拦截数据库操作的方法时</strong> 能获取注解信息，动态填充字段。</p><p><strong>3. <code>OperationType value();</code> —— 注解的属性</strong></p><ul><li>注解内部声明的方法就是<strong>属性</strong>（也叫“成员变量”）。</li><li>返回值可以是 <em>原始类型、String、Class、枚举、注解、以及它们的一维数组</em>。</li><li>如果属性名是 <code>value</code>，使用时可以省略 <code>value =</code>，见下方示例。</li></ul><p><strong>2）：OperationType</strong></p><p>在sky-common模块中定义</p><pre><code class="language-java">package com.sky.enumeration;/** * 数据库操作类型 */public enum OperationType &#123;    /**     * 更新操作     */    UPDATE,    /**     * 插入操作     */    INSERT&#125;</code></pre><p><strong>3）：自定义切面AutoFillAspect</strong></p><p>在sky-server模块，创建com.sky.aspect包。</p><pre><code class="language-java">package com.sky.aspect;import com.sky.annotation.AutoFill;import com.sky.constant.AutoFillConstant;import com.sky.context.BaseContext;import com.sky.enumeration.OperationType;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;import java.time.LocalDateTime;/** * 自定义切面，实现公共字段自动填充处理逻辑 */@Aspect@Component@Slf4jpublic class AutoFillAspect &#123;    /**     * 切入点     */    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)    public void autoFillPointCut()&#123;&#125;    /**     * 前置通知，在通知中进行公共字段的赋值     */    @Before(&quot;autoFillPointCut()&quot;)    public void autoFill(JoinPoint joinPoint)&#123;        log.info(&quot;开始进行公共字段自动填充...&quot;);        //获取到当前被拦截的方法上的数据库操作类型        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获得方法上的注解对象        OperationType operationType = autoFill.value();//获得数据库操作类型        //获取到当前被拦截的方法的参数--实体对象        Object[] args = joinPoint.getArgs();        if(args == null || args.length == 0)&#123;            return;        &#125;        Object entity = args[0];        //准备赋值的数据        LocalDateTime now = LocalDateTime.now();        Long currentId = BaseContext.getCurrentId();        //根据当前不同的操作类型，为对应的属性通过反射来赋值        if(operationType == OperationType.INSERT)&#123;            //为4个公共字段赋值            try &#123;                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setCreateTime.invoke(entity,now);                setCreateUser.invoke(entity,currentId);                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;else if(operationType == OperationType.UPDATE)&#123;            //为2个公共字段赋值            try &#123;                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);                //通过反射为对象属性赋值                setUpdateTime.invoke(entity,now);                setUpdateUser.invoke(entity,currentId);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>4）：对方法加上AutoFill注解</strong></p><p>Mapper接口的方法上添加，来代替公共字段</p><pre><code class="language-java"> /**     * 插入数据     * @param category     */    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +            &quot; VALUES&quot; +            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)    @AutoFill(value = OperationType.INSERT)    void insert(Category category);    /**     * 根据id修改分类     * @param category     */    @AutoFill(value = OperationType.UPDATE)    void update(Category category);</code></pre><p>这样在Service实现层上就可以省略公共字段的填充。</p><p>例如：</p><pre><code class="language-java">   /**     * 新增分类     * @param categoryDTO     */    public void save(CategoryDTO categoryDTO) &#123;        Category category = new Category();        //属性拷贝        BeanUtils.copyProperties(categoryDTO, category);        //分类状态默认为禁用状态0        category.setStatus(StatusConstant.DISABLE);        //在mapper层添加了注解   @AutoFill(value = OperationType.INSERT)，来自挂填充公共字段//        //设置创建时间、修改时间、创建人、修改人//        category.setCreateTime(LocalDateTime.now());//        category.setUpdateTime(LocalDateTime.now());//        category.setCreateUser(BaseContext.getCurrentId());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.insert(category);    &#125;/**     * 修改分类     * @param categoryDTO     */    public void update(CategoryDTO categoryDTO) &#123;        Category category = new Category();        BeanUtils.copyProperties(categoryDTO,category);        //在mapper层添加了注解   @AutoFill(value = OperationType.update)，来自挂填充公共字段//        //设置修改时间、修改人//        category.setUpdateTime(LocalDateTime.now());//        category.setUpdateUser(BaseContext.getCurrentId());        categoryMapper.update(category);    &#125;</code></pre><h2 id="前后端联调测试"><a href="#前后端联调测试" class="headerlink" title="前后端联调测试"></a>前后端联调测试</h2><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716152014926.png" class="" alt="image-20250716152014926"><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716152150264.png" class="" alt="image-20250716152150264"><h1 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h1><h2 id="需求分析与设计"><a href="#需求分析与设计" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型"></a>产品原型</h3><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716152348497.png" class="" alt="image-20250716152348497"><p><strong>业务规则：</strong></p><ul><li>菜品名称必须是唯一的</li><li>菜品必须属于某个分类下，不能单独存在</li><li>新增菜品时可以根据情况选择菜品的口味</li><li>每个菜品必须对应一张图片</li></ul><p>接口设计</p><p><strong>接口设计：</strong></p><ul><li>根据类型查询分类（已完成）</li><li>文件上传</li><li>新增菜品</li></ul><p><strong>1. 根据类型查询分类</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154458323.png" class="" alt="image-20250716154458323"><p><strong>2. 文件上传</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154511145.png" class="" alt="image-20250716154511145"><p><strong>3. 新增菜品</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154523491.png" class="" alt="image-20250716154523491"><p>表设计</p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716154545162.png" class="" alt="image-20250716154545162"><p>通过原型图进行分析：</p><p>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据。所以在新增菜品时，涉及到两个表：</p><table><thead><tr><th>表名</th><th>说明</th></tr></thead><tbody><tr><td>dish</td><td>菜品表</td></tr><tr><td>dish_flavor</td><td>菜品口味表</td></tr></tbody></table><p><strong>1). 菜品表:dish</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>name</td><td>varchar(32)</td><td>菜品名称</td><td>唯一</td></tr><tr><td>category_id</td><td>bigint</td><td>分类id</td><td>逻辑外键</td></tr><tr><td>price</td><td>decimal(10,2)</td><td>菜品价格</td><td></td></tr><tr><td>image</td><td>varchar(255)</td><td>图片路径</td><td></td></tr><tr><td>description</td><td>varchar(255)</td><td>菜品描述</td><td></td></tr><tr><td>status</td><td>int</td><td>售卖状态</td><td>1起售 0停售</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>update_time</td><td>datetime</td><td>最后修改时间</td><td></td></tr><tr><td>create_user</td><td>bigint</td><td>创建人id</td><td></td></tr><tr><td>update_user</td><td>bigint</td><td>最后修改人id</td><td></td></tr></tbody></table><p><strong>2). 菜品口味表:dish_flavor</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>dish_id</td><td>bigint</td><td>菜品id</td><td>逻辑外键</td></tr><tr><td>name</td><td>varchar(32)</td><td>口味名称</td><td></td></tr><tr><td>value</td><td>varchar(255)</td><td>口味值</td><td></td></tr></tbody></table><h2 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>因为在新增菜品时，需要上传菜品对应的图片(文件)，包括后绪其它功能也会使用到文件上传，故要实现通用的文件上传接口。</p><p>文件上传，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发抖音、发朋友圈都用到了文件上传功能。</p><p>实现文件上传服务，需要有存储的支持，那么我们的解决方案将以下几种：</p><ol><li>直接将图片保存到服务的硬盘（springmvc中的文件上传）<ol><li>优点：开发便捷，成本低</li><li>缺点：扩容困难</li></ol></li><li>使用分布式文件系统进行存储<ol><li>优点：容易实现扩容</li><li>缺点：开发复杂度稍大（有成熟的产品可以使用，比如：FastDFS,MinIO）</li></ol></li><li>使用第三方的存储服务（例如OSS）<ol><li>优点：开发简单，拥有强大功能，免维护</li><li>缺点：付费</li></ol></li></ol><p>在本项目选用阿里云的OSS服务进行文件存储。</p><p><strong>实现步骤：</strong></p><p><strong>1). 定义OSS相关配置</strong></p><p>在sky-server模块</p><p>application-dev.yml</p><pre><code class="language-yaml">sky: #阿里云OSS配置  alioss:    endpoint: 填自己的，github保护    accessKeyId: 填自己的，github保护    accessKeySecret: 填自己的，github保护    bucketName: 填自己的，github保护</code></pre><p>application.yml</p><pre><code class="language-yaml">spring:  profiles:    active: dev    #设置环境sky:   alioss:    endpoint: $&#123;sky.alioss.endpoint&#125;    access-key-id: $&#123;sky.alioss.access-key-id&#125;    access-key-secret: $&#123;sky.alioss.access-key-secret&#125;    bucket-name: $&#123;sky.alioss.bucket-name&#125;</code></pre><p><strong>2). 读取OSS配置</strong></p><p>在sky-common模块中，已定义</p><pre><code class="language-java">package com.sky.properties;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;sky.alioss&quot;)@Datapublic class AliOssProperties &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;&#125;</code></pre><p><strong>3). 生成OSS工具类对象</strong></p><p>在sky-server模块</p><pre><code class="language-java">package com.sky.config;import com.sky.properties.AliOssProperties;import com.sky.utils.AliOssUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 配置类，用于创建AliOssUtil对象 */@Configuration@Slf4jpublic class OssConfiguration &#123;    @Bean    @ConditionalOnMissingBean    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties)&#123;        log.info(&quot;开始创建阿里云文件上传工具类对象：&#123;&#125;&quot;,aliOssProperties);        return new AliOssUtil(aliOssProperties.getEndpoint(),                aliOssProperties.getAccessKeyId(),                aliOssProperties.getAccessKeySecret(),                aliOssProperties.getBucketName());    &#125;&#125;</code></pre><p>其中，AliOssUtil.java已在sky-common模块中定义</p><pre><code class="language-java">package com.sky.utils;import com.aliyun.oss.ClientException;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.aliyun.oss.OSSException;import lombok.AllArgsConstructor;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.io.ByteArrayInputStream;@Data@AllArgsConstructor@Slf4jpublic class AliOssUtil &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;    /**     * 文件上传     *     * @param bytes     * @param objectName     * @return     */    public String upload(byte[] bytes, String objectName) &#123;        // 创建OSSClient实例。        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);        try &#123;            // 创建PutObject请求。            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));        &#125; catch (OSSException oe) &#123;            System.out.println(&quot;Caught an OSSException, which means your request made it to OSS, &quot;                    + &quot;but was rejected with an error response for some reason.&quot;);            System.out.println(&quot;Error Message:&quot; + oe.getErrorMessage());            System.out.println(&quot;Error Code:&quot; + oe.getErrorCode());            System.out.println(&quot;Request ID:&quot; + oe.getRequestId());            System.out.println(&quot;Host ID:&quot; + oe.getHostId());        &#125; catch (ClientException ce) &#123;            System.out.println(&quot;Caught an ClientException, which means the client encountered &quot;                    + &quot;a serious internal problem while trying to communicate with OSS, &quot;                    + &quot;such as not being able to access the network.&quot;);            System.out.println(&quot;Error Message:&quot; + ce.getMessage());        &#125; finally &#123;            if (ossClient != null) &#123;                ossClient.shutdown();            &#125;        &#125;        //文件访问路径规则 https://BucketName.Endpoint/ObjectName        StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;);        stringBuilder                .append(bucketName)                .append(&quot;.&quot;)                .append(endpoint)                .append(&quot;/&quot;)                .append(objectName);        log.info(&quot;文件上传到:&#123;&#125;&quot;, stringBuilder.toString());        return stringBuilder.toString();    &#125;&#125;</code></pre><p><strong>4). 定义文件上传接口</strong></p><p>在sky-server模块中定义接口</p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.constant.MessageConstant;import com.sky.result.Result;import com.sky.utils.AliOssUtil;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.util.UUID;/** * 通用接口 */@RestController@RequestMapping(&quot;/admin/common&quot;)@Api(tags = &quot;通用接口&quot;)@Slf4jpublic class CommonController &#123;    @Autowired    private AliOssUtil aliOssUtil;    /**     * 文件上传     * @param file     * @return     */    @PostMapping(&quot;/upload&quot;)    @ApiOperation(&quot;文件上传&quot;)    public Result&lt;String&gt; upload(MultipartFile file)&#123;        log.info(&quot;文件上传：&#123;&#125;&quot;,file);        try &#123;            //原始文件名            String originalFilename = file.getOriginalFilename();            //截取原始文件名的后缀   dfdfdf.png            String extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));            //构造新文件名称            String objectName = UUID.randomUUID().toString() + extension;            //文件的请求路径            String filePath = aliOssUtil.upload(file.getBytes(), objectName);            return Result.success(filePath);        &#125; catch (IOException e) &#123;            log.error(&quot;文件上传失败：&#123;&#125;&quot;, e);        &#125;        return Result.error(MessageConstant.UPLOAD_FAILED);    &#125;&#125;</code></pre><h3 id="新增菜品实现"><a href="#新增菜品实现" class="headerlink" title="新增菜品实现"></a>新增菜品实现</h3><p><strong>1). 设计DTO类</strong></p><p>在sky-pojo模块中</p><pre><code class="language-java">package com.sky.dto;import com.sky.entity.DishFlavor;import lombok.Data;import java.io.Serializable;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;@Datapublic class DishDTO implements Serializable &#123;    private Long id;    //菜品名称    private String name;    //菜品分类id    private Long categoryId;    //菜品价格    private BigDecimal price;    //图片    private String image;    //描述信息    private String description;    //0 停售 1 起售    private Integer status;    //口味    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();&#125;</code></pre><p><strong>2). Controller层</strong></p><p>进入到sky-server模块</p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.dto.DishDTO;import com.sky.dto.DishPageQueryDTO;import com.sky.entity.Dish;import com.sky.result.PageResult;import com.sky.result.Result;import com.sky.service.DishService;import com.sky.vo.DishVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;import java.util.Set;/** * 菜品管理 */@RestController@RequestMapping(&quot;/admin/dish&quot;)@Api(tags = &quot;菜品相关接口&quot;)@Slf4jpublic class DishController &#123;    @Autowired    private DishService dishService;    /**     * 新增菜品     *     * @param dishDTO     * @return     */    @PostMapping    @ApiOperation(&quot;新增菜品&quot;)    public Result save(@RequestBody DishDTO dishDTO) &#123;        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);        dishService.saveWithFlavor(dishDTO);//后绪步骤开发        return Result.success();    &#125;&#125;</code></pre><p><strong>3). Service层接口</strong></p><pre><code class="language-java">package com.sky.service;import com.sky.dto.DishDTO;import com.sky.entity.Dish;public interface DishService &#123;    /**     * 新增菜品和对应的口味     *     * @param dishDTO     */    public void saveWithFlavor(DishDTO dishDTO);&#125;</code></pre><p><strong>4). Service层实现类</strong></p><pre><code class="language-java">package com.sky.service.impl;@Service@Slf4jpublic class DishServiceImpl implements DishService &#123;    @Autowired    private DishMapper dishMapper;    @Autowired    private DishFlavorMapper dishFlavorMapper;    /**     * 新增菜品和对应的口味     *     * @param dishDTO     */    @Transactional    public void saveWithFlavor(DishDTO dishDTO) &#123;        Dish dish = new Dish();        BeanUtils.copyProperties(dishDTO, dish);        //向菜品表插入1条数据        dishMapper.insert(dish);//后绪步骤实现        //获取insert语句生成的主键值        Long dishId = dish.getId();        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;            flavors.forEach(dishFlavor -&gt; &#123;                dishFlavor.setDishId(dishId);            &#125;);            //向口味表插入n条数据            dishFlavorMapper.insertBatch(flavors);//后绪步骤实现        &#125;    &#125;&#125;</code></pre><p><strong>5). Mapper层</strong></p><p>DishMapper.java中添加</p><pre><code class="language-java">/**     * 插入菜品数据     *     * @param dish     */    @AutoFill(value = OperationType.INSERT)    void insert(Dish dish);</code></pre><p>在&#x2F;resources&#x2F;mapper中创建DishMapper.xml</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,update_user, status)        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;, #&#123;status&#125;)    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>DishFlavorMapper.java</p><pre><code class="language-java">package com.sky.mapper;import com.sky.entity.DishFlavor;import java.util.List;@Mapperpublic interface DishFlavorMapper &#123;    /**     * 批量插入口味数据     * @param flavors     */    void insertBatch(List&lt;DishFlavor&gt; flavors);&#125;</code></pre><p>在&#x2F;resources&#x2F;mapper中创建DishFlavorMapper.xml</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.DishFlavorMapper&quot;&gt;    &lt;insert id=&quot;insertBatch&quot;&gt;        insert into dish_flavor (dish_id, name, value) VALUES        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)        &lt;/foreach&gt;    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716164928367.png" class="" alt="image-20250716164928367"><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716170757070.png" class="" alt="image-20250716170757070"><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716170810326.png" class="" alt="image-20250716170810326"><h1 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h1><h2 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><h3 id="产品原型-1"><a href="#产品原型-1" class="headerlink" title="产品原型"></a>产品原型</h3><p><strong>菜品分页原型：</strong></p><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716162007515.png" class="" alt="image-20250716162007515"> <p>在菜品列表展示时，除了菜品的基本信息(名称、售价、售卖状态、最后操作时间)外，还有两个字段略微特殊，第一个是图片字段 ，我们从数据库查询出来的仅仅是图片的名字，图片要想在表格中回显展示出来，就需要下载这个图片。第二个是菜品分类，这里展示的是分类名称，而不是分类ID，此时我们就需要根据菜品的分类ID，去分类表中查询分类信息，然后在页面展示。</p><p><strong>业务规则：</strong></p><ul><li>根据页码展示菜品信息</li><li>每页展示10条数据</li><li>分页查询时可以根据需要输入菜品名称、菜品分类、菜品状态进行查询</li></ul><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>根据上述原型图，设计出相应的接口。</p><p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221121202019258.png" alt="image-20221121202019258" style="zoom:50%;" /> <img src="D:/A_MyselfData/cqwm/讲义/讲义/day03/assets/image-20221121202033284.png" alt="image-20221121202033284" style="zoom:50%;" /></p><h2 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="设计DTO类"><a href="#设计DTO类" class="headerlink" title="设计DTO类"></a>设计DTO类</h3><p><strong>根据菜品分页查询接口定义设计对应的DTO：</strong></p><p>在sky-pojo模块中，已定义</p><pre><code class="language-java">package com.sky.dto;import lombok.Data;import java.io.Serializable;@Datapublic class DishPageQueryDTO implements Serializable &#123;    private int page;    private int pageSize;    private String name;    private Integer categoryId; //分类id    private Integer status; //状态 0表示禁用 1表示启用&#125;</code></pre><h3 id="设计VO类"><a href="#设计VO类" class="headerlink" title="设计VO类"></a>设计VO类</h3><p><strong>根据菜品分页查询接口定义设计对应的VO：</strong></p><p>在sky-pojo模块中，已定义</p><pre><code class="language-java">package com.sky.vo;import com.sky.entity.DishFlavor;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.math.BigDecimal;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class DishVO implements Serializable &#123;    private Long id;    //菜品名称    private String name;    //菜品分类id    private Long categoryId;    //菜品价格    private BigDecimal price;    //图片    private String image;    //描述信息    private String description;    //0 停售 1 起售    private Integer status;    //更新时间    private LocalDateTime updateTime;    //分类名称    private String categoryName;    //菜品关联的口味    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();&#125;</code></pre><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p><strong>根据接口定义创建DishController的page分页查询方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    @GetMapping(&quot;/page&quot;)    @ApiOperation(&quot;菜品分页查询&quot;)    public Result&lt;PageResult&gt; page(DishPageQueryDTO dishPageQueryDTO) &#123;        log.info(&quot;菜品分页查询:&#123;&#125;&quot;, dishPageQueryDTO);        PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);//后绪步骤定义        return Result.success(pageResult);    &#125;</code></pre><h3 id="Service层接口"><a href="#Service层接口" class="headerlink" title="Service层接口"></a>Service层接口</h3><p><strong>在 DishService 中扩展分页查询方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);</code></pre><h3 id="Service层实现类"><a href="#Service层实现类" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p><strong>在 DishServiceImpl 中实现分页查询方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);//后绪步骤实现        return new PageResult(page.getTotal(), page.getResult());    &#125;</code></pre><h3 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h3><p><strong>在 DishMapper 接口中声明 pageQuery 方法：</strong></p><pre><code class="language-java">/**     * 菜品分页查询     *     * @param dishPageQueryDTO     * @return     */    Page&lt;DishVO&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO);</code></pre><p><strong>在 DishMapper.xml 中编写SQL：</strong></p><pre><code class="language-xml">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;        select d.* , c.name as categoryName from dish d left outer join category c on d.category_id = c.id        &lt;where&gt;            &lt;if test=&quot;name != null&quot;&gt;                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)            &lt;/if&gt;            &lt;if test=&quot;categoryId != null&quot;&gt;                and d.category_id = #&#123;categoryId&#125;            &lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;                and d.status = #&#123;status&#125;            &lt;/if&gt;        &lt;/where&gt;        order by d.create_time desc&lt;/select&gt;</code></pre><h2 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h2><h1 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h1><h2 id="需求分析和设计-1"><a href="#需求分析和设计-1" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><h3 id="产品原型-2"><a href="#产品原型-2" class="headerlink" title="产品原型"></a>产品原型</h3><p><strong>删除菜品原型：</strong></p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221121211236356.png" alt="image-20221121211236356" style="zoom:67%;" /> <p><strong>业务规则：</strong></p><ul><li>可以一次删除一个菜品，也可以批量删除菜品</li><li>起售中的菜品不能删除</li><li>被套餐关联的菜品不能删除</li><li>删除菜品后，关联的口味数据也需要删除掉</li></ul><h3 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h3><p>根据上述原型图，设计出相应的接口。</p><p><img src="D:/A_MyselfData/cqwm/讲义/讲义/day03/assets/image-20221121211801121.png" alt="image-20221121211801121" style="zoom:50%;" /> <img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221121211814429.png" alt="image-20221121211814429" style="zoom:50%;" /></p><p>**注意：**删除一个菜品和批量删除菜品共用一个接口，故ids可包含多个菜品id,之间用逗号分隔。</p><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><p>在进行删除菜品操作时，会涉及到以下三张表。</p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221121212436851.png" alt="image-20221121212436851" style="zoom:50%;" /> <p><strong>注意事项：</strong></p><ul><li>在dish表中删除菜品基本数据时，同时，也要把关联在dish_flavor表中的数据一块删除。</li><li>setmeal_dish表为菜品和套餐关联的中间表。</li><li>若删除的菜品数据关联着某个套餐，此时，删除失败。</li><li>若要删除套餐关联的菜品数据，先解除两者关联，再对菜品进行删除。</li></ul><h2 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><p><strong>根据删除菜品的接口定义在DishController中创建方法：</strong></p><pre><code class="language-java">/**     * 菜品批量删除     *     * @param ids     * @return     */    @DeleteMapping    @ApiOperation(&quot;菜品批量删除&quot;)    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;        log.info(&quot;菜品批量删除：&#123;&#125;&quot;, ids);        dishService.deleteBatch(ids);//后绪步骤实现        return Result.success();    &#125;</code></pre><h3 id="Service层接口-1"><a href="#Service层接口-1" class="headerlink" title="Service层接口"></a>Service层接口</h3><p><strong>在DishService接口中声明deleteBatch方法：</strong></p><pre><code class="language-java">/**     * 菜品批量删除     *     * @param ids     */    void deleteBatch(List&lt;Long&gt; ids);</code></pre><h3 id="Service层实现类-1"><a href="#Service层实现类-1" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p><strong>在DishServiceImpl中实现deleteBatch方法：</strong></p><pre><code class="language-java">    @Autowired    private SetmealDishMapper setmealDishMapper;/**     * 菜品批量删除     *     * @param ids     */    @Transactional//事务    public void deleteBatch(List&lt;Long&gt; ids) &#123;        //判断当前菜品是否能够删除---是否存在起售中的菜品？？        for (Long id : ids) &#123;            Dish dish = dishMapper.getById(id);//后绪步骤实现            if (dish.getStatus() == StatusConstant.ENABLE) &#123;                //当前菜品处于起售中，不能删除                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);            &#125;        &#125;        //判断当前菜品是否能够删除---是否被套餐关联了？？        List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);        if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;            //当前菜品被套餐关联了，不能删除            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);        &#125;        //删除菜品表中的菜品数据        for (Long id : ids) &#123;            dishMapper.deleteById(id);//后绪步骤实现            //删除菜品关联的口味数据            dishFlavorMapper.deleteByDishId(id);//后绪步骤实现        &#125;    &#125;</code></pre><h3 id="Mapper层-1"><a href="#Mapper层-1" class="headerlink" title="Mapper层"></a>Mapper层</h3><p><strong>在DishMapper中声明getById方法，并配置SQL：</strong></p><pre><code class="language-java">/**     * 根据主键查询菜品     *     * @param id     * @return     */    @Select(&quot;select * from dish where id = #&#123;id&#125;&quot;)    Dish getById(Long id);</code></pre><p><strong>创建SetmealDishMapper，声明getSetmealIdsByDishIds方法，并在xml文件中编写SQL：</strong></p><pre><code class="language-java">package com.sky.mapper;import com.sky.entity.SetmealDish;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface SetmealDishMapper &#123;    /**     * 根据菜品id查询对应的套餐id     *     * @param dishIds     * @return     */    //select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)    List&lt;Long&gt; getSetmealIdsByDishIds(List&lt;Long&gt; dishIds);&#125;</code></pre><p>SetmealDishMapper.xml</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.SetmealDishMapper&quot;&gt;    &lt;select id=&quot;getSetmealIdsByDishIds&quot; resultType=&quot;java.lang.Long&quot;&gt;        select setmeal_id from setmeal_dish where dish_id in        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;            #&#123;dishId&#125;        &lt;/foreach&gt;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong>在DishMapper.java中声明deleteById方法并配置SQL：</strong></p><pre><code class="language-java">/**     * 根据主键删除菜品数据     *     * @param id     */    @Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)    void deleteById(Long id);</code></pre><p><strong>在DishFlavorMapper中声明deleteByDishId方法并配置SQL：</strong></p><pre><code class="language-java">    /**     * 根据菜品id删除对应的口味数据     * @param dishId     */    @Delete(&quot;delete from dish_flavor where dish_id = #&#123;dishId&#125;&quot;)    void deleteByDishId(Long dishId);</code></pre><h2 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h2><h1 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h1><h2 id="需求分析和设计-2"><a href="#需求分析和设计-2" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><h3 id="产品原型-3"><a href="#产品原型-3" class="headerlink" title="产品原型"></a>产品原型</h3><p>在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击保存按钮完成修改操作。</p><p><strong>修改菜品原型：</strong></p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221122130837173.png" alt="image-20221122130837173" style="zoom:50%;" /> <h3 id="接口设计-2"><a href="#接口设计-2" class="headerlink" title="接口设计"></a>接口设计</h3><p>通过对上述原型图进行分析，该页面共涉及4个接口。</p><p><strong>接口：</strong></p><ul><li>根据id查询菜品</li><li>根据类型查询分类(已实现)</li><li>文件上传(已实现)</li><li>修改菜品</li></ul><p>我们只需要实现<strong>根据id查询菜品</strong>和<strong>修改菜品</strong>两个接口，接下来，我们来重点分析这两个接口。</p><p><strong>1). 根据id查询菜品</strong></p><p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221122131733147.png" alt="image-20221122131733147" style="zoom:50%;" /><img src="D:/A_MyselfData/cqwm/讲义/讲义/day03/assets/image-20221122131743509.png" alt="image-20221122131743509" style="zoom:50%;" /></p><p><strong>2). 修改菜品</strong></p><p><img src="D:/A_MyselfData/cqwm/讲义/讲义/day03/assets/image-20221122131837393.png" alt="image-20221122131837393" style="zoom:50%;" /> <img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221122131847583.png" alt="image-20221122131847583" style="zoom:50%;" /></p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（三）公共字段填充、菜品CRUD\image-20221122131914533.png" alt="image-20221122131914533" style="zoom:50%;" /> <p><strong>注:因为是修改功能，请求方式可设置为PUT。</strong></p><h2 id="代码开发-4"><a href="#代码开发-4" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="根据id查询菜品实现"><a href="#根据id查询菜品实现" class="headerlink" title="根据id查询菜品实现"></a>根据id查询菜品实现</h3><p><strong>1). Controller层</strong></p><p><strong>根据id查询菜品的接口定义在DishController中创建方法：</strong></p><pre><code class="language-java">    /**     * 根据id查询菜品     *     * @param id     * @return     */    @GetMapping(&quot;/&#123;id&#125;&quot;)    @ApiOperation(&quot;根据id查询菜品&quot;)    public Result&lt;DishVO&gt; getById(@PathVariable Long id) &#123;        log.info(&quot;根据id查询菜品：&#123;&#125;&quot;, id);        DishVO dishVO = dishService.getByIdWithFlavor(id);//后绪步骤实现        return Result.success(dishVO);    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p><strong>在DishService接口中声明getByIdWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id查询菜品和对应的口味数据     *     * @param id     * @return     */    DishVO getByIdWithFlavor(Long id);</code></pre><p><strong>3). Service层实现类</strong></p><p><strong>在DishServiceImpl中实现getByIdWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id查询菜品和对应的口味数据     *     * @param id     * @return     */    public DishVO getByIdWithFlavor(Long id) &#123;        //根据id查询菜品数据        Dish dish = dishMapper.getById(id);        //根据菜品id查询口味数据        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);//后绪步骤实现        //将查询到的数据封装到VO        DishVO dishVO = new DishVO();        BeanUtils.copyProperties(dish, dishVO);        dishVO.setFlavors(dishFlavors);        return dishVO;    &#125;</code></pre><p><strong>4). Mapper层</strong></p><p><strong>在DishFlavorMapper中声明getByDishId方法，并配置SQL：</strong></p><pre><code class="language-java">    /**     * 根据菜品id查询对应的口味数据     * @param dishId     * @return     */    @Select(&quot;select * from dish_flavor where dish_id = #&#123;dishId&#125;&quot;)    List&lt;DishFlavor&gt; getByDishId(Long dishId);</code></pre><h3 id="修改菜品实现"><a href="#修改菜品实现" class="headerlink" title="修改菜品实现"></a>修改菜品实现</h3><p><strong>1). Controller层</strong></p><p><strong>根据修改菜品的接口定义在DishController中创建方法：</strong></p><pre><code class="language-java">/**     * 修改菜品     *     * @param dishDTO     * @return     */    @PutMapping    @ApiOperation(&quot;修改菜品&quot;)    public Result update(@RequestBody DishDTO dishDTO) &#123;        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);        dishService.updateWithFlavor(dishDTO);        return Result.success();    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p><strong>在DishService接口中声明updateWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id修改菜品基本信息和对应的口味信息     *     * @param dishDTO     */    void updateWithFlavor(DishDTO dishDTO);</code></pre><p><strong>3). Service层实现类</strong></p><p><strong>在DishServiceImpl中实现updateWithFlavor方法：</strong></p><pre><code class="language-java">/**     * 根据id修改菜品基本信息和对应的口味信息     *     * @param dishDTO     */    public void updateWithFlavor(DishDTO dishDTO) &#123;        Dish dish = new Dish();        BeanUtils.copyProperties(dishDTO, dish);        //修改菜品表基本信息        dishMapper.update(dish);        //删除原有的口味数据        dishFlavorMapper.deleteByDishId(dishDTO.getId());        //重新插入口味数据        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;            flavors.forEach(dishFlavor -&gt; &#123;                dishFlavor.setDishId(dishDTO.getId());            &#125;);            //向口味表插入n条数据            dishFlavorMapper.insertBatch(flavors);        &#125;    &#125;</code></pre><p><strong>4). Mapper层</strong></p><p><strong>在DishMapper中，声明update方法：</strong></p><pre><code class="language-java">/**     * 根据id动态修改菜品数据     *     * @param dish     */    @AutoFill(value = OperationType.UPDATE)    void update(Dish dish);</code></pre><p><strong>并在DishMapper.xml文件中编写SQL:</strong></p><pre><code class="language-xml">&lt;update id=&quot;update&quot;&gt;        update dish        &lt;set&gt;            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;            &lt;if test=&quot;categoryId != null&quot;&gt;category_id = #&#123;categoryId&#125;,&lt;/if&gt;            &lt;if test=&quot;price != null&quot;&gt;price = #&#123;price&#125;,&lt;/if&gt;            &lt;if test=&quot;image != null&quot;&gt;image = #&#123;image&#125;,&lt;/if&gt;            &lt;if test=&quot;description != null&quot;&gt;description = #&#123;description&#125;,&lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;update_time = #&#123;updateTime&#125;,&lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;update_user = #&#123;updateUser&#125;,&lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;&lt;/update&gt;</code></pre><h2 id="接口测试-3"><a href="#接口测试-3" class="headerlink" title="接口测试"></a>接口测试</h2><h1 id="启售禁售菜品"><a href="#启售禁售菜品" class="headerlink" title="启售禁售菜品"></a>启售禁售菜品</h1><h2 id="根据产品原型进行需求分析，分析出业务规则"><a href="#根据产品原型进行需求分析，分析出业务规则" class="headerlink" title="根据产品原型进行需求分析，分析出业务规则"></a>根据产品原型进行需求分析，分析出业务规则</h2><p>菜品起售表示该菜品可以对外售卖，在用户端可以点餐，菜品停售表示此菜品下架，用户端无法点餐。</p><p>业务规则为：如果执行停售操作，则包含此菜品的套餐也需要停售。</p><h2 id="设计-菜品起售停售-功能的接口"><a href="#设计-菜品起售停售-功能的接口" class="headerlink" title="设计 菜品起售停售 功能的接口"></a>设计 菜品起售停售 功能的接口</h2><img src="/2025/07/16/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%89%EF%BC%89%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E3%80%81%E8%8F%9C%E5%93%81CRUD/image-20250716163254205.png" class="" alt="image-20250716163254205"><h2 id="根据接口设计进行代码实现"><a href="#根据接口设计进行代码实现" class="headerlink" title="根据接口设计进行代码实现"></a>根据接口设计进行代码实现</h2><h4 id="DishController"><a href="#DishController" class="headerlink" title="DishController"></a>DishController</h4><pre><code class="language-java">/**     * 菜品起售停售     * @param status     * @param id     * @return*/@PostMapping(&quot;/status/&#123;status&#125;&quot;)@ApiOperation(&quot;菜品起售停售&quot;)public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id)&#123;    dishService.startOrStop(status,id);    return Result.success();&#125;</code></pre><h4 id="DishService"><a href="#DishService" class="headerlink" title="DishService"></a>DishService</h4><pre><code class="language-java">/**     * 菜品起售停售     * @param status     * @param id*/void startOrStop(Integer status, Long id);</code></pre><h4 id="DishServiceImpl"><a href="#DishServiceImpl" class="headerlink" title="DishServiceImpl"></a>DishServiceImpl</h4><pre><code class="language-java">/**     * 菜品起售停售     *     * @param status     * @param id*/@Transactionalpublic void startOrStop(Integer status, Long id) &#123;    Dish dish = Dish.builder()        .id(id)        .status(status)        .build();    dishMapper.update(dish);    if (status == StatusConstant.DISABLE) &#123;        // 如果是停售操作，还需要将包含当前菜品的套餐也停售        List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();        dishIds.add(id);        // select setmeal_id from setmeal_dish where dish_id in (?,?,?)        List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);        if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;            for (Long setmealId : setmealIds) &#123;                Setmeal setmeal = Setmeal.builder()                    .id(setmealId)                    .status(StatusConstant.DISABLE)                    .build();                setmealMapper.update(setmeal);            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="SetmealMapper"><a href="#SetmealMapper" class="headerlink" title="SetmealMapper"></a>SetmealMapper</h4><pre><code class="language-java">/**     * 根据id修改套餐     *     * @param setmeal */@AutoFill(OperationType.UPDATE)void update(Setmeal setmeal);</code></pre><h4 id="SetmealMapper-xml"><a href="#SetmealMapper-xml" class="headerlink" title="SetmealMapper.xml"></a>SetmealMapper.xml</h4><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;        update setmeal        &lt;set&gt;            &lt;if test=&quot;name != null&quot;&gt;                name = #&#123;name&#125;,            &lt;/if&gt;            &lt;if test=&quot;categoryId != null&quot;&gt;                category_id = #&#123;categoryId&#125;,            &lt;/if&gt;            &lt;if test=&quot;price != null&quot;&gt;                price = #&#123;price&#125;,            &lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;                status = #&#123;status&#125;,            &lt;/if&gt;            &lt;if test=&quot;description != null&quot;&gt;                description = #&#123;description&#125;,            &lt;/if&gt;            &lt;if test=&quot;image != null&quot;&gt;                image = #&#123;image&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;                update_time = #&#123;updateTime&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;                update_user = #&#123;updateUser&#125;            &lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;</code></pre><h2 id="接口测试-4"><a href="#接口测试-4" class="headerlink" title="接口测试"></a>接口测试</h2>]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（0）过程解惑</title>
      <link href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/"/>
      <url>/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/</url>
      
        <content type="html"><![CDATA[<h1 id="DTO-VO-Entity-实体类-区别"><a href="#DTO-VO-Entity-实体类-区别" class="headerlink" title="DTO,VO,Entity(实体类)区别"></a>DTO,VO,Entity(实体类)区别</h1><table><thead><tr><th>类型</th><th>全称</th><th>作用</th><th>用途</th></tr></thead><tbody><tr><td>VO</td><td>Value Object</td><td>值对象，表示<strong>只读的展示数据</strong></td><td>通常用于前端展示层，封装用户需要展示的数据，<strong>包装返回的数据</strong></td></tr><tr><td>DTO</td><td>Data Transfer Object</td><td>数据传输对象，用于<strong>系统内部层与层之间的数据传输</strong></td><td>常用于 Controller ↔ Service 或远程接口间的<strong>数据传输</strong></td></tr><tr><td>实体类（Entity）</td><td>实体类&#x2F;模型类</td><td>表示数据库中的一张表</td><td>用于 ORM 映射（如 JPA、MyBatis），直接与数据库交互</td></tr></tbody></table><h1 id="数据库字段与变量名的对应"><a href="#数据库字段与变量名的对应" class="headerlink" title="数据库字段与变量名的对应"></a>数据库字段与变量名的对应</h1><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/image-20250715145106151.png" class="" alt="image-20250715145106151"><h1 id="统一登录验证—JWT令牌"><a href="#统一登录验证—JWT令牌" class="headerlink" title="统一登录验证—JWT令牌"></a>统一登录验证—JWT令牌</h1><h1 id="统一封装返回给前端的结果-Result封装返回结果"><a href="#统一封装返回给前端的结果-Result封装返回结果" class="headerlink" title="统一封装返回给前端的结果-Result封装返回结果"></a>统一封装返回给前端的结果-Result封装返回结果</h1><p>进入sky-common模块，在com.sky.result包下定义了Result.java</p><pre><code class="language-java">package com.sky.result;import lombok.Data;import java.io.Serializable;/** * 后端统一返回结果 * @param &lt;T&gt; */@Datapublic class Result&lt;T&gt; implements Serializable &#123;    private Integer code; //编码：1成功，0和其它数字为失败    private String msg; //错误信息    private T data; //数据    public static &lt;T&gt; Result&lt;T&gt; success() &#123;        Result&lt;T&gt; result = new Result&lt;T&gt;();        result.code = 1;        return result;    &#125;    public static &lt;T&gt; Result&lt;T&gt; success(T object) &#123;        Result&lt;T&gt; result = new Result&lt;T&gt;();        result.data = object;        result.code = 1;        return result;    &#125;    public static &lt;T&gt; Result&lt;T&gt; error(String msg) &#123;        Result result = new Result();        result.msg = msg;        result.code = 0;        return result;    &#125;&#125;</code></pre><h1 id="DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils"><a href="#DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils" class="headerlink" title="DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils"></a>DTO（数据传输对象）和实体类之间的数据转换—-BeanUtils</h1><blockquote><p>注意：</p><p>​前端传来的数据字段 和 插入数据库中的字段数量不一致，缺少的需要补充。</p></blockquote><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%880%EF%BC%89%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%83%91/image-20250715155059419.png" class="" alt="image-20250715155059419"><p>对应代码如下：</p><pre><code class="language-java"> //对象属性拷贝BeanUtils.copyProperties(employeeDTO, employee);//设置账号的状态，默认正常状态 1表示正常 0表示锁定-------为了代码的可读性，将其封装为了常量类StatusConstant.javaemployee.setStatus(StatusConstant.ENABLE);//设置密码，默认密码123456employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</code></pre><h1 id="如何从JWT令牌中动态获取当前登录人的id。"><a href="#如何从JWT令牌中动态获取当前登录人的id。" class="headerlink" title="如何从JWT令牌中动态获取当前登录人的id。"></a>如何从JWT令牌中动态获取当前登录人的id。</h1><p><strong>1. JWT令牌中携带的id信息</strong></p><p><strong>2. 将id放到线程中</strong></p><p>因为在员工登录成功后生成的JWT令牌，后端会返回一个JWT令牌给前端，在后续的请求中，前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id。</p><pre><code class="language-java">  try &#123;            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);            //解析出令牌中的id            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());            log.info(&quot;当前员工id：&quot;, empId);            //将解析出的id，放到线程中      //--------------------------------------            BaseContext.setCurrentId(empId);//-------------------------------------                        //3、通过，放行            return true;        &#125; catch (Exception ex) &#123;            //4、不通过，响应401状态码            response.setStatus(401);            return false;        &#125;</code></pre><p><strong>解析出登录员工id后，如何传递给Service的save方法？</strong></p><p>​通过ThreadLocal进行传递。</p><p>在sky-common模块，中的com.sky.context</p><pre><code class="language-java">package com.sky.context;public class BaseContext &#123;    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) &#123;        threadLocal.set(id);    &#125;    public static Long getCurrentId() &#123;        return threadLocal.get();    &#125;    public static void removeCurrentId() &#123;        threadLocal.remove();    &#125;&#125;</code></pre><p><strong>在Service中获取线程局部变量中的值：</strong></p><pre><code class="language-java">/**     * 新增员工     *     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        //.............................        //设置当前记录创建人id和修改人id        employee.setCreateUser(BaseContext.getCurrentId());//目前写个假数据，后期修改        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.insert(employee);    &#125;</code></pre><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><strong>介绍：</strong></p><p>ThreadLocal 并不是一个Thread，而是Thread的局部变量。<br>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p><p><strong>常用方法：</strong></p><ul><li>public void set(T value) 设置当前线程的线程局部变量的值</li><li>public T get() 返回当前线程所对应的线程局部变量的值</li><li>public void remove()        移除当前线程的线程局部变量</li></ul><p>对ThreadLocal有了一定认识后，接下来继续解决<strong>问题二</strong></p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（0）过程解惑\image-20221111212349365.png" alt="image-20221111212349365" style="zoom:67%;" /> <p>ThreadLocal 操作的工具类：</p><pre><code class="language-java">package com.sky.context;public class BaseContext &#123;    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) &#123;        threadLocal.set(id);    &#125;    public static Long getCurrentId() &#123;        return threadLocal.get();    &#125;    public static void removeCurrentId() &#123;        threadLocal.remove();    &#125;&#125;</code></pre><h1 id="统一分页查询"><a href="#统一分页查询" class="headerlink" title="统一分页查询"></a>统一分页查询</h1><p>统一都封装为PageResult对象。</p><p>在sky-common模块</p><pre><code class="language-java">package com.sky.result;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.List;/** * 封装分页查询结果 */@Data@AllArgsConstructor@NoArgsConstructorpublic class PageResult implements Serializable &#123;    private long total; //总记录数    private List records; //当前页数据集合&#125;</code></pre><p>在EmployeeServiceImpl中实现pageQuery方法：</p><pre><code class="language-java">/**     * 分页查询     *     * @param employeePageQueryDTO     * @return     */    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;        // select * from employee limit 0,10        //开始分页查询        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());        Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);//后续定义        long total = page.getTotal();        List&lt;Employee&gt; records = page.getResult();        return new PageResult(total, records);    &#125;</code></pre><p>**注意：**此处使用 mybatis 的分页插件 PageHelper 来简化分页代码的开发。底层基于 mybatis 的拦截器实现。</p><p>故在pom.xml文中添加依赖(初始工程已添加)</p><pre><code class="language-xml">&lt;dependency&gt;   &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;   &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;$&#123;pagehelper&#125;&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="统一日期格式-全局处理"><a href="#统一日期格式-全局处理" class="headerlink" title="统一日期格式-全局处理"></a>统一日期格式-全局处理</h1><p>在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理</p><p> Spring MVC 框架的 <strong>消息转换器扩展（MessageConverter）</strong>，核心目的是用自定义的 <code>JacksonObjectMapper</code> 来替代 Spring 默认的 Jackson 配置，从而定制 JSON 的序列化和反序列化行为。</p><pre><code class="language-java">/**     * 扩展Spring MVC框架的消息转化器     * @param converters     */    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        log.info(&quot;扩展消息转换器...&quot;);        //创建一个消息转换器对象        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据        converter.setObjectMapper(new JacksonObjectMapper());        //将自己的消息转化器加入容器中        converters.add(0,converter);    &#125;</code></pre><p>时间格式定义，sky-common模块中</p><pre><code class="language-java">/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123;    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;    public JacksonObjectMapper() &#123;        super();        //收到未知属性时不报异常        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);        //反序列化时，属性不存在的兼容处理        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        SimpleModule simpleModule = new SimpleModule()                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));        //注册功能模块 例如，可以添加自定义序列化器和反序列化器        this.registerModule(simpleModule);    &#125;&#125;</code></pre><h2 id="针对处理："><a href="#针对处理：" class="headerlink" title="针对处理："></a>针对处理：</h2><p>在属性上加上注解，对日期进行格式化</p><img src="D:\我的博客\myblog\source\_posts\苍穹外卖（0）过程解惑\image-20221112103501581.png" alt="image-20221112103501581" style="zoom:67%;" /> <p>但这种方式，需要在每个时间属性上都要加上该注解，使用较麻烦，不能全局处理。</p>]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（二）员工管理、菜品分类管理</title>
      <link href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/"/>
      <url>/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h1><h2 id="需求分析与设计"><a href="#需求分析与设计" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型"></a>产品原型</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716102526489.png" class="" alt="image-20250716102526489"><p>当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据, 然后将数据保存至数据库中。</p><p><strong>注意事项：</strong></p><ol><li>账号必须是唯一的</li><li>手机号为合法的11位手机号码</li><li>身份证号为合法的18位身份证号码</li><li>密码默认为123456</li></ol><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715113036861.png" class="" alt="image-20250715113036861"><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><p>新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。</p><p><strong>employee表结构：</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>name</td><td>varchar(32)</td><td>姓名</td><td></td></tr><tr><td>username</td><td>varchar(32)</td><td>用户名</td><td>唯一</td></tr><tr><td>password</td><td>varchar(64)</td><td>密码</td><td></td></tr><tr><td>phone</td><td>varchar(11)</td><td>手机号</td><td></td></tr><tr><td>sex</td><td>varchar(2)</td><td>性别</td><td></td></tr><tr><td>id_number</td><td>varchar(18)</td><td>身份证号</td><td></td></tr><tr><td>status</td><td>Int</td><td>账号状态</td><td>1启用0禁用</td></tr><tr><td>create_time</td><td>Datetime</td><td>创建时间</td><td></td></tr><tr><td>update_time</td><td>datetime</td><td>最后修改时间</td><td></td></tr><tr><td>create_user</td><td>bigint</td><td>创建人id</td><td></td></tr><tr><td>update_user</td><td>bigint</td><td>最后修改人id</td><td></td></tr></tbody></table><h2 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="设计DTO"><a href="#设计DTO" class="headerlink" title="设计DTO"></a>设计DTO</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715144100437.png" class=""><p><strong>进入sky-pojo模块，在com.sky.dto包下，定义EmployeeDTO</strong></p><pre><code class="language-java">package com.sky.dto;import lombok.Data;import java.io.Serializable;@Datapublic class EmployeeDTO implements Serializable &#123;    private Long id;    private String username;    private String name;    private String phone;    private String sex;    private String idNumber;&#125;</code></pre><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>进入到sky-server模块中，在com.sky.controller.admin包下，在EmployeeController中创建新增员工方法，接收前端提交的参数。</p><pre><code class="language-java">/**     * 新增员工     * @param employeeDTO     * @return     */    @PostMapping    @ApiOperation(&quot;新增员工&quot;)    public Result save(@RequestBody EmployeeDTO employeeDTO)&#123;        log.info(&quot;新增员工：&#123;&#125;&quot;,employeeDTO);        employeeService.save(employeeDTO);//该方法后续步骤会定义        return Result.success();    &#125;</code></pre><h3 id="Service层接口"><a href="#Service层接口" class="headerlink" title="Service层接口"></a>Service层接口</h3><p>进入到sky-server模块中,com.sky.server.EmployeeService</p><pre><code class="language-java">/**     * 新增员工     * @param employeeDTO     */    void save(EmployeeDTO employeeDTO);</code></pre><h3 id="Service层实现类"><a href="#Service层实现类" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p>com.sky.server.impl.EmployeeServiceImpl中创建方法</p><pre><code class="language-java">/**     * 新增员工     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        //对象属性拷贝        BeanUtils.copyProperties(employeeDTO, employee);        //设置账号的状态，默认正常状态 1表示正常 0表示锁定-------为了代码的可读性，将其封装为了常量类StatusConstant.java        employee.setStatus(StatusConstant.ENABLE);        //设置密码，默认密码123456        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));        //设置当前记录的创建时间和修改时间        employee.setCreateTime(LocalDateTime.now());        employee.setUpdateTime(LocalDateTime.now());        //设置当前记录创建人id和修改人id        employee.setCreateUser(10L);//目前写个假数据，后期修改        employee.setUpdateUser(10L);        employeeMapper.insert(employee);//后续步骤定义    &#125;</code></pre><p>在sky-common模块com.sky.constants包下已定义StatusConstant.java</p><pre><code class="language-java">package com.sky.constant;/** * 状态常量，启用或者禁用 */public class StatusConstant &#123;    //启用    public static final Integer ENABLE = 1;    //禁用    public static final Integer DISABLE = 0;&#125;</code></pre><blockquote><p>注意：</p><p>​前端传来的数据字段 和 插入数据库中的字段数量不一致，缺少的需要补充。</p></blockquote><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715155059419.png" class="" alt="image-20250715155059419"><p>对应代码如下：</p><pre><code class="language-java"> //对象属性拷贝BeanUtils.copyProperties(employeeDTO, employee);//设置账号的状态，默认正常状态 1表示正常 0表示锁定-------为了代码的可读性，将其封装为了常量类StatusConstant.javaemployee.setStatus(StatusConstant.ENABLE);//设置密码，默认密码123456employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</code></pre><h3 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h3><p>com.sky.EmployeeMapper中添加方法</p><pre><code class="language-java">/**     * 插入员工数据     * @param employee     */    @Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +            &quot;values &quot; +            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)    void insert(Employee employee);</code></pre><p>在application.yml中已开启驼峰命名，故id_number和idNumber可对应。</p><pre><code class="language-yaml">mybatis:  configuration:    #开启驼峰命名    map-underscore-to-camel-case: true</code></pre><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><p>因为在登录过程，我们使用了<strong>JWT令牌验证</strong>的方式，所以在访问其他网站时都要在请求头上携带token令牌。</p><p><strong>获取token令牌</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715151131283.png" class="" alt="image-20250715151131283"><p><strong>将token令牌放到请求头中</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715151218200-1752563539574-1.png" class="" alt="image-20250715151218200"><p><strong>传入新增员工的信息</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715151254711.png" class="" alt="image-20250715151254711"><h2 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h2><h3 id="当员工姓名重复时，系统直接报错，停止"><a href="#当员工姓名重复时，系统直接报错，停止" class="headerlink" title="当员工姓名重复时，系统直接报错，停止"></a><strong>当员工姓名重复时，系统直接报错，停止</strong></h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715152230360.png" class="" alt="image-20250715152230360"><p>事实上：</p><p><strong>为了系统的正常运行，应该是出现提示错误  “该员工已存在”  而不是系统报错。</strong></p><p>针对手段：</p><p><strong>添加全局异常处理器来统一处理用户名已存在的错误。</strong></p><ol><li><p>截取错误信息ex</p></li><li><p>对ex进行字符串匹配</p></li><li><p>返回错误信息提示</p><br><p>具体整改如下：</p></li></ol><p>进入到sky-server模块，com.sky.hander包下，GlobalExceptionHandler.java添加方法</p><pre><code class="language-java">   /**     *重复出现相同的用户名     */    @ExceptionHandler    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123;        //异常信息        //Duplicate entry &#39;小智&#39; for key &#39;employee.idx_username&#39;        //下标：0     1       2    3   4     5        /**         * 1.获取异常信息         * 2.如果异常信息中存在Duplicate entry 则为该异常         *      如果不包含Duplicate entry 则为未知错误         * 3.如果是该异常，则返回异常信息：“用户名已存在”         *         1.对提取出来的异常信息使用 空格 划分数组元素         *         2.取出用户名所在下标的元素         *         3.打印提示信息         */        String message = ex.getMessage();        /*        message.contains(&quot;Duplicate entry&quot;) 的作用是 检查字符串 message 中是否包含子串 &quot;Duplicate entry&quot;        */        if (message.contains(&quot;Duplicate entry&quot;))&#123;            String[] split = message.split(&quot; &quot;);            String username = split[2];            String msy = username + &quot;已存在&quot;;            return Result.error(msy);        &#125;else &#123;            return  Result.error(&quot;未知错误&quot;);        &#125;    &#125;</code></pre><p>进入到sky-common模块，在MessageConstant.java添加</p><pre><code class="language-java">public static final String ALREADY_EXISTS = &quot;已存在&quot;;</code></pre><p><strong>再次，接口测试</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715153930092.png" class="" alt="image-20250715153930092"><h3 id="无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的"><a href="#无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的" class="headerlink" title="无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的"></a>无法获得操作者（当前登录员工）的id—数据库中可以查看到是谁进行新增员工的操作的</h3><p><strong>1. JWT令牌中携带的id信息</strong></p><p><strong>2. 将id放到线程中</strong></p><p>因为在员工登录成功后生成的JWT令牌，后端会返回一个JWT令牌给前端，在后续的请求中，前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id。</p><pre><code class="language-java">  try &#123;            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);            //解析出令牌中的id            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());            log.info(&quot;当前员工id：&quot;, empId);            //将解析出的id，放到线程中      //--------------------------------------            BaseContext.setCurrentId(empId);//-------------------------------------                        //3、通过，放行            return true;        &#125; catch (Exception ex) &#123;            //4、不通过，响应401状态码            response.setStatus(401);            return false;        &#125;</code></pre><p><strong>解析出登录员工id后，如何传递给Service的save方法？</strong></p><p>​通过ThreadLocal进行传递。</p><p>在sky-common模块，中的com.sky.context</p><pre><code class="language-java">package com.sky.context;public class BaseContext &#123;    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();    public static void setCurrentId(Long id) &#123;        threadLocal.set(id);    &#125;    public static Long getCurrentId() &#123;        return threadLocal.get();    &#125;    public static void removeCurrentId() &#123;        threadLocal.remove();    &#125;&#125;</code></pre><p><strong>在Service中获取线程局部变量中的值：</strong></p><pre><code class="language-java">/**     * 新增员工     *     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        //.............................        //设置当前记录创建人id和修改人id        employee.setCreateUser(BaseContext.getCurrentId());//目前写个假数据，后期修改        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.insert(employee);    &#125;</code></pre><p>再次，接口测试</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715162700866.png" class="" alt="image-20250715162700866"><h1 id="员工分页查询"><a href="#员工分页查询" class="headerlink" title="员工分页查询"></a>员工分页查询</h1><h2 id="产品原型-1"><a href="#产品原型-1" class="headerlink" title="产品原型"></a>产品原型</h2><p><strong>查询员工原型：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715162934812.png" class="" alt="image-20250715162934812"> <p><strong>业务规则</strong>：</p><ul><li>根据页码展示员工信息</li><li>每页展示10条数据</li><li>分页查询时可以根据需要，输入员工姓名进行查询</li></ul><h2 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h2><p><strong>1). 根据id查询员工信息</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715163120523.png" class=""><p><strong>注意事项：</strong></p><ul><li>请求参数类型为Query，不是json格式提交，在路径后直接拼接。&#x2F;admin&#x2F;employee&#x2F;page?name&#x3D;zhangsan</li><li>返回数据中records数组中使用Employee实体类对属性进行封装。</li></ul><h2 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="设计DTO类"><a href="#设计DTO类" class="headerlink" title="设计DTO类"></a>设计DTO类</h3><p>根据请求参数进行封装，在sky-pojo模块中</p><pre><code class="language-java">package com.sky.dto;import lombok.Data;import java.io.Serializable;@Datapublic class EmployeePageQueryDTO implements Serializable &#123;    //员工姓名    private String name;    //页码    private int page;    //每页显示记录数    private int pageSize;&#125;</code></pre><h3 id="封装分页查询结果—–PageResult"><a href="#封装分页查询结果—–PageResult" class="headerlink" title="封装分页查询结果—–PageResult"></a>封装分页查询结果—–PageResult</h3><p>统一都封装为PageResult对象。</p><p>在sky-common模块</p><pre><code class="language-java">package com.sky.result;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.List;/** * 封装分页查询结果 */@Data@AllArgsConstructor@NoArgsConstructorpublic class PageResult implements Serializable &#123;    private long total; //总记录数    private List records; //当前页数据集合&#125;</code></pre><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><p>在sky-server模块中，com.sky.controller.admin.EmployeeController中添加分页查询方法。</p><pre><code class="language-java">/**     * 员工分页查询     * @param employeePageQueryDTO     * @return     */    @GetMapping(&quot;/page&quot;)    @ApiOperation(&quot;员工分页查询&quot;)    public Result&lt;PageResult&gt; page(EmployeePageQueryDTO employeePageQueryDTO)&#123;        log.info(&quot;员工分页查询，参数为：&#123;&#125;&quot;, employeePageQueryDTO);        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);//后续定义        return Result.success(pageResult);    &#125;</code></pre><h3 id="Service层接口-1"><a href="#Service层接口-1" class="headerlink" title="Service层接口"></a>Service层接口</h3><p>在EmployeeService接口中声明pageQuery方法：</p><pre><code class="language-java">/**     * 分页查询     * @param employeePageQueryDTO     * @return     */    PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);</code></pre><h3 id="Service层实现类-1"><a href="#Service层实现类-1" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><blockquote><p>Page的依赖</p></blockquote><blockquote><pre><code class="language-java">import com.github.pagehelper.Page;</code></pre></blockquote><p>在EmployeeServiceImpl中实现pageQuery方法：</p><pre><code class="language-java">/**     * 分页查询     *     * @param employeePageQueryDTO     * @return     */    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;        // select * from employee limit 0,10        //开始分页查询                               页码                              每页记录数        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());        Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);//后续定义        long total = page.getTotal();        List&lt;Employee&gt; records = page.getResult();        return new PageResult(total, records);    &#125;</code></pre><p>**注意：**此处使用 mybatis 的分页插件 PageHelper 来简化分页代码的开发。底层基于 mybatis 的拦截器实现。</p><p>故在pom.xml文中添加依赖(初始工程已添加)</p><pre><code class="language-xml">&lt;dependency&gt;   &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;   &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;$&#123;pagehelper&#125;&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Mapper层-1"><a href="#Mapper层-1" class="headerlink" title="Mapper层"></a>Mapper层</h3><p>在 EmployeeMapper 中声明 pageQuery 方法：</p><pre><code class="language-java">/**     * 分页查询     * @param employeePageQueryDTO     * @return     */    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);</code></pre><p>在 src&#x2F;main&#x2F;resources&#x2F;mapper&#x2F;EmployeeMapper.xml 中编写SQL：</p><pre><code class="language-sql">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Employee&quot;&gt;        select * from employee        &lt;where&gt;            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)            &lt;/if&gt;        &lt;/where&gt;        order by create_time desc    &lt;/select&gt;</code></pre><h2 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715171559054.png" class="" alt="image-20250715171559054"><h2 id="代码完善-1"><a href="#代码完善-1" class="headerlink" title="代码完善"></a>代码完善</h2><h4 id="操作时间（系统时间）-表示错误"><a href="#操作时间（系统时间）-表示错误" class="headerlink" title="操作时间（系统时间）-表示错误"></a>操作时间（系统时间）-表示错误</h4><p>在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理</p><p> Spring MVC 框架的 <strong>消息转换器扩展（MessageConverter）</strong>，核心目的是用自定义的 <code>JacksonObjectMapper</code> 来替代 Spring 默认的 Jackson 配置，从而定制 JSON 的序列化和反序列化行为。</p><pre><code class="language-java">/**     * 扩展Spring MVC框架的消息转化器     * @param converters     */    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        log.info(&quot;扩展消息转换器...&quot;);        //创建一个消息转换器对象        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据        converter.setObjectMapper(new JacksonObjectMapper());        //将自己的消息转化器加入容器中        converters.add(0,converter);    &#125;</code></pre><p>时间格式定义，sky-common模块中</p><pre><code class="language-java">/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123;    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;    public JacksonObjectMapper() &#123;        super();        //收到未知属性时不报异常        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);        //反序列化时，属性不存在的兼容处理        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        SimpleModule simpleModule = new SimpleModule()                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));        //注册功能模块 例如，可以添加自定义序列化器和反序列化器        this.registerModule(simpleModule);    &#125;&#125;</code></pre><p><strong>再次，接口测试</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715173302970.png" class="" alt="image-20250715173302970"><h1 id="启用禁用员工账号"><a href="#启用禁用员工账号" class="headerlink" title="启用禁用员工账号"></a>启用禁用员工账号</h1><h2 id="产品原型-2"><a href="#产品原型-2" class="headerlink" title="产品原型"></a>产品原型</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715174422570.png" class="" alt="image-20250715174422570"><p><strong>业务规则：</strong></p><ul><li>可以对状态为“启用” 的员工账号进行“禁用”操作</li><li>可以对状态为“禁用”的员工账号进行“启用”操作</li><li>状态为“禁用”的员工账号不能登录系统</li></ul><h2 id="接口设计-2"><a href="#接口设计-2" class="headerlink" title="接口设计"></a>接口设计</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250715174450579.png" class="" alt="image-20250715174450579"><p>1). 路径参数携带状态值。</p><p>2). 同时，把id传递过去，明确对哪个用户进行操作。</p><p>3). 返回数据code状态是必须，其它是非必须。</p><h2 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="Controller层-2"><a href="#Controller层-2" class="headerlink" title="Controller层"></a>Controller层</h3><p>在sky-server模块中，根据接口设计中的请求参数形式对应的在 EmployeeController 中创建启用禁用员工账号的方法：</p><pre><code class="language-java">/**     * 启用禁用员工账号     * @param status     * @param id     * @return     */    @PostMapping(&quot;/status/&#123;status&#125;&quot;)    @ApiOperation(&quot;启用禁用员工账号&quot;)    public Result startOrStop(@PathVariable Integer status,Long id)&#123;        log.info(&quot;启用禁用员工账号：&#123;&#125;,&#123;&#125;&quot;,status,id);        employeeService.startOrStop(status,id);//后绪步骤定义        return Result.success();    &#125;</code></pre><h3 id="Service层接口-2"><a href="#Service层接口-2" class="headerlink" title="Service层接口"></a>Service层接口</h3><p>在 EmployeeService 接口中声明启用禁用员工账号的业务方法：</p><pre><code class="language-java">/**     * 启用禁用员工账号     * @param status     * @param id     */    void startOrStop(Integer status, Long id);</code></pre><h3 id="Service层实现类-2"><a href="#Service层实现类-2" class="headerlink" title="Service层实现类"></a>Service层实现类</h3><p>在 EmployeeServiceImpl 中实现启用禁用员工账号的业务方法：</p><pre><code class="language-java">/**     * 启用禁用员工账号     *     * @param status     * @param id     */    public void startOrStop(Integer status, Long id) &#123;        Employee employee = Employee.builder()                .status(status)                .id(id)                .build();        employeeMapper.update(employee);    &#125;</code></pre><h3 id="Mapper层-2"><a href="#Mapper层-2" class="headerlink" title="Mapper层"></a>Mapper层</h3><p>在 EmployeeMapper 接口中声明 update 方法：</p><pre><code class="language-java">/**     * 根据主键动态修改属性     * @param employee     */    void update(Employee employee);</code></pre><p>在 EmployeeMapper.xml 中编写SQL：</p><pre><code class="language-sql">&lt;update id=&quot;update&quot; parameterType=&quot;Employee&quot;&gt;        update employee        &lt;set&gt;            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;            &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt;            &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt;            &lt;if test=&quot;phone != null&quot;&gt;phone = #&#123;phone&#125;,&lt;/if&gt;            &lt;if test=&quot;sex != null&quot;&gt;sex = #&#123;sex&#125;,&lt;/if&gt;            &lt;if test=&quot;idNumber != null&quot;&gt;id_Number = #&#123;idNumber&#125;,&lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;update_Time = #&#123;updateTime&#125;,&lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;update_User = #&#123;updateUser&#125;,&lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;    &lt;/update&gt;</code></pre><h2 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716084543164.png" class="" alt="image-20250716084543164"><h1 id="编辑员工"><a href="#编辑员工" class="headerlink" title="编辑员工"></a>编辑员工</h1><h2 id="需求分析与设计-1"><a href="#需求分析与设计-1" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型-3"><a href="#产品原型-3" class="headerlink" title="产品原型"></a>产品原型</h3><p><strong>修改页面原型</strong>：</p><blockquote><p>注：点击修改时，数据应该正常回显到修改页面。</p><p>因此必须先需要根据id查询员工信息，来回显数据</p></blockquote><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716090435476.png" class="" alt="image-20250716090435476"><h2 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h2><h3 id="回显员工信息"><a href="#回显员工信息" class="headerlink" title="回显员工信息"></a>回显员工信息</h3><p><strong>1). Controller层</strong></p><p>在 EmployeeController 中创建 getById 方法：</p><pre><code class="language-java">/**     * 根据id查询员工信息     * @param id     * @return     */    @GetMapping(&quot;/&#123;id&#125;&quot;)    @ApiOperation(&quot;根据id查询员工信息&quot;)    public Result&lt;Employee&gt; getById(@PathVariable Long id)&#123;        Employee employee = employeeService.getById(id);        return Result.success(employee);    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p>在 EmployeeService 接口中声明 getById 方法：</p><pre><code class="language-java">    /**     * 根据id查询员工     * @param id     * @return     */    Employee getById(Long id);</code></pre><p><strong>3). Service层实现类</strong></p><p>在 EmployeeServiceImpl 中实现 getById 方法：</p><pre><code class="language-java"> /**     * 根据id查询员工     *     * @param id     * @return     */    public Employee getById(Long id) &#123;        Employee employee = employeeMapper.getById(id);        employee.setPassword(&quot;****&quot;);        return employee;    &#125;</code></pre><p><strong>4). Mapper层</strong></p><p>在 EmployeeMapper 接口中声明 getById 方法：</p><pre><code class="language-java">/**     * 根据id查询员工信息     * @param id     * @return     */    @Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)    Employee getById(Long id);</code></pre><h3 id="修改员工信息功能"><a href="#修改员工信息功能" class="headerlink" title="修改员工信息功能"></a>修改员工信息功能</h3><p><strong>1). Controller层</strong></p><p>在 EmployeeController 中创建 update 方法：</p><pre><code class="language-java">/**     * 编辑员工信息     * @param employeeDTO     * @return     */    @PutMapping    @ApiOperation(&quot;编辑员工信息&quot;)    public Result update(@RequestBody EmployeeDTO employeeDTO)&#123;        log.info(&quot;编辑员工信息：&#123;&#125;&quot;, employeeDTO);        employeeService.update(employeeDTO);        return Result.success();    &#125;</code></pre><p><strong>2). Service层接口</strong></p><p>在 EmployeeService 接口中声明 update 方法：</p><pre><code class="language-java">    /**     * 编辑员工信息     * @param employeeDTO     */    void update(EmployeeDTO employeeDTO);</code></pre><p><strong>3). Service层实现类</strong></p><p>在 EmployeeServiceImpl 中实现 update 方法：</p><pre><code class="language-java"> /**     * 编辑员工信息     *     * @param employeeDTO     */    public void update(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        BeanUtils.copyProperties(employeeDTO, employee);        employee.setUpdateTime(LocalDateTime.now());        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.update(employee);    &#125;</code></pre><p>在实现<strong>启用禁用员工账号</strong>功能时，已实现employeeMapper.update(employee)，在此不需写Mapper层代码。</p><h2 id="接口测试-3"><a href="#接口测试-3" class="headerlink" title="接口测试"></a>接口测试</h2><p><strong>1)：根据id查询并回显信息到编辑页面</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716093851763.png" class="" alt="image-20250716093851763"><p><strong>2)：编辑页面</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716093819962.png" class="" alt="image-20250716093819962"><h1 id="分类模块功能"><a href="#分类模块功能" class="headerlink" title="分类模块功能"></a>分类模块功能</h1><h2 id="需求分析与设计-2"><a href="#需求分析与设计-2" class="headerlink" title="需求分析与设计"></a>需求分析与设计</h2><h3 id="产品原型-4"><a href="#产品原型-4" class="headerlink" title="产品原型"></a>产品原型</h3><p>后台系统中可以管理分类信息，分类包括两种类型，分别是 <strong>菜品分类</strong> 和 <strong>套餐分类</strong> 。</p><p>先来分析<strong>菜品分类</strong>相关功能。</p><p>**新增菜品分类：**当我们在后台系统中添加菜品时需要选择一个菜品分类，在移动端也会按照菜品分类来展示对应的菜品。</p><p>**菜品分类分页查询：**系统中的分类很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p><p>**根据id删除菜品分类：**在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。</p><p>**修改菜品分类：**在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作。</p><p>**启用禁用菜品分类：**在分类管理列表页面，可以对某个分类进行启用或者禁用操作。</p><p>**分类类型查询：**当点击分类类型下拉框时，从数据库中查询所有的菜品分类数据进行展示。</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094626559.png" class="" alt="image-20250716094626559"><p><strong>业务规则：</strong></p><ul><li>分类名称必须是唯一的</li><li>分类按照类型可以分为菜品分类和套餐分类</li><li>新添加的分类状态默认为“禁用”</li></ul><h3 id="接口设计-3"><a href="#接口设计-3" class="headerlink" title="接口设计"></a>接口设计</h3><p>根据上述原型图分析，菜品分类模块共涉及6个接口。</p><ul><li>新增分类</li><li>分类分页查询</li><li>根据id删除分类</li><li>修改分类</li><li>启用禁用分类</li><li>根据类型查询分类</li></ul><p><strong>1). 新增分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094733102.png" class="" alt="image-20250716094733102"><p><strong>2). 分类分页查询</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094804295.png" class="" alt="image-20250716094804295"><p><strong>3). 根据id删除分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094816303.png" class="" alt="image-20250716094816303"><p><strong>4). 修改分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094830240.png" class="" alt="image-20250716094830240"><p><strong>5). 启用禁用分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094843290.png" class="" alt="image-20250716094843290"><p><strong>6). 根据类型查询分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716094855582.png" class="" alt="image-20250716094855582"><h3 id="表设计-1"><a href="#表设计-1" class="headerlink" title="表设计"></a>表设计</h3><p><strong>category表结构：</strong></p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>自增</td></tr><tr><td>name</td><td>varchar(32)</td><td>分类名称</td><td>唯一</td></tr><tr><td>type</td><td>int</td><td>分类类型</td><td>1菜品分类 2套餐分类</td></tr><tr><td>sort</td><td>int</td><td>排序字段</td><td>用于分类数据的排序</td></tr><tr><td>status</td><td>int</td><td>状态</td><td>1启用 0禁用</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>update_time</td><td>datetime</td><td>最后修改时间</td><td></td></tr><tr><td>create_user</td><td>bigint</td><td>创建人id</td><td></td></tr><tr><td>update_user</td><td>bigint</td><td>最后修改人id</td><td></td></tr></tbody></table><h2 id="代码导入"><a href="#代码导入" class="headerlink" title="代码导入"></a>代码导入</h2><p>进入到sky-server模块中</p><h3 id="Mapper层-3"><a href="#Mapper层-3" class="headerlink" title="Mapper层"></a>Mapper层</h3><p><strong>DishMapper.java</strong></p><pre><code class="language-java">package com.sky.mapper;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;@Mapperpublic interface DishMapper &#123;    /**     * 根据分类id查询菜品数量     * @param categoryId     * @return     */    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)    Integer countByCategoryId(Long categoryId);&#125;</code></pre><p><strong>SetmealMapper.java</strong></p><pre><code class="language-java">package com.sky.mapper;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;@Mapperpublic interface SetmealMapper &#123;    /**     * 根据分类id查询套餐的数量     * @param id     * @return     */    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)    Integer countByCategoryId(Long id);&#125;</code></pre><p><strong>CategoryMapper.java</strong></p><pre><code class="language-java">package com.sky.mapper;import com.github.pagehelper.Page;import com.sky.dto.CategoryPageQueryDTO;import com.sky.entity.Category;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface CategoryMapper &#123;    /**     * 插入数据     * @param category     */    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +            &quot; VALUES&quot; +            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)    void insert(Category category);    /**     * 分页查询     * @param categoryPageQueryDTO     * @return     */    Page&lt;Category&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);    /**     * 根据id删除分类     * @param id     */    @Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)    void deleteById(Long id);    /**     * 根据id修改分类     * @param category     */    void update(Category category);    /**     * 根据类型查询分类     * @param type     * @return     */    List&lt;Category&gt; list(Integer type);&#125;</code></pre><p><strong>CategoryMapper.xml</strong>,进入到resources&#x2F;mapper目录下</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sky.mapper.CategoryMapper&quot;&gt;    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Category&quot;&gt;        select * from category        &lt;where&gt;            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)            &lt;/if&gt;            &lt;if test=&quot;type != null&quot;&gt;                and type = #&#123;type&#125;            &lt;/if&gt;        &lt;/where&gt;        order by sort asc , create_time desc    &lt;/select&gt;    &lt;update id=&quot;update&quot; parameterType=&quot;Category&quot;&gt;        update category        &lt;set&gt;            &lt;if test=&quot;type != null&quot;&gt;                type = #&#123;type&#125;,            &lt;/if&gt;            &lt;if test=&quot;name != null&quot;&gt;                name = #&#123;name&#125;,            &lt;/if&gt;            &lt;if test=&quot;sort != null&quot;&gt;                sort = #&#123;sort&#125;,            &lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;                status = #&#123;status&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateTime != null&quot;&gt;                update_time = #&#123;updateTime&#125;,            &lt;/if&gt;            &lt;if test=&quot;updateUser != null&quot;&gt;                update_user = #&#123;updateUser&#125;            &lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;    &lt;/update&gt;    &lt;select id=&quot;list&quot; resultType=&quot;Category&quot;&gt;        select * from category        where status = 1        &lt;if test=&quot;type != null&quot;&gt;            and type = #&#123;type&#125;        &lt;/if&gt;        order by sort asc,create_time desc    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="5-2-2-Service层"><a href="#5-2-2-Service层" class="headerlink" title="5.2.2 Service层"></a>5.2.2 Service层</h3><p><strong>CategoryService.java</strong></p><pre><code class="language-java">package com.sky.service;import com.sky.dto.CategoryDTO;import com.sky.dto.CategoryPageQueryDTO;import com.sky.entity.Category;import com.sky.result.PageResult;import java.util.List;public interface CategoryService &#123;    /**     * 新增分类     * @param categoryDTO     */    void save(CategoryDTO categoryDTO);    /**     * 分页查询     * @param categoryPageQueryDTO     * @return     */    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);    /**     * 根据id删除分类     * @param id     */    void deleteById(Long id);    /**     * 修改分类     * @param categoryDTO     */    void update(CategoryDTO categoryDTO);    /**     * 启用、禁用分类     * @param status     * @param id     */    void startOrStop(Integer status, Long id);    /**     * 根据类型查询分类     * @param type     * @return     */    List&lt;Category&gt; list(Integer type);&#125;</code></pre><p><strong>EmployeeServiceImpl.java</strong></p><pre><code class="language-java">package com.sky.service.impl;import com.github.pagehelper.Page;import com.github.pagehelper.PageHelper;import com.sky.constant.MessageConstant;import com.sky.constant.PasswordConstant;import com.sky.constant.StatusConstant;import com.sky.context.BaseContext;import com.sky.dto.EmployeeDTO;import com.sky.dto.EmployeeLoginDTO;import com.sky.dto.EmployeePageQueryDTO;import com.sky.entity.Employee;import com.sky.exception.AccountLockedException;import com.sky.exception.AccountNotFoundException;import com.sky.exception.PasswordErrorException;import com.sky.mapper.EmployeeMapper;import com.sky.result.PageResult;import com.sky.service.EmployeeService;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.DigestUtils;import java.time.LocalDateTime;import java.util.List;@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123;    @Autowired    private EmployeeMapper employeeMapper;    /**     * 员工登录     *     * @param employeeLoginDTO     * @return     */    public Employee login(EmployeeLoginDTO employeeLoginDTO) &#123;        String username = employeeLoginDTO.getUsername();        String password = employeeLoginDTO.getPassword();        //1、根据用户名查询数据库中的数据        Employee employee = employeeMapper.getByUsername(username);        //2、处理各种异常情况（用户名不存在、密码不对、账号被锁定）        if (employee == null) &#123;            //账号不存在            throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND);        &#125;        //密码比对        // TODO 后期需要进行md5加密，然后再进行比对        password = DigestUtils.md5DigestAsHex(password.getBytes());        if (!password.equals(employee.getPassword())) &#123;            //密码错误            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);        &#125;        if (employee.getStatus() == StatusConstant.DISABLE) &#123;            //账号被锁定            throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED);        &#125;        //3、返回实体对象        return employee;    &#125;    /**     * 新增员工     *     * @param employeeDTO     */    public void save(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        //对象属性拷贝        BeanUtils.copyProperties(employeeDTO, employee);        //设置账号的状态，默认正常状态 1表示正常 0表示锁定        employee.setStatus(StatusConstant.ENABLE);        //设置密码，默认密码123456        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));        //设置当前记录的创建时间和修改时间        employee.setCreateTime(LocalDateTime.now());        employee.setUpdateTime(LocalDateTime.now());        //设置当前记录创建人id和修改人id        employee.setCreateUser(BaseContext.getCurrentId());//目前写个假数据，后期修改        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.insert(employee);    &#125;    /**     * 分页查询     *     * @param employeePageQueryDTO     * @return     */    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;        // select * from employee limit 0,10        //开始分页查询        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());        Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);        long total = page.getTotal();        List&lt;Employee&gt; records = page.getResult();        return new PageResult(total, records);    &#125;    /**     * 启用禁用员工账号     *     * @param status     * @param id     */    public void startOrStop(Integer status, Long id) &#123;        Employee employee = Employee.builder()                .status(status)                .id(id)                .build();        employeeMapper.update(employee);    &#125;    /**     * 根据id查询员工     *     * @param id     * @return     */    public Employee getById(Long id) &#123;        Employee employee = employeeMapper.getById(id);        employee.setPassword(&quot;****&quot;);        return employee;    &#125;    /**     * 编辑员工信息     *     * @param employeeDTO     */    public void update(EmployeeDTO employeeDTO) &#123;        Employee employee = new Employee();        BeanUtils.copyProperties(employeeDTO, employee);        employee.setUpdateTime(LocalDateTime.now());        employee.setUpdateUser(BaseContext.getCurrentId());        employeeMapper.update(employee);    &#125;&#125;</code></pre><h3 id="5-2-3-Controller层"><a href="#5-2-3-Controller层" class="headerlink" title="5.2.3 Controller层"></a>5.2.3 Controller层</h3><p><strong>CategoryController.java</strong></p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.dto.CategoryDTO;import com.sky.dto.CategoryPageQueryDTO;import com.sky.entity.Category;import com.sky.result.PageResult;import com.sky.result.Result;import com.sky.service.CategoryService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * 分类管理 */@RestController@RequestMapping(&quot;/admin/category&quot;)@Api(tags = &quot;分类相关接口&quot;)@Slf4jpublic class CategoryController &#123;    @Autowired    private CategoryService categoryService;    /**     * 新增分类     * @param categoryDTO     * @return     */    @PostMapping    @ApiOperation(&quot;新增分类&quot;)    public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123;        log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO);        categoryService.save(categoryDTO);        return Result.success();    &#125;    /**     * 分类分页查询     * @param categoryPageQueryDTO     * @return     */    @GetMapping(&quot;/page&quot;)    @ApiOperation(&quot;分类分页查询&quot;)    public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO)&#123;        log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO);        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);        return Result.success(pageResult);    &#125;    /**     * 删除分类     * @param id     * @return     */    @DeleteMapping    @ApiOperation(&quot;删除分类&quot;)    public Result&lt;String&gt; deleteById(Long id)&#123;        log.info(&quot;删除分类：&#123;&#125;&quot;, id);        categoryService.deleteById(id);        return Result.success();    &#125;    /**     * 修改分类     * @param categoryDTO     * @return     */    @PutMapping    @ApiOperation(&quot;修改分类&quot;)    public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO)&#123;        categoryService.update(categoryDTO);        return Result.success();    &#125;    /**     * 启用、禁用分类     * @param status     * @param id     * @return     */    @PostMapping(&quot;/status/&#123;status&#125;&quot;)    @ApiOperation(&quot;启用禁用分类&quot;)    public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123;        categoryService.startOrStop(status,id);        return Result.success();    &#125;    /**     * 根据类型查询分类     * @param type     * @return     */    @GetMapping(&quot;/list&quot;)    @ApiOperation(&quot;根据类型查询分类&quot;)    public Result&lt;List&lt;Category&gt;&gt; list(Integer type)&#123;        List&lt;Category&gt; list = categoryService.list(type);        return Result.success(list);    &#125;&#125;</code></pre><p>全部导入完毕后，进行编译</p><h2 id="前后端联调测试"><a href="#前后端联调测试" class="headerlink" title="前后端联调测试"></a>前后端联调测试</h2><p><strong>1):新增分类</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101043331.png" class="" alt="image-20250716101043331"><p><strong>2):分页查询</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101201565.png" class="" alt="image-20250716101201565"><p><strong>3):分类查询</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101311029.png" class="" alt="image-20250716101311029"><p><strong>4):启用禁用</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101345295.png" class="" alt="image-20250716101345295"><p><strong>5):回显信息到修改界面</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101436324.png" class="" alt="image-20250716101436324"><p>修改后：</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101557511.png" class="" alt="image-20250716101557511"><p><strong>6):删除</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101636409.png" class="" alt="image-20250716101636409"><p>删除后：</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%BA%8C%EF%BC%89%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/image-20250716101704023.png" class="" alt="image-20250716101704023">]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖（一）环境准备</title>
      <link href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
      <url>/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>我的gitee仓库，内涵源代码<a href="https://gitee.com/zhouhuiqiang5704/sky-cqwm.git">https://gitee.com/zhouhuiqiang5704/sky-cqwm.git</a></p></blockquote><h1 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>完成需求规格说明书、产品原型编写。  </p><p><strong>需求规格说明书</strong>： 一般来说就是使用 Word 文档来描述当前项目的各个组成部分，如：系统定义、应用环境、功能规格、性能需求等，都会在文档中描述。<strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110354550.png" class="" alt="image-20250715110354550"><p><strong>产品原型</strong>：一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。 <strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110407886.png" class="" alt="image-20250715110407886"><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计的内容包含 UI设计、数据库设计、接口设计。</p><p><strong>UI设计</strong>：用户界面的设计，主要设计项目的页面效果，小到一个按钮，大到一个页面布局，还有人机交互逻辑的体现。</p><p><strong>数据库设计</strong>：需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段。<strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110432975.png" class="" alt="image-20250715110432975"><p><strong>接口设计</strong>：通过分析原型图，首先，粗粒度地分析每个页面有多少接口，然后，再细粒度地分析每个接口的传入参数，返回值参数，同时明确接口路径及请求方式。<strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110442295.png" class="" alt="image-20250715110442295"><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编写项目代码、并完成单元测试。</p><p>项目代码编写：作为软件开发工程师，我们需要对项目的模块功能分析后，进行编码实现。</p><p>单元测试：编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。</p><p><strong>例如：</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110450986.png" class="" alt="image-20250715110450986"><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。</p><h2 id="上线运维"><a href="#上线运维" class="headerlink" title="上线运维"></a>上线运维</h2><p>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。</p><h1 id="苍穹外卖（一）环境准备项目介绍"><a href="#苍穹外卖（一）环境准备项目介绍" class="headerlink" title="苍穹外卖（一）环境准备项目介绍"></a>苍穹外卖（一）环境准备项目介绍</h1><h2 id="业务功能模块"><a href="#业务功能模块" class="headerlink" title="业务功能模块"></a>业务功能模块</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110642407.png" class="" alt="image-20250715110642407"><p><strong>1). 管理端功能</strong></p><p>员工登录&#x2F;退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 ，数据统计，来单提醒。</p><p><strong>2). 用户端功能</strong></p><p> 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 支付、分类及菜品浏览。</p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><p><strong>1). 管理端</strong></p><p><strong>餐饮企业内部员工使用。</strong> 主要功能有: </p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>内部员工必须登录后,才可以访问系统管理后台</td></tr><tr><td>员工管理</td><td>管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能</td></tr><tr><td>分类管理</td><td>主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护， 包含查询、新增、修改、删除等功能</td></tr><tr><td>菜品管理</td><td>主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>套餐管理</td><td>主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>订单管理</td><td>主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能</td></tr><tr><td>数据统计</td><td>主要完成对餐厅的各类数据统计，如营业额、用户数量、订单等</td></tr></tbody></table><p><strong>2). 用户端</strong></p><p>**移动端应用主要提供给消费者使用。**主要功能有:</p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>用户需要通过微信授权后登录使用小程序进行点餐</td></tr><tr><td>点餐-菜单</td><td>在点餐界面需要展示出菜品分类&#x2F;套餐分类, 并根据当前选择的分类加载其中的菜品信息, 供用户查询选择</td></tr><tr><td>点餐-购物车</td><td>用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除购物车、清空购物车等功能</td></tr><tr><td>订单支付</td><td>用户选完菜品&#x2F;套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支付</td></tr><tr><td>个人信息</td><td>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查询历史订单数据</td></tr></tbody></table><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20221106185646994.png" class="" alt="image-20221106185646994"><p><strong>1). 用户层</strong></p><p>本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI、apache echarts(展示图表)等技术。而在构建移动端应用时，我们会使用到微信小程序。</p><p><strong>2). 网关层</strong></p><p>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。</p><p><strong>3). 应用层</strong></p><p>SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开发。</p><p>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。</p><p>Spring Task:  由Spring提供的定时任务框架。</p><p>httpclient:  主要实现了对http请求的发送。</p><p>Spring Cache:  由Spring提供的数据缓存框架</p><p>JWT:  用于对应用程序上的用户进行身份验证的标记。</p><p>阿里云OSS:  对象存储服务，在项目中主要存储文件，如图片等。</p><p>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</p><p>POI:  封装了对Excel表格的常用操作。</p><p>WebSocket: 一种通信网络协议，使客户端和服务器之间的数据交换更加简单，用于项目的来单、催单功能实现。</p><p><strong>4). 数据层</strong></p><p>MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。</p><p>Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存。</p><p>Mybatis： 本项目持久层将会使用Mybatis开发。</p><p>pagehelper:  分页插件。</p><p>spring data redis:  简化java代码操作Redis的API。</p><p><strong>5). 工具</strong></p><p>git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。</p><p>maven: 项目构建工具。</p><p>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</p><p>postman:  接口测工具，模拟用户发起的各类HTTP请求，获取对应的响应结果。</p><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><p>开发环境搭建主要包含<strong>前端环境</strong>和<strong>后端环境</strong>两部分。作为服务端开发工程师， 我们重心放在后端的业务代码上， 前端的页面我们只需要导入资料中的nginx。</p><h2 id="前端开发环境"><a href="#前端开发环境" class="headerlink" title="前端开发环境"></a>前端开发环境</h2><p>管理端：前端资源</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093009864.png" class="" alt="image-20250715093009864"><p>双击 nginx.exe 即可启动 nginx 服务，访问端口号为 80</p><p><a href="http://localhost/">http://localhost:80</a></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093119330.png" class="" alt="image-20250715093119330"><h2 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h2><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093248485.png" class="" alt="image-20250715093248485"><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093535835.png" class="" alt="image-20250715093535835"><table><thead><tr><th><strong>序号</strong></th><th align="left"><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1</td><td align="left">sky-take-out</td><td><strong>maven父工程</strong>，统一管理<strong>依赖版本</strong>，聚合其他子模块</td></tr><tr><td>2</td><td align="left">sky-common</td><td>子模块，存放公共类，例如：工具类、常量类、异常类等</td></tr><tr><td>3</td><td align="left">sky-pojo</td><td>子模块，存放实体类、VO、DTO等</td></tr><tr><td>4</td><td align="left">sky-server</td><td>子模块，后端服务，存放配置文件、Controller、Service、Mapper等</td></tr></tbody></table><h4 id="sky-common"><a href="#sky-common" class="headerlink" title="sky-common"></a>sky-common</h4><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093730491.png" class="" alt="image-20250715093730491"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>constant</td><td>存放相关常量类</td></tr><tr><td>context</td><td>存放上下文类</td></tr><tr><td>enumeration</td><td>项目的枚举类存储</td></tr><tr><td>exception</td><td>存放自定义异常类</td></tr><tr><td>json</td><td>处理json转换的类</td></tr><tr><td>properties</td><td>存放SpringBoot相关的配置属性类</td></tr><tr><td>result</td><td>返回结果类的封装</td></tr><tr><td>utils</td><td>常用工具类</td></tr></tbody></table><h4 id="sky-pojo"><a href="#sky-pojo" class="headerlink" title="sky-pojo"></a>sky-pojo</h4><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093821373.png" class="" alt="image-20250715093821373"><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Entity</td><td>实体，通常和数据库中的表对应</td></tr><tr><td>DTO</td><td>数据传输对象，通常用于程序中各层之间传递数据</td></tr><tr><td>VO</td><td>视图对象，为前端展示数据提供的对象</td></tr><tr><td>POJO</td><td>普通Java对象，只有属性和对应的getter和setter</td></tr></tbody></table><h4 id="sky-server"><a href="#sky-server" class="headerlink" title="sky-server"></a>sky-server</h4><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715093858876.png" class="" alt="image-20250715093858876"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>config</td><td>存放配置类</td></tr><tr><td>controller</td><td>存放controller类</td></tr><tr><td>interceptor</td><td>存放拦截器类</td></tr><tr><td>mapper</td><td>存放mapper接口</td></tr><tr><td>service</td><td>存放service类</td></tr><tr><td>SkyApplication</td><td>启动类</td></tr></tbody></table><h2 id="git版本控制-远程推送仓库"><a href="#git版本控制-远程推送仓库" class="headerlink" title="git版本控制-远程推送仓库"></a>git版本控制-远程推送仓库</h2><p><strong>1). 创建Git本地仓库</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110704459.png" class="" alt="image-20250715110704459"><p>当Idea中出现：</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715094309776.png" class="" alt="image-20250715094309776"><p>说明本地仓库创建成功。</p><p><strong>2).推送初始代码工程</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715095355931.png" class="" alt="image-20250715095355931"><p><strong>3).连接远程仓库</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715095657061.png" class="" alt="image-20250715095657061"><p><strong>之后会让你输入凭证（gitee账号密码）</strong>，然后就可以看见仓库中刚刚推送的文件了。</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715095937973.png" class="" alt="image-20250715095937973"><h2 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h2><p>执行sql文件</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715100224269.png" class="" alt="image-20250715100224269"><table><thead><tr><th><strong>序号</strong></th><th><strong>表名</strong></th><th><strong>中文名</strong></th></tr></thead><tbody><tr><td>1</td><td>employee</td><td>员工表</td></tr><tr><td>2</td><td>category</td><td>分类表</td></tr><tr><td>3</td><td>dish</td><td>菜品表</td></tr><tr><td>4</td><td>dish_flavor</td><td>菜品口味表</td></tr><tr><td>5</td><td>setmeal</td><td>套餐表</td></tr><tr><td>6</td><td>setmeal_dish</td><td>套餐菜品关系表</td></tr><tr><td>7</td><td>user</td><td>用户表</td></tr><tr><td>8</td><td>address_book</td><td>地址表</td></tr><tr><td>9</td><td>shopping_cart</td><td>购物车表</td></tr><tr><td>10</td><td>orders</td><td>订单表</td></tr><tr><td>11</td><td>order_detail</td><td>订单明细表</td></tr></tbody></table><h2 id="前后联调"><a href="#前后联调" class="headerlink" title="前后联调"></a>前后联调</h2><p><strong>别忘记修改数据库配置</strong></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715100736241.png" class="" alt="image-20250715100736241"><p>访问地址：<a href="http://localhost/#/login">http://localhost:80/#/login</a></p><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：</p><ol><li>使得前后端分离开发更加方便，有利于团队协作</li><li>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</li></ol><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>目前，一般都使用knife4j框架。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><p>导入 knife4j 的maven坐标</p><p>在pom.xml中添加依赖</p><pre><code class="language-xml">&lt;dependency&gt;   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>在配置类中加入 knife4j 相关配置</p><p>WebMvcConfiguration.java</p><pre><code class="language-java">/**     * 通过knife4j生成接口文档     * @return*/    @Bean    public Docket docket() &#123;        ApiInfo apiInfo = new ApiInfoBuilder()                .title(&quot;苍穹外卖（一）环境准备项目接口文档&quot;)                .version(&quot;2.0&quot;)                .description(&quot;苍穹外卖（一）环境准备项目接口文档&quot;)                .build();        Docket docket = new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo)                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))                .paths(PathSelectors.any())                .build();        return docket;    &#125;</code></pre></li><li><p>设置静态资源映射，否则接口文档页面无法访问</p><p>WebMvcConfiguration.java</p><pre><code class="language-java">/**     * 设置静态资源映射     * @param registry*/protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);&#125;</code></pre></li><li><p>访问测试</p><p>接口文档访问路径为 <a href="http://ip:port/doc.html">http://ip:port/doc.html</a> —&gt; <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715110843996.png" class="" alt="image-20250715110843996"><p>接口测试:测试登录功能</p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715111011456.png" class="" alt="image-20250715111011456"></li></ol><p>**思考：**通过 Swagger 就可以生成接口文档，那么我们就不需要 Yapi 了？</p><p>1、Yapi 是设计阶段使用的工具，管理和维护接口</p><p>2、Swagger 在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table><p>接下来，使用上述注解，生成可读性更好的接口文档</p><p>在sky-pojo模块中</p><p>EmployeeLoginDTO.java</p><pre><code class="language-java">package com.sky.dto;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.io.Serializable;@Data@ApiModel(description = &quot;员工登录时传递的数据模型&quot;)public class EmployeeLoginDTO implements Serializable &#123;    @ApiModelProperty(&quot;用户名&quot;)    private String username;    @ApiModelProperty(&quot;密码&quot;)    private String password;&#125;</code></pre><p>EmployeeLoginVo.java</p><pre><code class="language-java">package com.sky.vo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@Builder@NoArgsConstructor@AllArgsConstructor@ApiModel(description = &quot;员工登录返回的数据格式&quot;)public class EmployeeLoginVO implements Serializable &#123;    @ApiModelProperty(&quot;主键值&quot;)    private Long id;    @ApiModelProperty(&quot;用户名&quot;)    private String userName;    @ApiModelProperty(&quot;姓名&quot;)    private String name;    @ApiModelProperty(&quot;jwt令牌&quot;)    private String token;&#125;</code></pre><p>在sky-server模块中</p><p>EmployeeController.java</p><pre><code class="language-java">package com.sky.controller.admin;import com.sky.constant.JwtClaimsConstant;import com.sky.dto.EmployeeLoginDTO;import com.sky.entity.Employee;import com.sky.properties.JwtProperties;import com.sky.result.Result;import com.sky.service.EmployeeService;import com.sky.utils.JwtUtil;import com.sky.vo.EmployeeLoginVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;/** * 员工管理 */@RestController@RequestMapping(&quot;/admin/employee&quot;)@Slf4j@Api(tags = &quot;员工相关接口&quot;)public class EmployeeController &#123;    @Autowired    private EmployeeService employeeService;    @Autowired    private JwtProperties jwtProperties;    /**     * 登录     *     * @param employeeLoginDTO     * @return     */    @PostMapping(&quot;/login&quot;)    @ApiOperation(value = &quot;员工登录&quot;)    public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123;        //..............            &#125;    /**     * 退出     *     * @return     */    @PostMapping(&quot;/logout&quot;)    @ApiOperation(&quot;员工退出&quot;)    public Result&lt;String&gt; logout() &#123;        return Result.success();    &#125;&#125;</code></pre><p>启动服务：访问<a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><img src="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-20250715111316655.png" class="" alt="image-20250715111316655">]]></content>
      
      
      <categories>
          
          <category> 实战项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网SQL刷题总结</title>
      <link href="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="总结-基础知识"><a href="#总结-基础知识" class="headerlink" title="总结-基础知识"></a>总结-基础知识</h1><blockquote><p><a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=199">牛客网在线编程_SQL篇_SQL快速入门</a></p></blockquote><h2 id="去重复数据"><a href="#去重复数据" class="headerlink" title="去重复数据"></a>去重复数据</h2><blockquote><p>关键字：<code>distinct</code></p></blockquote><pre><code class="language-sql">select distinct university from user_profile</code></pre><h2 id="过滤空值"><a href="#过滤空值" class="headerlink" title="过滤空值"></a>过滤空值</h2><pre><code class="language-sql">where 列名 is not &#39;null&#39; where 列名 != &#39;null&#39;where 列名 &lt;&gt; &#39;null&#39; </code></pre><h2 id="多个匹配值"><a href="#多个匹配值" class="headerlink" title="多个匹配值"></a>多个匹配值</h2><blockquote><p>关键字：<code>in</code></p></blockquote><pre><code class="language-sql">select device_id,gender,age,university,gpafrom user_profilewhere university in (&#39;北京大学&#39;,&#39;复旦大学&#39;,&#39;山东大学&#39;) </code></pre><h2 id="模糊查询（匹配字符串）"><a href="#模糊查询（匹配字符串）" class="headerlink" title="模糊查询（匹配字符串）"></a>模糊查询（匹配字符串）</h2><blockquote><p>关键字：<code>like</code>   或者   <code>not like</code></p></blockquote><pre><code class="language-sql">select device_id,age,universityfrom user_profilewhere university like &#39;北京%&#39;</code></pre><blockquote><p>北京%：列名以北京开头</p><p>%北京：列名以北京结束</p><p>%北京%：列名中包括北京</p></blockquote><h2 id="MAX-最大函数值"><a href="#MAX-最大函数值" class="headerlink" title="MAX()最大函数值"></a>MAX()最大函数值</h2><blockquote><p>关键字：max()</p></blockquote><pre><code class="language-sql">select max(gpa) as gpafrom user_profilewhere university = &#39;复旦大学&#39;</code></pre><h2 id="avg-求平均值"><a href="#avg-求平均值" class="headerlink" title="avg()求平均值"></a>avg()求平均值</h2><pre><code class="language-sql">select  count(gender) as male_num,round(avg(gpa),1) as avg_gpafrom user_profilewhere gender = &#39;male&#39;</code></pre><h2 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round()四舍五入"></a>round()四舍五入</h2><blockquote><p><code>round(avg(gpa),1)</code>其中第二个参数表示保留一位小数</p></blockquote><pre><code class="language-sql">select  count(gender) as male_num,round(avg(gpa),1) as avg_gpafrom user_profilewhere gender = &#39;male&#39;</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote><p>关键字：<code>order by</code> 字段 ASC</p><p>​ASC:默认  升序</p><p>​DESC:  降序</p><p>——对多个字段排序时，按照书写的先后顺序依次排列</p></blockquote><pre><code class="language-sql">select    gender,university,count(device_id) as user_num,round(avg(active_days_within_30),1) as avg_active_day,round(avg(question_cnt),1) as avg_question_cntfrom    user_profilegroup by gender,universityorder by gender ASC,university ASC</code></pre><blockquote><p>先按照gender(性别)排序，在每个性别里面再按照university字段排序</p></blockquote><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><blockquote><p>关键字：<code>group by</code> 字段</p><p>多个字段使用<code>,</code>分隔</p></blockquote><pre><code class="language-sql">select    gender,university,count(device_id) as user_num,round(avg(active_days_within_30),1) as avg_active_day,round(avg(question_cnt),1) as avg_question_cntfrom    user_profilegroup by gender,universityorder by gender ASC,university ASC</code></pre><h3 id="对分组的字段，条件查询"><a href="#对分组的字段，条件查询" class="headerlink" title="对分组的字段，条件查询"></a>对分组的字段，条件查询</h3><blockquote><p>关键字：having    </p><p>当对字段进行<code>group by</code>分组之后，就不能使用where来限制条件，必须使用having</p></blockquote><pre><code class="language-sql">select    university,    round(avg(question_cnt), 3) as avg_question_cnt,    round(avg(answer_cnt), 3) as avg_answer_cntfrom    user_profilegroup by    universityhaving     avg(question_cnt)&lt;5 or avg(answer_cnt) &lt;20</code></pre><h2 id="多表连接-21-25"><a href="#多表连接-21-25" class="headerlink" title="多表连接 21-25"></a>多表连接 21-25</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote><p>注意点：子查询中不存在多表之间的联系，是使用<code>in</code>等关键字匹配字段的值来连接。</p><p>即 <code>from</code>关键字后都只有一个表</p></blockquote><pre><code class="language-sql">select device_id,question_id,resultfrom    question_practice_detailwhere question_practice_detail.device_id in(    select device_id    from user_profile    where university = &#39;浙江大学&#39;)</code></pre><h3 id="内连接–INNER-JOIN"><a href="#内连接–INNER-JOIN" class="headerlink" title="内连接–INNER JOIN"></a>内连接–INNER JOIN</h3><blockquote><p>关键字：<code>INNER JOIN</code>  连接的表名  <code>on</code>  关联的字段</p><p>后续可使用<code>where</code>关键字作筛选</p></blockquote><pre><code class="language-sql">select question_practice_detail.device_id,question_id,resultfrom    question_practice_detailInner JOIN user_profile on question_practice_detail.device_id = user_profile.device_idwhere university = &#39;浙江大学&#39;</code></pre><blockquote><p>在使用多个<code>INNER JOIN</code>关键字内连接其他表时，第一个表的字段与第二个表的字段连接，第二个表的字段与第三个表的字段连接。</p></blockquote><h3 id="左右连接29"><a href="#左右连接29" class="headerlink" title="左右连接29"></a>左右连接29</h3><blockquote><p>当结果中出现某一列需要输出为<code>null</code>的字段值，这么就使用左右连接</p></blockquote><pre><code class="language-sql">select Products.prod_name,OrderItems.order_numfrom Productsleft JOIN OrderItemson Products.prod_id = OrderItems.prod_id order by prod_name</code></pre><blockquote><img src="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/image-20250711085747146.png" class="" alt="image-20250711085747146"></blockquote><pre><code class="language-sql">SELECT    ROUND(        SUM(CASE WHEN p2.device_id IS NOT NULL THEN 1                ELSE 0            END        ) / COUNT(*),        4    ) AS avg_ret    # 也可以表示为    # COUNT(q2.device_id) / COUNT(q1.device_id) AS avg_ret    # 对于count（）函数计数时不会统计值为null的条目    # 因为是最左连接，会将p1表中的数据都显示，而只会显示符合条件的p2中留存的数据，否则为空        # 也就是说对于同一个人来说，第一天刷题，才会有p1.device_id。第二天刷题了，才会有p2.device_id，否则为空FROM    (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p1LEFT JOIN (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p2 ON p1.device_id = p2.device_id AND p2.date = DATE_ADD(p1.date, INTERVAL 1 DAY);</code></pre><h3 id="内连接与左右连接的区别"><a href="#内连接与左右连接的区别" class="headerlink" title="内连接与左右连接的区别"></a>内连接与左右连接的区别</h3><table><thead><tr><th align="left">连接类型</th><th align="left">行为</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>INNER JOIN</strong></td><td align="left">只返回两个表中<strong>匹配的行</strong></td><td align="left">只关心两个表都存在的关联数据</td></tr><tr><td align="left"><strong>LEFT JOIN</strong></td><td align="left">返回<strong>左表所有行</strong> + 右表<strong>匹配的行</strong>（右表无匹配则补 <code>NULL</code>）</td><td align="left">即使右表没有匹配，也要保留左表数据</td></tr><tr><td align="left"><strong>RIGHT JOIN</strong></td><td align="left">返回<strong>右表所有行</strong> + 左表<strong>匹配的行</strong>（左表无匹配则补 <code>NULL</code>）</td><td align="left">即使左表没有匹配，也要保留右表数据</td></tr></tbody></table><h3 id="联合查询-25"><a href="#联合查询-25" class="headerlink" title="联合查询 25"></a>联合查询 25</h3><blockquote><p>关键字：<code>UNION ALL</code> 或<code>UNION</code></p><p><code>UNION</code>:表示将两个查询结果连接起来，并且<strong>去重</strong></p><p><code>UNION ALL</code>:表示将两个查询结果连接起来，但是不<strong>去重</strong></p></blockquote><pre><code class="language-sql">select device_id,gender,age,gpafrom user_profilewhere university = &#39;山东大学&#39;union ALLselect device_id,gender,age,gpafrom user_profilewhere gender = &#39;male</code></pre><blockquote><ul><li><strong>结果集</strong>：包含两类数据的并集：<ol><li>山东大学的所有学生（无论性别）。</li><li>所有男性学生（无论学校）。</li></ol></li><li><strong>重复数据</strong>：如果一个山东大学的学生同时也是男性，则该学生的记录会 <strong>出现两次</strong>（因为 <code>UNION ALL</code> 保留重复）。</li></ul></blockquote><h2 id="条件逻辑"><a href="#条件逻辑" class="headerlink" title="条件逻辑"></a>条件逻辑</h2><blockquote><p>关键字：</p><pre><code class="language-sql">CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... ELSE default_resultEND</code></pre><p>当符合条件condition1时，将他设置为result1</p></blockquote><pre><code class="language-sql">select    case        when            age &lt; 25            or age is null then &#39;25岁以下&#39;            else &#39;25岁及以上&#39;    end as age_cut,    count(device_id) as numberfrom    user_profileGROUP BY    age_cut</code></pre><h2 id="年月日函数28"><a href="#年月日函数28" class="headerlink" title="年月日函数28"></a>年月日函数28</h2><blockquote><p>date:2021-05-03</p><p><code> year(date)</code>:取出date数据中的年  2021</p><p><code>month(date)</code>:取出date数据中的月  05</p><p><code>day(date)</code>:取出date数据中的日 03</p></blockquote><pre><code class="language-sql">select day(date) as day,count(question_id) as question_cntfrom question_practice_detailwhere month(date) = 8 and year(date) = 2021group by date</code></pre><h2 id="Date函数29"><a href="#Date函数29" class="headerlink" title="Date函数29"></a>Date函数29</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_now.asp">NOW()</a></td><td align="left">返回当前的日期和时间</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_curdate.asp">CURDATE()</a></td><td align="left">返回当前的日期</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_curtime.asp">CURTIME()</a></td><td align="left">返回当前的时间</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date.asp">DATE()</a></td><td align="left">提取日期或日期&#x2F;时间表达式的日期部分</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_extract.asp">EXTRACT()</a></td><td align="left">返回日期&#x2F;时间按的单独部分</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date_add.asp">DATE_ADD()</a></td><td align="left">给日期添加指定的时间间隔</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date_sub.asp">DATE_SUB()</a></td><td align="left">从日期减去指定的时间间隔</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_datediff_mysql.asp">DATEDIFF()</a></td><td align="left">返回两个日期之间的天数</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/sql/func_date_format.asp">DATE_FORMAT()</a></td><td align="left">用不同的格式显示日期&#x2F;时间</td></tr></tbody></table><blockquote><p>date_add()函数：<code>DATE_ADD(date,INTERVAL expr type)</code></p><p>​<em>date</em> 参数是合法的日期表达式。<em>expr</em> 参数是您希望添加的时间间隔。type参数是day,mouth,year等值。</p><p>​如果希望向 “OrderDate” 添加 2 天，<code>DATE_ADD(OrderDate,INTERVAL 2 DAY)</code>。</p></blockquote><img src="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/image-20250709150940731.png" class="" alt="image-20250709150940731"><pre><code class="language-sql">SELECT    ROUND(        SUM(CASE WHEN p2.device_id IS NOT NULL THEN 1                ELSE 0            END        ) / COUNT(*),        4    ) AS avg_ret    # 也可以表示为    # COUNT(q2.device_id) / COUNT(q1.device_id) AS avg_ret    # 对于count（）函数计数时不会统计值为null的条目    # 因为是最左 连接，会将p1表中的数据都显示，而只会显示符合条件的p2中留存的数据，否则为空        # 也就是说对于同一个人来说，第一天刷题，才会有p1.device_id。第二天刷题了，才会有p2.device_id，否则为空FROM    (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p1LEFT JOIN (        SELECT             DISTINCT device_id,            date        FROM            question_practice_detail    ) p2 ON p1.device_id = p2.device_id AND p2.date = DATE_ADD(p1.date, INTERVAL 1 DAY);</code></pre><h2 id="字符串截取30-拼接，转大小写"><a href="#字符串截取30-拼接，转大小写" class="headerlink" title="字符串截取30,拼接，转大小写"></a>字符串截取30,拼接，转大小写</h2> <img src="/2025/07/14/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/image-20250709151301784.png" class="" alt="image-20250709151301784"><pre><code class="language-sql">SELECT SUBSTRING_INDEX(profile,&quot;,&quot;,-1) gender,COUNT(*) numberFROM user_submitGROUP BY gender;</code></pre><blockquote><ul><li>使用 <code>GROUP BY gender</code> 后，SQL 会先按 <code>gender</code> 分类，再分别计算每组的 <code>COUNT(*)</code>。</li></ul></blockquote><blockquote><pre><code class="language-sql">字符串的截取：substring(字符串，起始位置，截取字符数）取字符串左边 size个字符:left(column_name,int size)字符串的拼接：concat(字符串1，字符串2，字符串3,...)字母大写：upper(字符串）字母小写：lower(字符串）</code></pre></blockquote><h3 id="case语句-模糊查询-笨蛋题解"><a href="#case语句-模糊查询-笨蛋题解" class="headerlink" title="case语句+模糊查询&#x3D;笨蛋题解"></a>case语句+模糊查询&#x3D;笨蛋题解</h3><pre><code class="language-sql">select    case        when profile like &#39;%,male&#39; then &#39;male&#39;        when profile like &#39;%,female&#39; then &#39;female&#39;    end gender,    count(device_id) as numberfrom    user_submitgroup by    gender;</code></pre><h2 id="窗口函数33-41"><a href="#窗口函数33-41" class="headerlink" title="窗口函数33,41"></a>窗口函数33,41</h2><blockquote><p>窗口函数</p></blockquote><blockquote><pre><code class="language-sql">SELECT *, DENSE_RANK() OVER (PARTITION BY university ORDER BY gpa) AS drFROM user_profile</code></pre></blockquote><pre><code class="language-sql"># 严格连续编号，即使分数相同也分配不同序号。ROW_NUMBER()# 每个大学中GPA最低的所有学生（包括并列情况）：DENSE_RANK()SELECT device_id, university, gpaFROM (    SELECT *, DENSE_RANK() OVER (PARTITION BY university ORDER BY gpa) AS dr    FROM user_profile) AS univ_minWHERE dr = 1ORDER BY university</code></pre><blockquote><h3 id="一、聚合类窗口函数"><a href="#一、聚合类窗口函数" class="headerlink" title="一、聚合类窗口函数"></a><strong>一、聚合类窗口函数</strong></h3><pre><code>SUM(), AVG(), MIN(), MAX(), COUNT()</code></pre><h3 id="二、排名类窗口函数"><a href="#二、排名类窗口函数" class="headerlink" title="二、排名类窗口函数"></a>二、排名类窗口函数</h3><table><thead><tr><th>ROW_NUMBER()</th><th>行号（相同值不同号）</th><th>1,2,3,4</th></tr></thead><tbody><tr><td>RANK()</td><td>排名（相同值并列但留空）</td><td>1,2,2,4</td></tr><tr><td>DENSE_RANK()</td><td>密集排名（相同值并列无空）</td><td>1,2,2,3</td></tr></tbody></table><h3 id="三、偏移分析类窗口函数"><a href="#三、偏移分析类窗口函数" class="headerlink" title="三、偏移分析类窗口函数"></a>三、偏移分析类窗口函数</h3><pre><code class="language-sql">LAG(column, n) -- 访问前n行值LEAD(column, n) -- 访问后n行值FIRST_VALUE(column) -- 窗口第一行LAST_VALUE(column) -- 窗口最后一行</code></pre><h3 id="四、统计类窗口函数"><a href="#四、统计类窗口函数" class="headerlink" title="四、统计类窗口函数"></a>四、统计类窗口函数</h3><pre><code class="language-sql">PERCENT_RANK() -- 排名百分比 (0-1)CUME_DIST()   -- 累计分布 (0-1)STDDEV(), VAR() -- 标准差和方差</code></pre></blockquote><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="PARTITION-BY-——-分组处理"><a href="#PARTITION-BY-——-分组处理" class="headerlink" title="PARTITION BY —— 分组处理"></a><code>PARTITION BY</code> —— 分组处理</h4><ul><li>类似 <code>GROUP BY</code>，但<strong>不聚合</strong>，仅把行划分成若干组；</li><li>每组窗口函数单独计算；</li><li>可选，不写则默认全表一组。</li></ul><h4 id="ORDER-BY-——-窗口内排序"><a href="#ORDER-BY-——-窗口内排序" class="headerlink" title="ORDER BY —— 窗口内排序"></a><code>ORDER BY</code> —— 窗口内排序</h4><ul><li>决定行的先后顺序；</li><li>排序顺序直接影响如排名、前后行等函数计算；</li><li>必须写在 <code>OVER(...)</code> 内部，否则是整个结果集排序。</li></ul><h4 id="ROWS-BETWEEN-——-明确窗口范围"><a href="#ROWS-BETWEEN-——-明确窗口范围" class="headerlink" title="ROWS BETWEEN —— 明确窗口范围"></a><code>ROWS BETWEEN</code> —— 明确窗口范围</h4><table><thead><tr><th><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></th><th>从分区第一行到当前行（累计）</th></tr></thead><tbody><tr><td><code>ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</code></td><td>当前行、前一行、后一行</td></tr><tr><td><code>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code></td><td>当前行到最后一行</td></tr></tbody></table><blockquote><p>若不写 <code>ROWS</code>，窗口函数默认是“从分区首行到当前行”或整个分区（函数而异）</p></blockquote><h2 id="if条件表达34"><a href="#if条件表达34" class="headerlink" title="if条件表达34"></a>if条件表达34</h2><pre><code class="language-sql">IF(condition, value_if_true, value_if_false)这是一个条件表达式，类似于编程语言中的三元运算符：</code></pre><blockquote><pre><code class="language-sql">sum(if(qpd.result=&#39;right&#39;, 1, 0))</code></pre><ul><li><strong><code>qpd.result=&#39;right&#39;</code></strong>：条件判断，检查 <code>result</code> 字段是否等于 ‘right’</li><li><strong><code>1</code></strong>：如果条件为真（即 result&#x3D;’right’）时返回的值</li><li><strong><code>0</code></strong>：如果条件为假（即 result≠’right’）时返回的值</li></ul></blockquote><pre><code class="language-sql">select up.device_id,university,    count(question_id) as question_cnt,    sum(if(qpd.result=&#39;right&#39;, 1, 0)) as right_question_cntfrom user_profile as upleft join question_practice_detail as qpdon qpd.device_id = up.device_id and month(qpd.date) = 8where up.university = &#39;复旦大学&#39;group by up.device_id</code></pre><h2 id="正则表达式40"><a href="#正则表达式40" class="headerlink" title="正则表达式40"></a>正则表达式40</h2><blockquote><p>关键字：regexp</p></blockquote><blockquote><ol><li>电话号码必须是 10 位数字。</li><li>电话号码的第一位不能以 0 开头。</li><li>电话号码的格式可以是连续的 10 位数字，或以-分隔的格式（如123-456-7890）。</li></ol></blockquote><pre><code class="language-sql">select *from contactswhere phone_number regexp &#39;^[1-9][0-9]&#123;9&#125;$|^[1-9][0-9]&#123;2&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&#39;order by id ASC</code></pre><blockquote><p>这个正则表达式的作用如下：</p><ul><li>^ 表示匹配字符串的开头，$ 表示匹配字符串的结尾，确保整个字符串都符合指定的模式。</li><li>[1-9] 表示电话号码的第一位不能是 0，必须是 1 到 9 之间的数字。</li><li>[0-9]{9} 表示接下来的 9 位可以是任意数字，与开头的 [1-9] 组合形成一个完整的 10 位数字电话号码。</li><li>| 是正则表达式的“或”操作符，用于分隔两种不同的匹配模式。</li><li>^[1-9]{2}-[0-9]{3}-[0-9]{4}$ 表示电话号码可以是以 “-” 分隔的格式，其中第一部分是 3 位数字，第二部分是 3 位数字，第三部分是 4 位数字。</li></ul></blockquote><h2 id="数学函数42"><a href="#数学函数42" class="headerlink" title="数学函数42"></a>数学函数42</h2><table><thead><tr><th align="left">返回类型</th><th align="left">描述</th><th align="left">例子</th><th align="left">结果</th><th></th></tr></thead><tbody><tr><td align="left"><strong>abs(x)</strong></td><td align="left"></td><td align="left"><strong>绝对值</strong></td><td align="left"><strong>abs(-17.4)</strong></td><td><strong>17.4</strong></td></tr><tr><td align="left">cbrt(double)</td><td align="left"></td><td align="left">立方根</td><td align="left">cbrt(27.0)</td><td>3</td></tr><tr><td align="left"><strong>ceil(double&#x2F;numeric)</strong></td><td align="left"></td><td align="left"><strong>向上取整</strong></td><td align="left"><strong>ceil(-42.8)</strong></td><td><strong>-42</strong></td></tr><tr><td align="left">degrees(double)</td><td align="left"></td><td align="left">把弧度转为角度</td><td align="left">degrees(0.5)</td><td>28.6478897565412</td></tr><tr><td align="left">exp(double&#x2F;numeric)</td><td align="left"></td><td align="left">自然指数</td><td align="left">exp(1.0)</td><td>2.71828182845905</td></tr><tr><td align="left"><strong>floor(double&#x2F;numeric)</strong></td><td align="left"></td><td align="left"><strong>向下取整</strong></td><td align="left"><strong>floor(-42.8)</strong></td><td><strong>-43</strong></td></tr><tr><td align="left">ln(double&#x2F;numeric)</td><td align="left"></td><td align="left">自然对数</td><td align="left">ln(2.0)</td><td>0.693147180559945</td></tr><tr><td align="left">log(double&#x2F;numeric)</td><td align="left"></td><td align="left">10为底的对数</td><td align="left">log(100.0)</td><td>2</td></tr><tr><td align="left">log(b numeric,x numeric)</td><td align="left">numeric</td><td align="left">指定底数的对数</td><td align="left">log(2.0, 64.0)</td><td>6.0000000000</td></tr><tr><td align="left"><strong>mod(y, x)</strong></td><td align="left"></td><td align="left"><strong>取余数</strong></td><td align="left"><strong>mod(9,4)</strong></td><td><strong>1</strong></td></tr><tr><td align="left">pi()</td><td align="left">double</td><td align="left">“π”常量</td><td align="left">pi()</td><td>3.14159265358979</td></tr><tr><td align="left"><strong>power(a double, b double)</strong></td><td align="left"><strong>double</strong></td><td align="left"><strong>求a的b次幂</strong></td><td align="left"><strong>power(9.0, 3.0)</strong></td><td><strong>729</strong></td></tr><tr><td align="left">power(a numeric, b numeric)</td><td align="left">numeric</td><td align="left">求a的b次幂</td><td align="left">power(9.0, 3.0)</td><td>729</td></tr><tr><td align="left">radians(double)</td><td align="left">double</td><td align="left">把角度转为弧度</td><td align="left">radians(45.0)</td><td>0.785398163397448</td></tr><tr><td align="left">random()</td><td align="left">double</td><td align="left">0.0到1.0之间的随机数值</td><td align="left">random()</td><td></td></tr><tr><td align="left">round(double&#x2F;numeric)</td><td align="left"></td><td align="left">圆整为最接近的整数</td><td align="left">round(42.4)</td><td>42</td></tr><tr><td align="left"><strong>round(v numeric, s int)</strong></td><td align="left"><strong>numeric</strong></td><td align="left"><strong>圆整为s位小数数字</strong></td><td align="left"><strong>round(42.438,2)</strong></td><td><strong>42.44</strong></td></tr><tr><td align="left">sign(double&#x2F;numeric)</td><td align="left"></td><td align="left">参数的符号(-1,0,+1)</td><td align="left">sign(-8.4)</td><td>-1</td></tr><tr><td align="left"><strong>sqrt(double&#x2F;numeric)</strong></td><td align="left"></td><td align="left"><strong>平方根</strong></td><td align="left"><strong>sqrt(2.0)</strong></td><td><strong>1.4142135623731</strong></td></tr><tr><td align="left">trunc(double&#x2F;numeric)</td><td align="left"></td><td align="left"><strong>截断</strong>(向零靠近)</td><td align="left">trunc(42.8)</td><td>42</td></tr><tr><td align="left">trunc(v numeric, s int)</td><td align="left">numeric</td><td align="left"><strong>截断</strong>为s小数位置的数字</td><td align="left">trunc(42.438,2)</td><td>42.43</td></tr></tbody></table><h2 id="Limit关键字"><a href="#Limit关键字" class="headerlink" title="Limit关键字"></a>Limit关键字</h2><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><blockquote><p>关键字：<code>LIMIT pageSize OFFSET (pageNumber - 1) * pageSize</code></p></blockquote><pre><code class="language-sql">SELECT * FROM CustomersLIMIT 10 OFFSET 20;</code></pre><blockquote><p>表示1：</p><ul><li>跳过前 20 行（OFFSET 20）</li><li>返回接下来的 10 行</li></ul><p>等价于取出第 21～30 行。</p></blockquote><blockquote><p>表示2：</p><ul><li>第 3页，每页 10 条数据</li></ul></blockquote><h3 id="取前-N-条最大-最小的值"><a href="#取前-N-条最大-最小的值" class="headerlink" title="取前 N 条最大&#x2F;最小的值"></a>取前 N 条最大&#x2F;最小的值</h3><blockquote><p>关键字：<code>LIMIT + ORDER BY</code></p></blockquote><pre><code class="language-sql">-- 取销量最高的 3 个商品SELECT product_name, salesFROM ProductsORDER BY sales DESCLIMIT 3;</code></pre><h2 id="技巧注意"><a href="#技巧注意" class="headerlink" title="技巧注意"></a>技巧注意</h2><ol><li><p><strong>是或不是</strong>的时候才能用**“is”<strong>，别的时候有</strong>关联关系<strong>还是</strong>用等号和大于小于**才行</p></li><li><p><code>select</code>关键字后面字段之间使用<code>,</code>间隔，但是最后一个字段后面不能加<code>,</code></p></li><li><p>如果<code>from</code>字段后面<strong>有多个表</strong>，那么在where语句中就必须写出这<strong>多表之间的联系</strong>。</p></li><li><p>如果是多表连接，最后的查询结果必须指明是那个表里面的字段（如果这两个表都有该字段）。</p></li><li><p>在使用多个<code>INNER JOIN</code>关键字内连接其他表时，第一个表的字段与第二个表的字段连接，第二个表的字段与第三个表的字段连接。</p><pre><code class="language-sql">select  user_profile.university,question_detail.difficult_level,ROUND(COUNT(question_practice_detail.question_id) / COUNT(DISTINCT user_profile.device_id), 4) AS avg_answer_cntFROM user_profileINNER JOIN question_practice_detailon user_profile.device_id = question_practice_detail.device_idINNER JOIN question_detailon question_practice_detail.question_id = question_detail.question_idgroup by university,difficult_level</code></pre></li><li><p>多表连接中select，group by  ,  order by 子句中的字段最好加上表名</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 政务数据_实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
